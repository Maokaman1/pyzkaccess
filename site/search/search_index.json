{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"pyzkaccess pyzkaccess is small library for low-level operating the ZKTeco ZKAccess C3 family access control panels. Python 3 is used. Now implemented: Relay switching Device inputs state read and events retrieving The ZKTeco's PULL SDK (plcommpro.dll) is used as machinery. Therefore the code must execute in Windows environment or Wine. Tested on C3-400. Installing pip3 install -r requirements.txt SDK installing First, download current version of PULL SDK: ZKTeco software downloads . Extract archive and place all pl .dll files to the system directory, usually windows/system32*. On *nix systems you can use Wine. Usage Turn on the relay: from pyzkaccess import ZKAccess , RelayGroup connstr = b 'protocol=TCP,ipaddress=172.16.1.1,port=4370,timeout=4000,passwd=' with ZKAccess ( 'plcommpro.dll' , connstr ) as zk : zk . enable_relay ( RelayGroup . lock , 1 , 16 ) # Turn on the first relay in 'lock' group for 16 seconds Read aux input state: import time from pyzkaccess import ZKAccess connstr = b 'protocol=TCP,ipaddress=172.16.1.1,port=4370,timeout=4000,passwd=' with ZKAccess ( 'plcommpro.dll' , connstr ) as zk : while ( 1 ): events = zk . read_events () for e in events : if e . event_type == '221' and e . door == '1' : print ( \"Auxiliary input on door {} shorted at {}\" . format ( e . door , e . time )) elif e . event_type == '220' and e . door == '1' : print ( \"Auxiliary input on door {} released at {}\" . format ( e . door , e . time )) time . sleep ( 1 ) The default model is C3-400. How to use another model, e.g. C3-200: from pyzkaccess import ZKAccess , ZK200 connstr = b 'protocol=TCP,ipaddress=172.16.1.1,port=4370,timeout=4000,passwd=' with ZKAccess ( 'plcommpro.dll' , connstr , device_model = ZK200 ) as zk : ... Author Igor Derkach, gosha753951@gmail.com Bugs Please report any bugs or feature requests to the author.","title":"Home"},{"location":"#pyzkaccess","text":"pyzkaccess is small library for low-level operating the ZKTeco ZKAccess C3 family access control panels. Python 3 is used. Now implemented: Relay switching Device inputs state read and events retrieving The ZKTeco's PULL SDK (plcommpro.dll) is used as machinery. Therefore the code must execute in Windows environment or Wine. Tested on C3-400.","title":"pyzkaccess"},{"location":"#installing","text":"pip3 install -r requirements.txt","title":"Installing"},{"location":"#sdk-installing","text":"First, download current version of PULL SDK: ZKTeco software downloads . Extract archive and place all pl .dll files to the system directory, usually windows/system32*. On *nix systems you can use Wine.","title":"SDK installing"},{"location":"#usage","text":"Turn on the relay: from pyzkaccess import ZKAccess , RelayGroup connstr = b 'protocol=TCP,ipaddress=172.16.1.1,port=4370,timeout=4000,passwd=' with ZKAccess ( 'plcommpro.dll' , connstr ) as zk : zk . enable_relay ( RelayGroup . lock , 1 , 16 ) # Turn on the first relay in 'lock' group for 16 seconds Read aux input state: import time from pyzkaccess import ZKAccess connstr = b 'protocol=TCP,ipaddress=172.16.1.1,port=4370,timeout=4000,passwd=' with ZKAccess ( 'plcommpro.dll' , connstr ) as zk : while ( 1 ): events = zk . read_events () for e in events : if e . event_type == '221' and e . door == '1' : print ( \"Auxiliary input on door {} shorted at {}\" . format ( e . door , e . time )) elif e . event_type == '220' and e . door == '1' : print ( \"Auxiliary input on door {} released at {}\" . format ( e . door , e . time )) time . sleep ( 1 ) The default model is C3-400. How to use another model, e.g. C3-200: from pyzkaccess import ZKAccess , ZK200 connstr = b 'protocol=TCP,ipaddress=172.16.1.1,port=4370,timeout=4000,passwd=' with ZKAccess ( 'plcommpro.dll' , connstr , device_model = ZK200 ) as zk : ...","title":"Usage"},{"location":"#author","text":"Igor Derkach, gosha753951@gmail.com","title":"Author"},{"location":"#bugs","text":"Please report any bugs or feature requests to the author.","title":"Bugs"},{"location":"docs/installing/","text":"Installing Requirements: python >= 3.5 wrapt PULL SDK Download current version of PULL SDK: ZKTeco software downloads . Downloaded archive contains pl*.dll DLL files and documentation. *nix First, you will need to set up Wine (32-bit) environment (commands for Debian/Ubuntu): apt-get install wine Next install the last Python version for Windows : wine python-3.8.5.exe Make sure you checked the box \"Add executable to PATH variable\" . Next install the library: wine pip install pyzkaccess Finally, copy pl*.dll files from SDK archive to Wine system32 directory, usually it is /home/user/.wine/drive_c/windows/system32 . Executing the regsvr32 is not needed. (Sometimes Wine doesn't see dll files even if you copied them right. In this case you can run wine explorer.exe and move these files using it) Windows Install the last Python version for Windows . Next open command window and install library from pip: pip install pyzkaccess Finally, copy pl*.dll files from SDK archive to system32 directory, usually it is C:\\Windows\\System32 . Executing the regsvr32 is not needed.","title":"Installing"},{"location":"docs/installing/#installing","text":"Requirements: python >= 3.5 wrapt","title":"Installing"},{"location":"docs/installing/#pull-sdk","text":"Download current version of PULL SDK: ZKTeco software downloads . Downloaded archive contains pl*.dll DLL files and documentation.","title":"PULL SDK"},{"location":"docs/installing/#nix","text":"First, you will need to set up Wine (32-bit) environment (commands for Debian/Ubuntu): apt-get install wine Next install the last Python version for Windows : wine python-3.8.5.exe Make sure you checked the box \"Add executable to PATH variable\" . Next install the library: wine pip install pyzkaccess Finally, copy pl*.dll files from SDK archive to Wine system32 directory, usually it is /home/user/.wine/drive_c/windows/system32 . Executing the regsvr32 is not needed. (Sometimes Wine doesn't see dll files even if you copied them right. In this case you can run wine explorer.exe and move these files using it)","title":"*nix"},{"location":"docs/installing/#windows","text":"Install the last Python version for Windows . Next open command window and install library from pip: pip install pyzkaccess Finally, copy pl*.dll files from SDK archive to system32 directory, usually it is C:\\Windows\\System32 . Executing the regsvr32 is not needed.","title":"Windows"},{"location":"docs/summary/","text":"PyZKAccess PyZKAccess is a library for working with ZKTeco ZKAccess C3-100/200/400 access controllers. The ZKTeco PULL SDK is used as machinery. Therefore the code is executed in Windows environment. *nix are also supported using Wine. Features Relays switching Reading events of whole device or separately for certain reader, aux input or even door Getting/setting the device parameters such as datetime, network settings, entry modes, backup time, etc. Getting/setting a door parameters such as smart card modes, intervals, entry modes, etc. Scanning the local network in searching for active C3 devices Restarting a device Here are the controllers we're taking about: C3-100 C3-200 C3-400 To be implemented Pulling data from a device with filtering support (cards, ACL, holidays and timezone info, access history, i/o table) Uploading data to a device (the same) CLI interface Downloading/uploading files from PC to/from a device Restoring from SD card backup Cancelling alarm function Emergency resetting network settings NOTE : the version pyzkaccess>=0.2 is incompatible with pyzkaccess==0.1 Author Igor Derkach, gosha753951@gmail.com","title":"Summary"},{"location":"docs/summary/#pyzkaccess","text":"PyZKAccess is a library for working with ZKTeco ZKAccess C3-100/200/400 access controllers. The ZKTeco PULL SDK is used as machinery. Therefore the code is executed in Windows environment. *nix are also supported using Wine.","title":"PyZKAccess"},{"location":"docs/summary/#features","text":"Relays switching Reading events of whole device or separately for certain reader, aux input or even door Getting/setting the device parameters such as datetime, network settings, entry modes, backup time, etc. Getting/setting a door parameters such as smart card modes, intervals, entry modes, etc. Scanning the local network in searching for active C3 devices Restarting a device Here are the controllers we're taking about: C3-100 C3-200 C3-400","title":"Features"},{"location":"docs/summary/#to-be-implemented","text":"Pulling data from a device with filtering support (cards, ACL, holidays and timezone info, access history, i/o table) Uploading data to a device (the same) CLI interface Downloading/uploading files from PC to/from a device Restoring from SD card backup Cancelling alarm function Emergency resetting network settings NOTE : the version pyzkaccess>=0.2 is incompatible with pyzkaccess==0.1","title":"To be implemented"},{"location":"docs/summary/#author","text":"Igor Derkach, gosha753951@gmail.com","title":"Author"},{"location":"docs/usage/","text":"Usage Quick start The default factory ip of C3 devices is 192.168.1.201 . from pyzkaccess import ZKAccess connstr = 'protocol=TCP,ipaddress=192.168.1.201,port=4370,timeout=4000,passwd=' zk = ZKAccess ( connstr = connstr ) print ( 'Device SN:' , zk . parameters . serial_number , 'IP:' , zk . parameters . ip_address ) # Turn on relays in \"lock\" group for 5 seconds zk . relays . lock . switch_on ( 5 ) # Wait for any card will be given to reader on door 1 card = None while not card : for door1_event in zk . doors [ 0 ] . events . poll ( timeout = 60 ): print ( door1_event ) if door1_event . card and door1_event . card != '0' : print ( 'Got card #' , door1_event . card ) card = door1_event . card # Switch on both relays on door 1 zk . doors [ 0 ] . relays . switch_on ( 5 ) # After that the device will be restarted zk . restart () zk . disconnect () Working with a device Use as context manager from pyzkaccess import ZKAccess connstr = 'protocol=TCP,ipaddress=192.168.1.201,port=4370,timeout=4000,passwd=' with ZKAccess ( connstr = connstr ) as zk : print ( zk . parameters . ip_address ) Find a device in local network and connect to it from pyzkaccess import ZKAccess found = ZKAccess . search_devices ( '192.168.1.255' ) print ( len ( found ), 'devices found' ) if found : # Pick the first found device device = found [ 0 ] with ZKAccess ( device = device ) as zk : print ( zk . parameters . ip_address ) Default model is C3-400. Use another model from pyzkaccess import ZKAccess , ZK200 connstr = 'protocol=TCP,ipaddress=192.168.1.201,port=4370,timeout=4000,passwd=' with ZKAccess ( connstr = connstr , device_model = ZK200 ) as zk : print ( zk . parameters . ip_address ) Set current datetime from pyzkaccess import ZKAccess from datetime import datetime connstr = 'protocol=TCP,ipaddress=192.168.1.201,port=4370,timeout=4000,passwd=' with ZKAccess ( connstr = connstr ) as zk : zk . parameters . datetime = datetime . now () Change ip settings from pyzkaccess import ZKAccess connstr = 'protocol=TCP,ipaddress=192.168.1.201,port=4370,timeout=4000,passwd=' with ZKAccess ( connstr = connstr ) as zk : zk . parameters . gateway_ip_address = '172.31.255.254' zk . parameters . netmask = '255.240.0.0' zk . parameters . ip_address = '172.17.10.2' Relays The main operation which we can do with a relay is switch on it for given count of seconds (0..255). Relays number corresponds to its number on board starting from aux relay group. A relay can be accessed by various variants: zk.relays.switch_on(5) # All relays zk.relays[0].switch_on(5) # By index zk.relays[1:3].switch_on(5) # By range zk.doors[0].relays[0].switch_on(5) # By number of door which it belongs to zk.relays[0].aux.switch_on(5) # By group zk.relays[0].aux[1].switch_on(5) # By index in group zk.relays.by_mask([1, 0, 1, 0, 0, 0, 0, 0]).switch_on(5) # By mask Readers The main operation for readers is reading its events. Reader number is denoted on board. They can be accessed by several ways: zk.readers.events.refresh() # All readers zk.readers[0].events.refresh() # By index zk.readers[1:3].events.refresh() # By range zk.readers[1:3].events.poll() # Await events for readers 2 and 3 zk.doors[0].reader.events.refresh() # By number of door which it belongs to Aux inputs As for readers, the main operations for aux inputs is reading events. The number of aux input is also denoted on board. zk.aux_inputs.events.refresh() # All aux inputs zk.aux_inputs[0].events.refresh() # By index zk.aux_inputs[1:3].events.refresh() # By range zk.aux_inputs[1:3].events.poll() # Await events for aux inputs 2 and 3 zk.doors[0].aux_input.events.refresh() # By number of door which it belongs to Events Events which occured on a device are accessible through .events property. C3 controller keeps maximum 30 unread events. Events begin registered starting from device connecting. Event log should be refreshed manually using refresh() method. Due to restriction of maximum 30 entries described above you should call refresh() pretty ofter in order to avoid missing. Another way to obtain events is poll() method which awaits new log entries by doing periodical refresh and returns new events if any. Event log is available in several places. For ZKAccess object it keeps all events occured on device. Readers also give access to events which are related to this reader. Doors and aux inputs too. Under the hood these properties use the same event list which keeps all device events, but each apply its own filter to this list. zk . events # Event log with all events occured on device zk . events . refresh () # Get unread events from device zk . events . poll () # Wait until any event will occur zk . door . events # Event log for all doors ( exluding auto open door by time for instance ) zk . aux_inputs . events # Event log related to aux inputs only zk . readers . events # Event log related to readers only # More complex # Wait until event related to the reader of Door 1 will occur zk . door [ 0 ]. reader . events . poll () # Wait until unregistered card ( event_type 27 ) with given number will appear on reader of Door 1 zk . door [ 0 ]. reader . events . only ( card = '123456' , event_type = 27 ). poll () # Take all records from log with given card which was occur after 2010 - 10 - 11 14 : 28 : 04 zk . events . only ( card = '123456' ). after_time ( datetime ( 2010 , 10 , 11 , 14 , 28 , 4 ))","title":"Usage"},{"location":"docs/usage/#usage","text":"","title":"Usage"},{"location":"docs/usage/#quick-start","text":"The default factory ip of C3 devices is 192.168.1.201 . from pyzkaccess import ZKAccess connstr = 'protocol=TCP,ipaddress=192.168.1.201,port=4370,timeout=4000,passwd=' zk = ZKAccess ( connstr = connstr ) print ( 'Device SN:' , zk . parameters . serial_number , 'IP:' , zk . parameters . ip_address ) # Turn on relays in \"lock\" group for 5 seconds zk . relays . lock . switch_on ( 5 ) # Wait for any card will be given to reader on door 1 card = None while not card : for door1_event in zk . doors [ 0 ] . events . poll ( timeout = 60 ): print ( door1_event ) if door1_event . card and door1_event . card != '0' : print ( 'Got card #' , door1_event . card ) card = door1_event . card # Switch on both relays on door 1 zk . doors [ 0 ] . relays . switch_on ( 5 ) # After that the device will be restarted zk . restart () zk . disconnect ()","title":"Quick start"},{"location":"docs/usage/#working-with-a-device","text":"","title":"Working with a device"},{"location":"docs/usage/#use-as-context-manager","text":"from pyzkaccess import ZKAccess connstr = 'protocol=TCP,ipaddress=192.168.1.201,port=4370,timeout=4000,passwd=' with ZKAccess ( connstr = connstr ) as zk : print ( zk . parameters . ip_address )","title":"Use as context manager"},{"location":"docs/usage/#find-a-device-in-local-network-and-connect-to-it","text":"from pyzkaccess import ZKAccess found = ZKAccess . search_devices ( '192.168.1.255' ) print ( len ( found ), 'devices found' ) if found : # Pick the first found device device = found [ 0 ] with ZKAccess ( device = device ) as zk : print ( zk . parameters . ip_address )","title":"Find a device in local network and connect to it"},{"location":"docs/usage/#default-model-is-c3-400-use-another-model","text":"from pyzkaccess import ZKAccess , ZK200 connstr = 'protocol=TCP,ipaddress=192.168.1.201,port=4370,timeout=4000,passwd=' with ZKAccess ( connstr = connstr , device_model = ZK200 ) as zk : print ( zk . parameters . ip_address )","title":"Default model is C3-400. Use another model"},{"location":"docs/usage/#set-current-datetime","text":"from pyzkaccess import ZKAccess from datetime import datetime connstr = 'protocol=TCP,ipaddress=192.168.1.201,port=4370,timeout=4000,passwd=' with ZKAccess ( connstr = connstr ) as zk : zk . parameters . datetime = datetime . now ()","title":"Set current datetime"},{"location":"docs/usage/#change-ip-settings","text":"from pyzkaccess import ZKAccess connstr = 'protocol=TCP,ipaddress=192.168.1.201,port=4370,timeout=4000,passwd=' with ZKAccess ( connstr = connstr ) as zk : zk . parameters . gateway_ip_address = '172.31.255.254' zk . parameters . netmask = '255.240.0.0' zk . parameters . ip_address = '172.17.10.2'","title":"Change ip settings"},{"location":"docs/usage/#relays","text":"The main operation which we can do with a relay is switch on it for given count of seconds (0..255). Relays number corresponds to its number on board starting from aux relay group. A relay can be accessed by various variants: zk.relays.switch_on(5) # All relays zk.relays[0].switch_on(5) # By index zk.relays[1:3].switch_on(5) # By range zk.doors[0].relays[0].switch_on(5) # By number of door which it belongs to zk.relays[0].aux.switch_on(5) # By group zk.relays[0].aux[1].switch_on(5) # By index in group zk.relays.by_mask([1, 0, 1, 0, 0, 0, 0, 0]).switch_on(5) # By mask","title":"Relays"},{"location":"docs/usage/#readers","text":"The main operation for readers is reading its events. Reader number is denoted on board. They can be accessed by several ways: zk.readers.events.refresh() # All readers zk.readers[0].events.refresh() # By index zk.readers[1:3].events.refresh() # By range zk.readers[1:3].events.poll() # Await events for readers 2 and 3 zk.doors[0].reader.events.refresh() # By number of door which it belongs to","title":"Readers"},{"location":"docs/usage/#aux-inputs","text":"As for readers, the main operations for aux inputs is reading events. The number of aux input is also denoted on board. zk.aux_inputs.events.refresh() # All aux inputs zk.aux_inputs[0].events.refresh() # By index zk.aux_inputs[1:3].events.refresh() # By range zk.aux_inputs[1:3].events.poll() # Await events for aux inputs 2 and 3 zk.doors[0].aux_input.events.refresh() # By number of door which it belongs to","title":"Aux inputs"},{"location":"docs/usage/#events","text":"Events which occured on a device are accessible through .events property. C3 controller keeps maximum 30 unread events. Events begin registered starting from device connecting. Event log should be refreshed manually using refresh() method. Due to restriction of maximum 30 entries described above you should call refresh() pretty ofter in order to avoid missing. Another way to obtain events is poll() method which awaits new log entries by doing periodical refresh and returns new events if any. Event log is available in several places. For ZKAccess object it keeps all events occured on device. Readers also give access to events which are related to this reader. Doors and aux inputs too. Under the hood these properties use the same event list which keeps all device events, but each apply its own filter to this list. zk . events # Event log with all events occured on device zk . events . refresh () # Get unread events from device zk . events . poll () # Wait until any event will occur zk . door . events # Event log for all doors ( exluding auto open door by time for instance ) zk . aux_inputs . events # Event log related to aux inputs only zk . readers . events # Event log related to readers only # More complex # Wait until event related to the reader of Door 1 will occur zk . door [ 0 ]. reader . events . poll () # Wait until unregistered card ( event_type 27 ) with given number will appear on reader of Door 1 zk . door [ 0 ]. reader . events . only ( card = '123456' , event_type = 27 ). poll () # Take all records from log with given card which was occur after 2010 - 10 - 11 14 : 28 : 04 zk . events . only ( card = '123456' ). after_time ( datetime ( 2010 , 10 , 11 , 14 , 28 , 4 ))","title":"Events"},{"location":"reference/pyzkaccess/","text":"Module pyzkaccess View Source from .aux_input import * from .common import * from .device import * from .door import * from .enum import * from .event import * from .exceptions import * from .param import * from .pyzkaccess import * from .reader import * from .relay import * from .sdk import * Sub-modules pyzkaccess.aux_input pyzkaccess.common pyzkaccess.ctypes pyzkaccess.device pyzkaccess.door pyzkaccess.enum pyzkaccess.event pyzkaccess.exceptions pyzkaccess.param pyzkaccess.pyzkaccess pyzkaccess.reader pyzkaccess.relay pyzkaccess.sdk Classes DocValue class DocValue ( value : Union [ str , int ], doc : str ) Ancestors (in MRO) builtins.ObjectProxy Instance variables doc Documentation of a value value Exposed value","title":"Index"},{"location":"reference/pyzkaccess/#module-pyzkaccess","text":"View Source from .aux_input import * from .common import * from .device import * from .door import * from .enum import * from .event import * from .exceptions import * from .param import * from .pyzkaccess import * from .reader import * from .relay import * from .sdk import *","title":"Module pyzkaccess"},{"location":"reference/pyzkaccess/#sub-modules","text":"pyzkaccess.aux_input pyzkaccess.common pyzkaccess.ctypes pyzkaccess.device pyzkaccess.door pyzkaccess.enum pyzkaccess.event pyzkaccess.exceptions pyzkaccess.param pyzkaccess.pyzkaccess pyzkaccess.reader pyzkaccess.relay pyzkaccess.sdk","title":"Sub-modules"},{"location":"reference/pyzkaccess/#classes","text":"","title":"Classes"},{"location":"reference/pyzkaccess/#docvalue","text":"class DocValue ( value : Union [ str , int ], doc : str )","title":"DocValue"},{"location":"reference/pyzkaccess/#ancestors-in-mro","text":"builtins.ObjectProxy","title":"Ancestors (in MRO)"},{"location":"reference/pyzkaccess/#instance-variables","text":"doc Documentation of a value value Exposed value","title":"Instance variables"},{"location":"reference/pyzkaccess/aux_input/","text":"Module pyzkaccess.aux_input View Source __all__ = [ 'AuxInput' , 'AuxInputList' ] from abc import ABCMeta , abstractmethod from typing import Iterable from .common import UserTuple from .event import EventLog from .sdk import ZKSDK class AuxInputInterface ( metaclass = ABCMeta ): event_types = ( 220 , 221 ) @property def events ( self ) -> EventLog : \"\"\"Event log of current aux input\"\"\" return self . _specific_event_log () @abstractmethod def _specific_event_log ( self ) -> EventLog : pass class AuxInput ( AuxInputInterface ): \"\"\"Concrete auxiliary input\"\"\" def __init__ ( self , sdk : ZKSDK , event_log : EventLog , number : int ): self . number = number self . _sdk = sdk self . _event_log = event_log def _specific_event_log ( self ) -> EventLog : return self . _event_log . only ( door = [ self . number ], event_type = self . event_types ) def __eq__ ( self , other ): if isinstance ( other , AuxInput ): return self . number == other . number and self . _sdk is other . _sdk return False def __ne__ ( self , other ): return not self . __eq__ ( other ) def __str__ ( self ): return \"AuxInput[{}]\" . format ( self . number ) def __repr__ ( self ): return self . __str__ () class AuxInputList ( AuxInputInterface , UserTuple ): \"\"\"Collection of aux input objects which is used to perform group operations over multiple aux inputs \"\"\" def __init__ ( self , sdk : ZKSDK , event_log : EventLog , aux_inputs : Iterable [ AuxInput ] = ()): super () . __init__ ( aux_inputs ) self . _sdk = sdk self . _event_log = event_log def __getitem__ ( self , item ): aux_inputs = self . data [ item ] if isinstance ( item , slice ): return self . __class__ ( self . _sdk , self . _event_log , aux_inputs = aux_inputs ) else : return aux_inputs def _specific_event_log ( self ) -> EventLog : doors = set ( x . number for x in self ) return self . _event_log . only ( door = doors , event_type = self . event_types ) Classes AuxInput class AuxInput ( sdk : pyzkaccess . sdk . ZKSDK , event_log : pyzkaccess . event . EventLog , number : int ) Concrete auxiliary input View Source class AuxInput ( AuxInputInterface ): \"\"\"Concrete auxiliary input\"\"\" def __init__ ( self , sdk: ZKSDK , event_log: EventLog , number: int ): self . number = number self . _sdk = sdk self . _event_log = event_log def _specific_event_log ( self ) -> EventLog: return self . _event_log . only ( door =[ self . number ], event_type = self . event_types ) def __eq__ ( self , other ): if isinstance ( other , AuxInput ): return self . number == other . number and self . _sdk is other . _sdk return False def __ne__ ( self , other ): return not self . __eq__ ( other ) def __str__ ( self ): return \"AuxInput[{}]\" . format ( self . number ) def __repr__ ( self ): return self . __str__ () Ancestors (in MRO) pyzkaccess.aux_input.AuxInputInterface Class variables event_types Instance variables events Event log of current aux input AuxInputList class AuxInputList ( sdk : pyzkaccess . sdk . ZKSDK , event_log : pyzkaccess . event . EventLog , aux_inputs : Iterable [ pyzkaccess . aux_input . AuxInput ] = () ) Collection of aux input objects which is used to perform group operations over multiple aux inputs View Source class AuxInputList ( AuxInputInterface , UserTuple ) : \"\"\"Collection of aux input objects which is used to perform group operations over multiple aux inputs \"\"\" def __init__ ( self , sdk : ZKSDK , event_log : EventLog , aux_inputs : Iterable [ AuxInput ] = ()) : super (). __init__ ( aux_inputs ) self . _sdk = sdk self . _event_log = event_log def __getitem__ ( self , item ) : aux_inputs = self . data [ item ] if isinstance ( item , slice ) : return self . __class__ ( self . _sdk , self . _event_log , aux_inputs = aux_inputs ) else : return aux_inputs def _specific_event_log ( self ) -> EventLog : doors = set ( x . number for x in self ) return self . _event_log . only ( door = doors , event_type = self . event_types ) Ancestors (in MRO) pyzkaccess.aux_input.AuxInputInterface pyzkaccess.common.UserTuple Class variables event_types Instance variables events Event log of current aux input Methods copy def copy ( self ) View Source def copy(self): return self.__class__(self) count def count ( self , item ) View Source def count(self, item): return self.data.count(item) index def index ( self , item , * args ) View Source def index(self, item, *args): return self.data.index(item, *args)","title":"Aux Input"},{"location":"reference/pyzkaccess/aux_input/#module-pyzkaccessaux_input","text":"View Source __all__ = [ 'AuxInput' , 'AuxInputList' ] from abc import ABCMeta , abstractmethod from typing import Iterable from .common import UserTuple from .event import EventLog from .sdk import ZKSDK class AuxInputInterface ( metaclass = ABCMeta ): event_types = ( 220 , 221 ) @property def events ( self ) -> EventLog : \"\"\"Event log of current aux input\"\"\" return self . _specific_event_log () @abstractmethod def _specific_event_log ( self ) -> EventLog : pass class AuxInput ( AuxInputInterface ): \"\"\"Concrete auxiliary input\"\"\" def __init__ ( self , sdk : ZKSDK , event_log : EventLog , number : int ): self . number = number self . _sdk = sdk self . _event_log = event_log def _specific_event_log ( self ) -> EventLog : return self . _event_log . only ( door = [ self . number ], event_type = self . event_types ) def __eq__ ( self , other ): if isinstance ( other , AuxInput ): return self . number == other . number and self . _sdk is other . _sdk return False def __ne__ ( self , other ): return not self . __eq__ ( other ) def __str__ ( self ): return \"AuxInput[{}]\" . format ( self . number ) def __repr__ ( self ): return self . __str__ () class AuxInputList ( AuxInputInterface , UserTuple ): \"\"\"Collection of aux input objects which is used to perform group operations over multiple aux inputs \"\"\" def __init__ ( self , sdk : ZKSDK , event_log : EventLog , aux_inputs : Iterable [ AuxInput ] = ()): super () . __init__ ( aux_inputs ) self . _sdk = sdk self . _event_log = event_log def __getitem__ ( self , item ): aux_inputs = self . data [ item ] if isinstance ( item , slice ): return self . __class__ ( self . _sdk , self . _event_log , aux_inputs = aux_inputs ) else : return aux_inputs def _specific_event_log ( self ) -> EventLog : doors = set ( x . number for x in self ) return self . _event_log . only ( door = doors , event_type = self . event_types )","title":"Module pyzkaccess.aux_input"},{"location":"reference/pyzkaccess/aux_input/#classes","text":"","title":"Classes"},{"location":"reference/pyzkaccess/aux_input/#auxinput","text":"class AuxInput ( sdk : pyzkaccess . sdk . ZKSDK , event_log : pyzkaccess . event . EventLog , number : int ) Concrete auxiliary input View Source class AuxInput ( AuxInputInterface ): \"\"\"Concrete auxiliary input\"\"\" def __init__ ( self , sdk: ZKSDK , event_log: EventLog , number: int ): self . number = number self . _sdk = sdk self . _event_log = event_log def _specific_event_log ( self ) -> EventLog: return self . _event_log . only ( door =[ self . number ], event_type = self . event_types ) def __eq__ ( self , other ): if isinstance ( other , AuxInput ): return self . number == other . number and self . _sdk is other . _sdk return False def __ne__ ( self , other ): return not self . __eq__ ( other ) def __str__ ( self ): return \"AuxInput[{}]\" . format ( self . number ) def __repr__ ( self ): return self . __str__ ()","title":"AuxInput"},{"location":"reference/pyzkaccess/aux_input/#ancestors-in-mro","text":"pyzkaccess.aux_input.AuxInputInterface","title":"Ancestors (in MRO)"},{"location":"reference/pyzkaccess/aux_input/#class-variables","text":"event_types","title":"Class variables"},{"location":"reference/pyzkaccess/aux_input/#instance-variables","text":"events Event log of current aux input","title":"Instance variables"},{"location":"reference/pyzkaccess/aux_input/#auxinputlist","text":"class AuxInputList ( sdk : pyzkaccess . sdk . ZKSDK , event_log : pyzkaccess . event . EventLog , aux_inputs : Iterable [ pyzkaccess . aux_input . AuxInput ] = () ) Collection of aux input objects which is used to perform group operations over multiple aux inputs View Source class AuxInputList ( AuxInputInterface , UserTuple ) : \"\"\"Collection of aux input objects which is used to perform group operations over multiple aux inputs \"\"\" def __init__ ( self , sdk : ZKSDK , event_log : EventLog , aux_inputs : Iterable [ AuxInput ] = ()) : super (). __init__ ( aux_inputs ) self . _sdk = sdk self . _event_log = event_log def __getitem__ ( self , item ) : aux_inputs = self . data [ item ] if isinstance ( item , slice ) : return self . __class__ ( self . _sdk , self . _event_log , aux_inputs = aux_inputs ) else : return aux_inputs def _specific_event_log ( self ) -> EventLog : doors = set ( x . number for x in self ) return self . _event_log . only ( door = doors , event_type = self . event_types )","title":"AuxInputList"},{"location":"reference/pyzkaccess/aux_input/#ancestors-in-mro_1","text":"pyzkaccess.aux_input.AuxInputInterface pyzkaccess.common.UserTuple","title":"Ancestors (in MRO)"},{"location":"reference/pyzkaccess/aux_input/#class-variables_1","text":"event_types","title":"Class variables"},{"location":"reference/pyzkaccess/aux_input/#instance-variables_1","text":"events Event log of current aux input","title":"Instance variables"},{"location":"reference/pyzkaccess/aux_input/#methods","text":"","title":"Methods"},{"location":"reference/pyzkaccess/aux_input/#copy","text":"def copy ( self ) View Source def copy(self): return self.__class__(self)","title":"copy"},{"location":"reference/pyzkaccess/aux_input/#count","text":"def count ( self , item ) View Source def count(self, item): return self.data.count(item)","title":"count"},{"location":"reference/pyzkaccess/aux_input/#index","text":"def index ( self , item , * args ) View Source def index(self, item, *args): return self.data.index(item, *args)","title":"index"},{"location":"reference/pyzkaccess/common/","text":"Module pyzkaccess.common View Source __all__ = [ 'UserTuple' , 'DocValue' , 'DocDict' ] from copy import copy , deepcopy from typing import Sequence , Union , Iterable from wrapt import ObjectProxy from wrapt.wrappers import _ObjectProxyMetaType # noqa class UserTuple : \"\"\"Immutable version of `collections.UserList` from the stdlib\"\"\" def __init__ ( self , initlist : Union [ Sequence , Iterable , 'UserTuple' ] = None ): self . data = tuple () if initlist is not None : # XXX should this accept an arbitrary sequence? if isinstance ( initlist , tuple ): self . data = initlist elif isinstance ( initlist , UserTuple ): self . data = copy ( initlist . data ) else : self . data = tuple ( initlist ) def __repr__ ( self ): return repr ( self . data ) def __lt__ ( self , other ): return self . data < self . __cast ( other ) # noqa def __le__ ( self , other ): return self . data <= self . __cast ( other ) def __eq__ ( self , other ): return self . data == self . __cast ( other ) def __gt__ ( self , other ): return self . data > self . __cast ( other ) # noqa def __ge__ ( self , other ): return self . data >= self . __cast ( other ) def __cast ( self , other ): return other . data if isinstance ( other , UserTuple ) else other def __contains__ ( self , item ): return item in self . data def __len__ ( self ): return len ( self . data ) def __getitem__ ( self , i ): if isinstance ( i , slice ): return self . __class__ ( self . data [ i ]) else : return self . data [ i ] def __add__ ( self , other ): if isinstance ( other , UserTuple ): return self . __class__ ( self . data + other . data ) elif isinstance ( other , type ( self . data )): return self . __class__ ( self . data + other ) return self . __class__ ( self . data + list ( other )) def __radd__ ( self , other ): if isinstance ( other , UserTuple ): return self . __class__ ( other . data + self . data ) elif isinstance ( other , type ( self . data )): return self . __class__ ( other + self . data ) return self . __class__ ( list ( other ) + self . data ) def __iadd__ ( self , other ): if isinstance ( other , UserTuple ): self . data += other . data elif isinstance ( other , type ( self . data )): self . data += other else : self . data += list ( other ) return self def __mul__ ( self , n ): return self . __class__ ( self . data * n ) __rmul__ = __mul__ def __imul__ ( self , n ): self . data *= n return self def __hash__ ( self ): return hash ( self . data ) def __copy__ ( self ): inst = self . __class__ . __new__ ( self . __class__ ) inst . __dict__ . update ( self . __dict__ ) # Create a copy and avoid triggering descriptors inst . __dict__ [ \"data\" ] = self . __dict__ [ \"data\" ][:] return inst def copy ( self ): return self . __class__ ( self ) def count ( self , item ): return self . data . count ( item ) def index ( self , item , * args ): return self . data . index ( item , * args ) class DocValueMeta ( _ObjectProxyMetaType ): def __new__ ( cls , name , bases , attrs ): # Hack: override class creation for proxy object since # ObjectProxy metaclass doesn't allow easily redefine __doc__ def get_doc ( self ): return self . _self_doc if self . _self_doc else self . __wrapped__ . __doc__ doc_prop = property ( get_doc , None , None ) new_class = super () . __new__ ( cls , name , bases , attrs ) type . __setattr__ ( new_class , '__doc__' , doc_prop ) return new_class class DocValue ( ObjectProxy , metaclass = DocValueMeta ): \"\"\"Value of type with custom __doc__ attribute. The main aim is to annotate a value of any type including built-in ones \"\"\" def __init__ ( self , value : Union [ str , int ], doc : str ): \"\"\" :param value: value which was exposed by this object :param doc: documentation string which will be put to __doc__ \"\"\" super () . __init__ ( value ) if not isinstance ( value , ( str , int )): raise TypeError ( 'Init value type must be int or str' ) self . _self_value = value self . _self_doc = doc def __repr__ ( self ): return self . __wrapped__ . __repr__ () @property def value ( self ): \"\"\"Exposed value\"\"\" return self . _self_value @property def doc ( self ): \"\"\"Documentation of a value\"\"\" return self . _self_doc def __copy__ ( self ): obj = DocValue ( copy ( self . _self_value ), copy ( self . _self_doc )) return obj def __deepcopy__ ( self , memodict = None ): obj = DocValue ( deepcopy ( self . _self_value ), deepcopy ( self . _self_doc )) return obj class DocDict ( dict ): \"\"\"DocDict is dictionary, where values are annotated versions of keys. As initial value DocDict accepts a dictionary where dict key is an exposed value and dict value is docstring. >>> d = DocDict({1: 'Docstring 1', '2': 'Docstring 2'}) >>> print(repr(d[1]), repr(d['2'])) 1 '2' >>> print(type(d[1]), type(d['2'])) <class 'DocValue'> <class 'DocValue'> >>> print(d[1] == 1) True >>> print(d['2'] == '2') True >>> print(isinstance(d[1], int), isinstance(d['2'], str)) True True >>> print(d[1].__doc__, ',', d['2'].__doc__) Docstring 1 , Docstring 2 \"\"\" def __init__ ( self , initdict : dict ): super () . __init__ ({ k : DocValue ( k , v ) for k , v in initdict . items ()}) Classes DocDict class DocDict ( initdict : dict ) DocDict is dictionary, where values are annotated versions of keys. As initial value DocDict accepts a dictionary where dict key is an exposed value and dict value is docstring. >>> d = DocDict({1: 'Docstring 1', '2': 'Docstring 2'}) >>> print(repr(d[1]), repr(d['2'])) 1 '2' >>> print(type(d[1]), type(d['2'])) <class 'DocValue'> <class 'DocValue'> >>> print(d[1] == 1) True >>> print(d['2'] == '2') True >>> print(isinstance(d[1], int), isinstance(d['2'], str)) True True >>> print(d[1].__doc__, ',', d['2'].__doc__) Docstring 1 , Docstring 2 View Source class DocDict ( dict ): \"\"\"DocDict is dictionary, where values are annotated versions of keys. As initial value DocDict accepts a dictionary where dict key is an exposed value and dict value is docstring. >>> d = DocDict({1: 'Docstring 1', '2': 'Docstring 2'}) >>> print(repr(d[1]), repr(d['2'])) 1 '2' >>> print(type(d[1]), type(d['2'])) <class 'DocValue'> <class 'DocValue'> >>> print(d[1] == 1) True >>> print(d['2'] == '2') True >>> print(isinstance(d[1], int), isinstance(d['2'], str)) True True >>> print(d[1].__doc__, ',', d['2'].__doc__) Docstring 1 , Docstring 2 \"\"\" def __init__ ( self , initdict: dict ): super (). __init__ ({ k: DocValue ( k , v ) for k , v in initdict . items ()}) Ancestors (in MRO) builtins.dict Methods clear def clear ( ... ) D.clear() -> None. Remove all items from D. copy def copy ( ... ) D.copy() -> a shallow copy of D fromkeys def fromkeys ( iterable , value = None , / ) Create a new dictionary with keys from iterable and values set to value. get def get ( self , key , default = None , / ) Return the value for key if key is in the dictionary, else default. items def items ( ... ) D.items() -> a set-like object providing a view on D's items keys def keys ( ... ) D.keys() -> a set-like object providing a view on D's keys pop def pop ( ... ) D.pop(k[,d]) -> v, remove specified key and return the corresponding value. If key is not found, d is returned if given, otherwise KeyError is raised popitem def popitem ( self , / ) Remove and return a (key, value) pair as a 2-tuple. Pairs are returned in LIFO (last-in, first-out) order. Raises KeyError if the dict is empty. setdefault def setdefault ( self , key , default = None , / ) Insert key with a value of default if key is not in the dictionary. Return the value for key if key is in the dictionary, else default. update def update ( ... ) D.update([E, ]**F) -> None. Update D from dict/iterable E and F. If E is present and has a .keys() method, then does: for k in E: D[k] = E[k] If E is present and lacks a .keys() method, then does: for k, v in E: D[k] = v In either case, this is followed by: for k in F: D[k] = F[k] values def values ( ... ) D.values() -> an object providing a view on D's values DocValue class DocValue ( value : Union [ str , int ], doc : str ) Ancestors (in MRO) builtins.ObjectProxy Instance variables doc Documentation of a value value Exposed value UserTuple class UserTuple ( initlist : Union [ Sequence , Iterable , ForwardRef ( 'UserTuple' )] = None ) Immutable version of collections.UserList from the stdlib View Source class UserTuple : \"\"\"Immutable version of `collections.UserList` from the stdlib\"\"\" def __init__ ( self , initlist : Union [ Sequence, Iterable, 'UserTuple' ] = None ) : self . data = tuple () if initlist is not None : # XXX should this accept an arbitrary sequence ? if isinstance ( initlist , tuple ) : self . data = initlist elif isinstance ( initlist , UserTuple ) : self . data = copy ( initlist . data ) else : self . data = tuple ( initlist ) def __repr__ ( self ) : return repr ( self . data ) def __lt__ ( self , other ) : return self . data < self . __cast ( other ) # noqa def __le__ ( self , other ) : return self . data <= self . __cast ( other ) def __eq__ ( self , other ) : return self . data == self . __cast ( other ) def __gt__ ( self , other ) : return self . data > self . __cast ( other ) # noqa def __ge__ ( self , other ) : return self . data >= self . __cast ( other ) def __cast ( self , other ) : return other . data if isinstance ( other , UserTuple ) else other def __contains__ ( self , item ) : return item in self . data def __len__ ( self ) : return len ( self . data ) def __getitem__ ( self , i ) : if isinstance ( i , slice ) : return self . __class__ ( self . data [ i ] ) else : return self . data [ i ] def __add__ ( self , other ) : if isinstance ( other , UserTuple ) : return self . __class__ ( self . data + other . data ) elif isinstance ( other , type ( self . data )) : return self . __class__ ( self . data + other ) return self . __class__ ( self . data + list ( other )) def __radd__ ( self , other ) : if isinstance ( other , UserTuple ) : return self . __class__ ( other . data + self . data ) elif isinstance ( other , type ( self . data )) : return self . __class__ ( other + self . data ) return self . __class__ ( list ( other ) + self . data ) def __iadd__ ( self , other ) : if isinstance ( other , UserTuple ) : self . data += other . data elif isinstance ( other , type ( self . data )) : self . data += other else : self . data += list ( other ) return self def __mul__ ( self , n ) : return self . __class__ ( self . data * n ) __rmul__ = __mul__ def __imul__ ( self , n ) : self . data *= n return self def __hash__ ( self ) : return hash ( self . data ) def __copy__ ( self ) : inst = self . __class__ . __new__ ( self . __class__ ) inst . __dict__ . update ( self . __dict__ ) # Create a copy and avoid triggering descriptors inst . __dict__ [ \"data\" ] = self . __dict__ [ \"data\" ][ : ] return inst def copy ( self ) : return self . __class__ ( self ) def count ( self , item ) : return self . data . count ( item ) def index ( self , item , * args ) : return self . data . index ( item , * args ) Descendants pyzkaccess.aux_input.AuxInputList pyzkaccess.reader.ReaderList pyzkaccess.relay.RelayList pyzkaccess.door.DoorList Methods copy def copy ( self ) View Source def copy(self): return self.__class__(self) count def count ( self , item ) View Source def count(self, item): return self.data.count(item) index def index ( self , item , * args ) View Source def index(self, item, *args): return self.data.index(item, *args)","title":"Common"},{"location":"reference/pyzkaccess/common/#module-pyzkaccesscommon","text":"View Source __all__ = [ 'UserTuple' , 'DocValue' , 'DocDict' ] from copy import copy , deepcopy from typing import Sequence , Union , Iterable from wrapt import ObjectProxy from wrapt.wrappers import _ObjectProxyMetaType # noqa class UserTuple : \"\"\"Immutable version of `collections.UserList` from the stdlib\"\"\" def __init__ ( self , initlist : Union [ Sequence , Iterable , 'UserTuple' ] = None ): self . data = tuple () if initlist is not None : # XXX should this accept an arbitrary sequence? if isinstance ( initlist , tuple ): self . data = initlist elif isinstance ( initlist , UserTuple ): self . data = copy ( initlist . data ) else : self . data = tuple ( initlist ) def __repr__ ( self ): return repr ( self . data ) def __lt__ ( self , other ): return self . data < self . __cast ( other ) # noqa def __le__ ( self , other ): return self . data <= self . __cast ( other ) def __eq__ ( self , other ): return self . data == self . __cast ( other ) def __gt__ ( self , other ): return self . data > self . __cast ( other ) # noqa def __ge__ ( self , other ): return self . data >= self . __cast ( other ) def __cast ( self , other ): return other . data if isinstance ( other , UserTuple ) else other def __contains__ ( self , item ): return item in self . data def __len__ ( self ): return len ( self . data ) def __getitem__ ( self , i ): if isinstance ( i , slice ): return self . __class__ ( self . data [ i ]) else : return self . data [ i ] def __add__ ( self , other ): if isinstance ( other , UserTuple ): return self . __class__ ( self . data + other . data ) elif isinstance ( other , type ( self . data )): return self . __class__ ( self . data + other ) return self . __class__ ( self . data + list ( other )) def __radd__ ( self , other ): if isinstance ( other , UserTuple ): return self . __class__ ( other . data + self . data ) elif isinstance ( other , type ( self . data )): return self . __class__ ( other + self . data ) return self . __class__ ( list ( other ) + self . data ) def __iadd__ ( self , other ): if isinstance ( other , UserTuple ): self . data += other . data elif isinstance ( other , type ( self . data )): self . data += other else : self . data += list ( other ) return self def __mul__ ( self , n ): return self . __class__ ( self . data * n ) __rmul__ = __mul__ def __imul__ ( self , n ): self . data *= n return self def __hash__ ( self ): return hash ( self . data ) def __copy__ ( self ): inst = self . __class__ . __new__ ( self . __class__ ) inst . __dict__ . update ( self . __dict__ ) # Create a copy and avoid triggering descriptors inst . __dict__ [ \"data\" ] = self . __dict__ [ \"data\" ][:] return inst def copy ( self ): return self . __class__ ( self ) def count ( self , item ): return self . data . count ( item ) def index ( self , item , * args ): return self . data . index ( item , * args ) class DocValueMeta ( _ObjectProxyMetaType ): def __new__ ( cls , name , bases , attrs ): # Hack: override class creation for proxy object since # ObjectProxy metaclass doesn't allow easily redefine __doc__ def get_doc ( self ): return self . _self_doc if self . _self_doc else self . __wrapped__ . __doc__ doc_prop = property ( get_doc , None , None ) new_class = super () . __new__ ( cls , name , bases , attrs ) type . __setattr__ ( new_class , '__doc__' , doc_prop ) return new_class class DocValue ( ObjectProxy , metaclass = DocValueMeta ): \"\"\"Value of type with custom __doc__ attribute. The main aim is to annotate a value of any type including built-in ones \"\"\" def __init__ ( self , value : Union [ str , int ], doc : str ): \"\"\" :param value: value which was exposed by this object :param doc: documentation string which will be put to __doc__ \"\"\" super () . __init__ ( value ) if not isinstance ( value , ( str , int )): raise TypeError ( 'Init value type must be int or str' ) self . _self_value = value self . _self_doc = doc def __repr__ ( self ): return self . __wrapped__ . __repr__ () @property def value ( self ): \"\"\"Exposed value\"\"\" return self . _self_value @property def doc ( self ): \"\"\"Documentation of a value\"\"\" return self . _self_doc def __copy__ ( self ): obj = DocValue ( copy ( self . _self_value ), copy ( self . _self_doc )) return obj def __deepcopy__ ( self , memodict = None ): obj = DocValue ( deepcopy ( self . _self_value ), deepcopy ( self . _self_doc )) return obj class DocDict ( dict ): \"\"\"DocDict is dictionary, where values are annotated versions of keys. As initial value DocDict accepts a dictionary where dict key is an exposed value and dict value is docstring. >>> d = DocDict({1: 'Docstring 1', '2': 'Docstring 2'}) >>> print(repr(d[1]), repr(d['2'])) 1 '2' >>> print(type(d[1]), type(d['2'])) <class 'DocValue'> <class 'DocValue'> >>> print(d[1] == 1) True >>> print(d['2'] == '2') True >>> print(isinstance(d[1], int), isinstance(d['2'], str)) True True >>> print(d[1].__doc__, ',', d['2'].__doc__) Docstring 1 , Docstring 2 \"\"\" def __init__ ( self , initdict : dict ): super () . __init__ ({ k : DocValue ( k , v ) for k , v in initdict . items ()})","title":"Module pyzkaccess.common"},{"location":"reference/pyzkaccess/common/#classes","text":"","title":"Classes"},{"location":"reference/pyzkaccess/common/#docdict","text":"class DocDict ( initdict : dict ) DocDict is dictionary, where values are annotated versions of keys. As initial value DocDict accepts a dictionary where dict key is an exposed value and dict value is docstring. >>> d = DocDict({1: 'Docstring 1', '2': 'Docstring 2'}) >>> print(repr(d[1]), repr(d['2'])) 1 '2' >>> print(type(d[1]), type(d['2'])) <class 'DocValue'> <class 'DocValue'> >>> print(d[1] == 1) True >>> print(d['2'] == '2') True >>> print(isinstance(d[1], int), isinstance(d['2'], str)) True True >>> print(d[1].__doc__, ',', d['2'].__doc__) Docstring 1 , Docstring 2 View Source class DocDict ( dict ): \"\"\"DocDict is dictionary, where values are annotated versions of keys. As initial value DocDict accepts a dictionary where dict key is an exposed value and dict value is docstring. >>> d = DocDict({1: 'Docstring 1', '2': 'Docstring 2'}) >>> print(repr(d[1]), repr(d['2'])) 1 '2' >>> print(type(d[1]), type(d['2'])) <class 'DocValue'> <class 'DocValue'> >>> print(d[1] == 1) True >>> print(d['2'] == '2') True >>> print(isinstance(d[1], int), isinstance(d['2'], str)) True True >>> print(d[1].__doc__, ',', d['2'].__doc__) Docstring 1 , Docstring 2 \"\"\" def __init__ ( self , initdict: dict ): super (). __init__ ({ k: DocValue ( k , v ) for k , v in initdict . items ()})","title":"DocDict"},{"location":"reference/pyzkaccess/common/#ancestors-in-mro","text":"builtins.dict","title":"Ancestors (in MRO)"},{"location":"reference/pyzkaccess/common/#methods","text":"","title":"Methods"},{"location":"reference/pyzkaccess/common/#clear","text":"def clear ( ... ) D.clear() -> None. Remove all items from D.","title":"clear"},{"location":"reference/pyzkaccess/common/#copy","text":"def copy ( ... ) D.copy() -> a shallow copy of D","title":"copy"},{"location":"reference/pyzkaccess/common/#fromkeys","text":"def fromkeys ( iterable , value = None , / ) Create a new dictionary with keys from iterable and values set to value.","title":"fromkeys"},{"location":"reference/pyzkaccess/common/#get","text":"def get ( self , key , default = None , / ) Return the value for key if key is in the dictionary, else default.","title":"get"},{"location":"reference/pyzkaccess/common/#items","text":"def items ( ... ) D.items() -> a set-like object providing a view on D's items","title":"items"},{"location":"reference/pyzkaccess/common/#keys","text":"def keys ( ... ) D.keys() -> a set-like object providing a view on D's keys","title":"keys"},{"location":"reference/pyzkaccess/common/#pop","text":"def pop ( ... ) D.pop(k[,d]) -> v, remove specified key and return the corresponding value. If key is not found, d is returned if given, otherwise KeyError is raised","title":"pop"},{"location":"reference/pyzkaccess/common/#popitem","text":"def popitem ( self , / ) Remove and return a (key, value) pair as a 2-tuple. Pairs are returned in LIFO (last-in, first-out) order. Raises KeyError if the dict is empty.","title":"popitem"},{"location":"reference/pyzkaccess/common/#setdefault","text":"def setdefault ( self , key , default = None , / ) Insert key with a value of default if key is not in the dictionary. Return the value for key if key is in the dictionary, else default.","title":"setdefault"},{"location":"reference/pyzkaccess/common/#update","text":"def update ( ... ) D.update([E, ]**F) -> None. Update D from dict/iterable E and F. If E is present and has a .keys() method, then does: for k in E: D[k] = E[k] If E is present and lacks a .keys() method, then does: for k, v in E: D[k] = v In either case, this is followed by: for k in F: D[k] = F[k]","title":"update"},{"location":"reference/pyzkaccess/common/#values","text":"def values ( ... ) D.values() -> an object providing a view on D's values","title":"values"},{"location":"reference/pyzkaccess/common/#docvalue","text":"class DocValue ( value : Union [ str , int ], doc : str )","title":"DocValue"},{"location":"reference/pyzkaccess/common/#ancestors-in-mro_1","text":"builtins.ObjectProxy","title":"Ancestors (in MRO)"},{"location":"reference/pyzkaccess/common/#instance-variables","text":"doc Documentation of a value value Exposed value","title":"Instance variables"},{"location":"reference/pyzkaccess/common/#usertuple","text":"class UserTuple ( initlist : Union [ Sequence , Iterable , ForwardRef ( 'UserTuple' )] = None ) Immutable version of collections.UserList from the stdlib View Source class UserTuple : \"\"\"Immutable version of `collections.UserList` from the stdlib\"\"\" def __init__ ( self , initlist : Union [ Sequence, Iterable, 'UserTuple' ] = None ) : self . data = tuple () if initlist is not None : # XXX should this accept an arbitrary sequence ? if isinstance ( initlist , tuple ) : self . data = initlist elif isinstance ( initlist , UserTuple ) : self . data = copy ( initlist . data ) else : self . data = tuple ( initlist ) def __repr__ ( self ) : return repr ( self . data ) def __lt__ ( self , other ) : return self . data < self . __cast ( other ) # noqa def __le__ ( self , other ) : return self . data <= self . __cast ( other ) def __eq__ ( self , other ) : return self . data == self . __cast ( other ) def __gt__ ( self , other ) : return self . data > self . __cast ( other ) # noqa def __ge__ ( self , other ) : return self . data >= self . __cast ( other ) def __cast ( self , other ) : return other . data if isinstance ( other , UserTuple ) else other def __contains__ ( self , item ) : return item in self . data def __len__ ( self ) : return len ( self . data ) def __getitem__ ( self , i ) : if isinstance ( i , slice ) : return self . __class__ ( self . data [ i ] ) else : return self . data [ i ] def __add__ ( self , other ) : if isinstance ( other , UserTuple ) : return self . __class__ ( self . data + other . data ) elif isinstance ( other , type ( self . data )) : return self . __class__ ( self . data + other ) return self . __class__ ( self . data + list ( other )) def __radd__ ( self , other ) : if isinstance ( other , UserTuple ) : return self . __class__ ( other . data + self . data ) elif isinstance ( other , type ( self . data )) : return self . __class__ ( other + self . data ) return self . __class__ ( list ( other ) + self . data ) def __iadd__ ( self , other ) : if isinstance ( other , UserTuple ) : self . data += other . data elif isinstance ( other , type ( self . data )) : self . data += other else : self . data += list ( other ) return self def __mul__ ( self , n ) : return self . __class__ ( self . data * n ) __rmul__ = __mul__ def __imul__ ( self , n ) : self . data *= n return self def __hash__ ( self ) : return hash ( self . data ) def __copy__ ( self ) : inst = self . __class__ . __new__ ( self . __class__ ) inst . __dict__ . update ( self . __dict__ ) # Create a copy and avoid triggering descriptors inst . __dict__ [ \"data\" ] = self . __dict__ [ \"data\" ][ : ] return inst def copy ( self ) : return self . __class__ ( self ) def count ( self , item ) : return self . data . count ( item ) def index ( self , item , * args ) : return self . data . index ( item , * args )","title":"UserTuple"},{"location":"reference/pyzkaccess/common/#descendants","text":"pyzkaccess.aux_input.AuxInputList pyzkaccess.reader.ReaderList pyzkaccess.relay.RelayList pyzkaccess.door.DoorList","title":"Descendants"},{"location":"reference/pyzkaccess/common/#methods_1","text":"","title":"Methods"},{"location":"reference/pyzkaccess/common/#copy_1","text":"def copy ( self ) View Source def copy(self): return self.__class__(self)","title":"copy"},{"location":"reference/pyzkaccess/common/#count","text":"def count ( self , item ) View Source def count(self, item): return self.data.count(item)","title":"count"},{"location":"reference/pyzkaccess/common/#index","text":"def index ( self , item , * args ) View Source def index(self, item, *args): return self.data.index(item, *args)","title":"index"},{"location":"reference/pyzkaccess/ctypes/","text":"Module pyzkaccess.ctypes This module is intended to safety import Windows-specific features from ctypes stdlib module on non-windows platform -- they are replaced by mock objects. Despite the code which uses that features becomes partially unoperable in this case, we can import it and generate documentation for instance View Source \"\"\"This module is intended to safety import Windows-specific features from `ctypes` stdlib module on non-windows platform -- they are replaced by mock objects. Despite the code which uses that features becomes partially unoperable in this case, we can import it and generate documentation for instance \"\"\" import warnings from ctypes import * # noqa from unittest.mock import Mock try : from ctypes import WinDLL # noqa except ImportError : warnings . warn ( 'ctypes.WinDLL is not available on non-Windows system. The code is not functional on ' 'current platform, but in order to be able import it we mock WinDLL with ' 'unittest.mock.Mock object' ) WinDLL = Mock () Variables DEFAULT_MODE RTLD_GLOBAL RTLD_LOCAL","title":"Ctypes"},{"location":"reference/pyzkaccess/ctypes/#module-pyzkaccessctypes","text":"This module is intended to safety import Windows-specific features from ctypes stdlib module on non-windows platform -- they are replaced by mock objects. Despite the code which uses that features becomes partially unoperable in this case, we can import it and generate documentation for instance View Source \"\"\"This module is intended to safety import Windows-specific features from `ctypes` stdlib module on non-windows platform -- they are replaced by mock objects. Despite the code which uses that features becomes partially unoperable in this case, we can import it and generate documentation for instance \"\"\" import warnings from ctypes import * # noqa from unittest.mock import Mock try : from ctypes import WinDLL # noqa except ImportError : warnings . warn ( 'ctypes.WinDLL is not available on non-Windows system. The code is not functional on ' 'current platform, but in order to be able import it we mock WinDLL with ' 'unittest.mock.Mock object' ) WinDLL = Mock ()","title":"Module pyzkaccess.ctypes"},{"location":"reference/pyzkaccess/ctypes/#variables","text":"DEFAULT_MODE RTLD_GLOBAL RTLD_LOCAL","title":"Variables"},{"location":"reference/pyzkaccess/device/","text":"Module pyzkaccess.device View Source __all__ = [ 'ZKModel' , 'ZK100' , 'ZK200' , 'ZK400' , 'ZKDevice' ] from typing import Mapping , Optional from .common import DocDict from .enum import RelayGroup class ZKModel : \"\"\"Base class for concrete ZK model Contains model-specific definitions \"\"\" #: Name of model name = None #: Relays count relays = None #: Definition of relay numbers (count must be equal to `relays`) relays_def = None #: Definition of relay groups (count must be equal to `relays`) groups_def = None #: Definition of reader numbers readers_def = None #: Definition of door numbers doors_dev = None #: Definition of aux input numbers aux_inputs_def = None #: Anti-passback rules available on concrete device model anti_passback_rules = None #: Interlock rules available on concrete device model interlock_rules = None class ZK400 ( ZKModel ): \"\"\"ZKAccess C3-400 model\"\"\" name = 'C3-400' relays = 8 relays_def = ( 1 , 2 , 3 , 4 , 1 , 2 , 3 , 4 ) groups_def = ( RelayGroup . aux , RelayGroup . aux , RelayGroup . aux , RelayGroup . aux , RelayGroup . lock , RelayGroup . lock , RelayGroup . lock , RelayGroup . lock ) readers_def = ( 1 , 2 , 3 , 4 ) doors_def = ( 1 , 2 , 3 , 4 ) aux_inputs_def = ( 1 , 2 , 3 , 4 ) anti_passback_rules = DocDict ({ 0 : 'Anti-passback disabled' , 1 : 'Enable the anti-passback function Door 1 and Door 2' , 2 : 'Enable the anti\u2022passback function between Door 3 and Door 4' , 3 : 'Enable the anti-passback function between Door 1 and Door 2, and between ' 'Door 3 and Door 4' , 4 : 'Enable the anti-passback function between Door 1,2 and Door 3,4' , 5 : 'Enable the anti-passback function between Door 1 and Door 2,3' , 6 : 'Enable the anti-passback function between Door 1 and Door 2,3,4' , 16 : 'Anti-passback is supported only between the readers of Door 1' , 32 : 'Anti-passback is supported only between the readers of Door 2' , 64 : 'Anti-passback is supported only between the readers of Door 3' , 128 : 'Anti-passback is supported only between the readers of Door 4' , 96 : 'Anti-passback is supported concurrently among Door 2 and Door 3 readers respectively' , 160 : 'Anti-passback is supported concurrently among Door 2 and Door 4 readers respectively' , 196 : 'Anti-passback is supported concurrently among Door 3 and Door 4 readers respectively' , 112 : 'Anti-passback is supported concurrently among Door 1, 2, 3 readers respectively' , 176 : 'Anti-passback is supported concurrently among Door 1, 2, 4 readers respectively' , 208 : 'Anti-passback is supported concurrently among Door 1, 3, 4 readers respectively' , 224 : 'Anti-passback is supported concurrently among Door 2, 3, 4 readers respectively' , 240 : 'Anti-passback is supported concurrently among Door 1, 2, 3, 4 readers respectively' , }) interlock_rules = DocDict ({ 0 : 'Interlock disabled' , 1 : 'Interlock Door 1 and Door 2 mutually' , 2 : 'Interlock Door 3 and Door 4 mutually' , 3 : 'Interlock Door 1, Door 2 and Door 3 mutually' , 4 : 'Interlock Door 1 and Door 2 mutually and interlock Door 3 and Door 4 mutually' , 5 : 'Interlock Door 1, Door 2, Door 3, Door 4 mutually' , }) class ZK200 ( ZKModel ): \"\"\"ZKAccess C3-200\"\"\" name = 'C3-200' relays = 4 relays_def = ( 1 , 2 , 1 , 2 ) groups_def = ( RelayGroup . aux , RelayGroup . aux , RelayGroup . lock , RelayGroup . lock ) readers_def = ( 1 , 2 ) # FIXME: fix ZKAccess.doors for C3-200 doors_def = ( 1 , 2 ) aux_inputs_def = ( 1 , 2 ) anti_passback_rules = DocDict ({ 0 : 'Anti-passback disabled' , 1 : 'Enable the anti-passback function between Door 1 and Door 2 (one-way) ' 'or readers of Door 1 (two-way)' , 2 : 'Enable the anti-passback function between readers of Door 2 (two-way)' , 3 : 'Enable the anti-passback function between readers of Door 1 and between readers of ' 'Door 2 respectively (two-way)' , 4 : 'Enable the anti-passback function between Door 1 and Door 2 (two-way)' }) interlock_rules = DocDict ({ 0 : 'Interlock disabled' , 1 : 'Interlock Door 1 and Door 2 mutually' , }) class ZK100 ( ZKModel ): \"\"\"ZKAccess C3-100\"\"\" name = 'C3-100' relays = 2 relays_def = ( 1 , 2 ) groups_def = ( RelayGroup . aux , RelayGroup . lock ) readers_def = ( 1 , ) # FIXME: fix ZKAccess.doors for C3-100 doors_def = ( 1 , ) aux_inputs_def = ( 1 , ) # FIXME: fix ZKAccess.doors for C3-100 anti_passback_rules = DocDict ({ 0 : 'Anti-passback disabled' , 1 : 'Enable the anti-passback function between the readers of Door1 (two-way)' , }) interlock_rules = DocDict ({ 0 : 'Interlock disabled' , }) class ZKDevice : \"\"\"Concrete ZK device info\"\"\" __slots__ = ( 'mac' , 'ip' , 'serial_number' , 'model' , 'version' ) parse_tokens = ( 'MAC' , 'IP' , 'SN' , 'Device' , 'Ver' ) # The same order as __slots__ available_models = ( ZK100 , ZK200 , ZK400 ) def __init__ ( self , s = None , ** params ): if s is not None : params = self . parse ( s ) if not params : raise TypeError ( 'You must specify device string or object attributes as kwargs' ) self . mac = params [ 'mac' ] # type: Optional[str] self . ip = params [ 'ip' ] # type: str self . serial_number = params [ 'serial_number' ] # type: str self . model = self . _get_model_cls ( params [ 'model' ]) # type: type(ZKModel) self . version = params [ 'version' ] # type: Optional[str] def parse ( self , device_line : str ) -> Mapping [ str , str ]: \"\"\" Parse and validate raw device string :param device_line: event string :return: dictionary where keys are slots and values are appropriate values extracted from string \"\"\" device_line = device_line . replace ( ' \\r\\n ' , '' ) res = {} tokens_mapping = dict ( zip ( self . parse_tokens , self . __slots__ )) pieces = device_line . split ( ',' ) for piece in pieces : tok , val = piece . split ( '=' ) if tok not in tokens_mapping : raise ValueError ( \"Unknown param '{}={}' found in device string '{}'\" . format ( tok , val , device_line )) res [ tokens_mapping [ tok ]] = val # {slot: value} if res . keys () != set ( self . __slots__ ): raise ValueError ( \"Some keys was not found in device string '{}'\" . format ( device_line )) return res def _get_model_cls ( self , model_name ) -> type ( ZKModel ): if isinstance ( model_name , type ) and issubclass ( model_name , ZKModel ): return model_name for cls in self . available_models : if cls . name == model_name : return cls raise ValueError ( \"Unknown device model '{}'\" . format ( model_name )) def __eq__ ( self , other ): if isinstance ( other , ZKDevice ): return all ( getattr ( self , attr ) == getattr ( other , attr ) for attr in self . __slots__ ) return False def __ne__ ( self , other ): return not self . __eq__ ( other ) def __str__ ( self ): params = ', ' . join ( '{}={}' . format ( k , getattr ( self , k , '?' )) for k in self . __slots__ ) return 'Device[{}]({})' . format ( self . model . name , params ) def __repr__ ( self ): return self . __str__ () Classes ZK100 class ZK100 ( / , * args , ** kwargs ) ZKAccess C3-100 View Source class ZK100 ( ZKModel ): \"\"\"ZKAccess C3-100\"\"\" name = 'C3-100' relays = 2 relays_def = ( 1 , 2 ) groups_def = ( RelayGroup . aux , RelayGroup . lock ) readers_def = ( 1 , ) # FIXME: fix ZKAccess.doors for C3-100 doors_def = ( 1 , ) aux_inputs_def = ( 1 , ) # FIXME: fix ZKAccess.doors for C3-100 anti_passback_rules = DocDict ({ 0 : 'Anti-passback disabled' , 1 : 'Enable the anti-passback function between the readers of Door1 (two-way)' , }) interlock_rules = DocDict ({ 0 : 'Interlock disabled' , }) Ancestors (in MRO) pyzkaccess.device.ZKModel Class variables anti_passback_rules aux_inputs_def doors_def doors_dev groups_def interlock_rules name readers_def relays relays_def ZK200 class ZK200 ( / , * args , ** kwargs ) ZKAccess C3-200 View Source class ZK200 ( ZKModel ): \"\"\"ZKAccess C3-200\"\"\" name = 'C3-200' relays = 4 relays_def = ( 1 , 2 , 1 , 2 ) groups_def = ( RelayGroup . aux , RelayGroup . aux , RelayGroup . lock , RelayGroup . lock ) readers_def = ( 1 , 2 ) # FIXME: fix ZKAccess.doors for C3-200 doors_def = ( 1 , 2 ) aux_inputs_def = ( 1 , 2 ) anti_passback_rules = DocDict ({ 0 : 'Anti-passback disabled' , 1 : 'Enable the anti-passback function between Door 1 and Door 2 (one-way) ' 'or readers of Door 1 (two-way)' , 2 : 'Enable the anti-passback function between readers of Door 2 (two-way)' , 3 : 'Enable the anti-passback function between readers of Door 1 and between readers of ' 'Door 2 respectively (two-way)' , 4 : 'Enable the anti-passback function between Door 1 and Door 2 (two-way)' }) interlock_rules = DocDict ({ 0 : 'Interlock disabled' , 1 : 'Interlock Door 1 and Door 2 mutually' , }) Ancestors (in MRO) pyzkaccess.device.ZKModel Class variables anti_passback_rules aux_inputs_def doors_def doors_dev groups_def interlock_rules name readers_def relays relays_def ZK400 class ZK400 ( / , * args , ** kwargs ) ZKAccess C3-400 model View Source class ZK400 ( ZKModel ): \"\"\"ZKAccess C3-400 model\"\"\" name = 'C3-400' relays = 8 relays_def = ( 1 , 2 , 3 , 4 , 1 , 2 , 3 , 4 ) groups_def = ( RelayGroup . aux , RelayGroup . aux , RelayGroup . aux , RelayGroup . aux , RelayGroup . lock , RelayGroup . lock , RelayGroup . lock , RelayGroup . lock ) readers_def = ( 1 , 2 , 3 , 4 ) doors_def = ( 1 , 2 , 3 , 4 ) aux_inputs_def = ( 1 , 2 , 3 , 4 ) anti_passback_rules = DocDict ({ 0 : 'Anti-passback disabled' , 1 : 'Enable the anti-passback function Door 1 and Door 2' , 2 : 'Enable the anti\u2022passback function between Door 3 and Door 4' , 3 : 'Enable the anti-passback function between Door 1 and Door 2, and between ' 'Door 3 and Door 4' , 4 : 'Enable the anti-passback function between Door 1,2 and Door 3,4' , 5 : 'Enable the anti-passback function between Door 1 and Door 2,3' , 6 : 'Enable the anti-passback function between Door 1 and Door 2,3,4' , 16 : 'Anti-passback is supported only between the readers of Door 1' , 32 : 'Anti-passback is supported only between the readers of Door 2' , 64 : 'Anti-passback is supported only between the readers of Door 3' , 128 : 'Anti-passback is supported only between the readers of Door 4' , 96 : 'Anti-passback is supported concurrently among Door 2 and Door 3 readers respectively' , 160 : 'Anti-passback is supported concurrently among Door 2 and Door 4 readers respectively' , 196 : 'Anti-passback is supported concurrently among Door 3 and Door 4 readers respectively' , 112 : 'Anti-passback is supported concurrently among Door 1, 2, 3 readers respectively' , 176 : 'Anti-passback is supported concurrently among Door 1, 2, 4 readers respectively' , 208 : 'Anti-passback is supported concurrently among Door 1, 3, 4 readers respectively' , 224 : 'Anti-passback is supported concurrently among Door 2, 3, 4 readers respectively' , 240 : 'Anti-passback is supported concurrently among Door 1, 2, 3, 4 readers respectively' , }) interlock_rules = DocDict ({ 0 : 'Interlock disabled' , 1 : 'Interlock Door 1 and Door 2 mutually' , 2 : 'Interlock Door 3 and Door 4 mutually' , 3 : 'Interlock Door 1, Door 2 and Door 3 mutually' , 4 : 'Interlock Door 1 and Door 2 mutually and interlock Door 3 and Door 4 mutually' , 5 : 'Interlock Door 1, Door 2, Door 3, Door 4 mutually' , }) Ancestors (in MRO) pyzkaccess.device.ZKModel Class variables anti_passback_rules aux_inputs_def doors_def doors_dev groups_def interlock_rules name readers_def relays relays_def ZKDevice class ZKDevice ( s = None , ** params ) Concrete ZK device info View Source class ZKDevice : \"\"\"Concrete ZK device info\"\"\" __slots__ = ( 'mac' , 'ip' , 'serial_number' , 'model' , 'version' ) parse_tokens = ( 'MAC' , 'IP' , 'SN' , 'Device' , 'Ver' ) # The same order as __slots__ available_models = ( ZK100 , ZK200 , ZK400 ) def __init__ ( self , s = None , ** params ) : if s is not None : params = self . parse ( s ) if not params : raise TypeError ( 'You must specify device string or object attributes as kwargs' ) self . mac = params [ 'mac' ] # type : Optional [ str ] self . ip = params [ 'ip' ] # type : str self . serial_number = params [ 'serial_number' ] # type : str self . model = self . _get_model_cls ( params [ 'model' ] ) # type : type ( ZKModel ) self . version = params [ 'version' ] # type : Optional [ str ] def parse ( self , device_line : str ) -> Mapping [ str, str ] : \"\"\" Parse and validate raw device string :param device_line: event string :return: dictionary where keys are slots and values are appropriate values extracted from string \"\"\" device_line = device_line . replace ( '\\r\\n' , '' ) res = {} tokens_mapping = dict ( zip ( self . parse_tokens , self . __slots__ )) pieces = device_line . split ( ',' ) for piece in pieces : tok , val = piece . split ( '=' ) if tok not in tokens_mapping : raise ValueError ( \"Unknown param '{}={}' found in device string '{}'\" . format ( tok , val , device_line )) res [ tokens_mapping[tok ] ] = val # { slot : value } if res . keys () != set ( self . __slots__ ) : raise ValueError ( \"Some keys was not found in device string '{}'\" . format ( device_line )) return res def _get_model_cls ( self , model_name ) -> type ( ZKModel ) : if isinstance ( model_name , type ) and issubclass ( model_name , ZKModel ) : return model_name for cls in self . available_models : if cls . name == model_name : return cls raise ValueError ( \"Unknown device model '{}'\" . format ( model_name )) def __eq__ ( self , other ) : if isinstance ( other , ZKDevice ) : return all ( getattr ( self , attr ) == getattr ( other , attr ) for attr in self . __slots__ ) return False def __ne__ ( self , other ) : return not self . __eq__ ( other ) def __str__ ( self ) : params = ', ' . join ( '{}={}' . format ( k , getattr ( self , k , '?' )) for k in self . __slots__ ) return 'Device[{}]({})' . format ( self . model . name , params ) def __repr__ ( self ) : return self . __str__ () Class variables available_models parse_tokens Instance variables ip mac model serial_number version Methods parse def parse ( self , device_line : str ) -> Mapping [ str , str ] Parse and validate raw device string :param device_line: event string :return: dictionary where keys are slots and values are appropriate values extracted from string View Source def parse ( self , device_line : str ) -> Mapping [ str, str ] : \"\"\" Parse and validate raw device string :param device_line: event string :return: dictionary where keys are slots and values are appropriate values extracted from string \"\"\" device_line = device_line . replace ( '\\r\\n' , '' ) res = {} tokens_mapping = dict ( zip ( self . parse_tokens , self . __slots__ )) pieces = device_line . split ( ',' ) for piece in pieces : tok , val = piece . split ( '=' ) if tok not in tokens_mapping : raise ValueError ( \"Unknown param '{}={}' found in device string '{}'\" . format ( tok , val , device_line )) res [ tokens_mapping[tok ] ] = val # { slot : value } if res . keys () != set ( self . __slots__ ) : raise ValueError ( \"Some keys was not found in device string '{}'\" . format ( device_line )) return res ZKModel class ZKModel ( / , * args , ** kwargs ) Base class for concrete ZK model Contains model-specific definitions View Source class ZKModel : \"\"\"Base class for concrete ZK model Contains model-specific definitions \"\"\" #: Name of model name = None #: Relays count relays = None #: Definition of relay numbers (count must be equal to `relays`) relays_def = None #: Definition of relay groups (count must be equal to `relays`) groups_def = None #: Definition of reader numbers readers_def = None #: Definition of door numbers doors_dev = None #: Definition of aux input numbers aux_inputs_def = None #: Anti-passback rules available on concrete device model anti_passback_rules = None #: Interlock rules available on concrete device model interlock_rules = None Descendants pyzkaccess.device.ZK400 pyzkaccess.device.ZK200 pyzkaccess.device.ZK100 Class variables anti_passback_rules aux_inputs_def doors_dev groups_def interlock_rules name readers_def relays relays_def","title":"Device"},{"location":"reference/pyzkaccess/device/#module-pyzkaccessdevice","text":"View Source __all__ = [ 'ZKModel' , 'ZK100' , 'ZK200' , 'ZK400' , 'ZKDevice' ] from typing import Mapping , Optional from .common import DocDict from .enum import RelayGroup class ZKModel : \"\"\"Base class for concrete ZK model Contains model-specific definitions \"\"\" #: Name of model name = None #: Relays count relays = None #: Definition of relay numbers (count must be equal to `relays`) relays_def = None #: Definition of relay groups (count must be equal to `relays`) groups_def = None #: Definition of reader numbers readers_def = None #: Definition of door numbers doors_dev = None #: Definition of aux input numbers aux_inputs_def = None #: Anti-passback rules available on concrete device model anti_passback_rules = None #: Interlock rules available on concrete device model interlock_rules = None class ZK400 ( ZKModel ): \"\"\"ZKAccess C3-400 model\"\"\" name = 'C3-400' relays = 8 relays_def = ( 1 , 2 , 3 , 4 , 1 , 2 , 3 , 4 ) groups_def = ( RelayGroup . aux , RelayGroup . aux , RelayGroup . aux , RelayGroup . aux , RelayGroup . lock , RelayGroup . lock , RelayGroup . lock , RelayGroup . lock ) readers_def = ( 1 , 2 , 3 , 4 ) doors_def = ( 1 , 2 , 3 , 4 ) aux_inputs_def = ( 1 , 2 , 3 , 4 ) anti_passback_rules = DocDict ({ 0 : 'Anti-passback disabled' , 1 : 'Enable the anti-passback function Door 1 and Door 2' , 2 : 'Enable the anti\u2022passback function between Door 3 and Door 4' , 3 : 'Enable the anti-passback function between Door 1 and Door 2, and between ' 'Door 3 and Door 4' , 4 : 'Enable the anti-passback function between Door 1,2 and Door 3,4' , 5 : 'Enable the anti-passback function between Door 1 and Door 2,3' , 6 : 'Enable the anti-passback function between Door 1 and Door 2,3,4' , 16 : 'Anti-passback is supported only between the readers of Door 1' , 32 : 'Anti-passback is supported only between the readers of Door 2' , 64 : 'Anti-passback is supported only between the readers of Door 3' , 128 : 'Anti-passback is supported only between the readers of Door 4' , 96 : 'Anti-passback is supported concurrently among Door 2 and Door 3 readers respectively' , 160 : 'Anti-passback is supported concurrently among Door 2 and Door 4 readers respectively' , 196 : 'Anti-passback is supported concurrently among Door 3 and Door 4 readers respectively' , 112 : 'Anti-passback is supported concurrently among Door 1, 2, 3 readers respectively' , 176 : 'Anti-passback is supported concurrently among Door 1, 2, 4 readers respectively' , 208 : 'Anti-passback is supported concurrently among Door 1, 3, 4 readers respectively' , 224 : 'Anti-passback is supported concurrently among Door 2, 3, 4 readers respectively' , 240 : 'Anti-passback is supported concurrently among Door 1, 2, 3, 4 readers respectively' , }) interlock_rules = DocDict ({ 0 : 'Interlock disabled' , 1 : 'Interlock Door 1 and Door 2 mutually' , 2 : 'Interlock Door 3 and Door 4 mutually' , 3 : 'Interlock Door 1, Door 2 and Door 3 mutually' , 4 : 'Interlock Door 1 and Door 2 mutually and interlock Door 3 and Door 4 mutually' , 5 : 'Interlock Door 1, Door 2, Door 3, Door 4 mutually' , }) class ZK200 ( ZKModel ): \"\"\"ZKAccess C3-200\"\"\" name = 'C3-200' relays = 4 relays_def = ( 1 , 2 , 1 , 2 ) groups_def = ( RelayGroup . aux , RelayGroup . aux , RelayGroup . lock , RelayGroup . lock ) readers_def = ( 1 , 2 ) # FIXME: fix ZKAccess.doors for C3-200 doors_def = ( 1 , 2 ) aux_inputs_def = ( 1 , 2 ) anti_passback_rules = DocDict ({ 0 : 'Anti-passback disabled' , 1 : 'Enable the anti-passback function between Door 1 and Door 2 (one-way) ' 'or readers of Door 1 (two-way)' , 2 : 'Enable the anti-passback function between readers of Door 2 (two-way)' , 3 : 'Enable the anti-passback function between readers of Door 1 and between readers of ' 'Door 2 respectively (two-way)' , 4 : 'Enable the anti-passback function between Door 1 and Door 2 (two-way)' }) interlock_rules = DocDict ({ 0 : 'Interlock disabled' , 1 : 'Interlock Door 1 and Door 2 mutually' , }) class ZK100 ( ZKModel ): \"\"\"ZKAccess C3-100\"\"\" name = 'C3-100' relays = 2 relays_def = ( 1 , 2 ) groups_def = ( RelayGroup . aux , RelayGroup . lock ) readers_def = ( 1 , ) # FIXME: fix ZKAccess.doors for C3-100 doors_def = ( 1 , ) aux_inputs_def = ( 1 , ) # FIXME: fix ZKAccess.doors for C3-100 anti_passback_rules = DocDict ({ 0 : 'Anti-passback disabled' , 1 : 'Enable the anti-passback function between the readers of Door1 (two-way)' , }) interlock_rules = DocDict ({ 0 : 'Interlock disabled' , }) class ZKDevice : \"\"\"Concrete ZK device info\"\"\" __slots__ = ( 'mac' , 'ip' , 'serial_number' , 'model' , 'version' ) parse_tokens = ( 'MAC' , 'IP' , 'SN' , 'Device' , 'Ver' ) # The same order as __slots__ available_models = ( ZK100 , ZK200 , ZK400 ) def __init__ ( self , s = None , ** params ): if s is not None : params = self . parse ( s ) if not params : raise TypeError ( 'You must specify device string or object attributes as kwargs' ) self . mac = params [ 'mac' ] # type: Optional[str] self . ip = params [ 'ip' ] # type: str self . serial_number = params [ 'serial_number' ] # type: str self . model = self . _get_model_cls ( params [ 'model' ]) # type: type(ZKModel) self . version = params [ 'version' ] # type: Optional[str] def parse ( self , device_line : str ) -> Mapping [ str , str ]: \"\"\" Parse and validate raw device string :param device_line: event string :return: dictionary where keys are slots and values are appropriate values extracted from string \"\"\" device_line = device_line . replace ( ' \\r\\n ' , '' ) res = {} tokens_mapping = dict ( zip ( self . parse_tokens , self . __slots__ )) pieces = device_line . split ( ',' ) for piece in pieces : tok , val = piece . split ( '=' ) if tok not in tokens_mapping : raise ValueError ( \"Unknown param '{}={}' found in device string '{}'\" . format ( tok , val , device_line )) res [ tokens_mapping [ tok ]] = val # {slot: value} if res . keys () != set ( self . __slots__ ): raise ValueError ( \"Some keys was not found in device string '{}'\" . format ( device_line )) return res def _get_model_cls ( self , model_name ) -> type ( ZKModel ): if isinstance ( model_name , type ) and issubclass ( model_name , ZKModel ): return model_name for cls in self . available_models : if cls . name == model_name : return cls raise ValueError ( \"Unknown device model '{}'\" . format ( model_name )) def __eq__ ( self , other ): if isinstance ( other , ZKDevice ): return all ( getattr ( self , attr ) == getattr ( other , attr ) for attr in self . __slots__ ) return False def __ne__ ( self , other ): return not self . __eq__ ( other ) def __str__ ( self ): params = ', ' . join ( '{}={}' . format ( k , getattr ( self , k , '?' )) for k in self . __slots__ ) return 'Device[{}]({})' . format ( self . model . name , params ) def __repr__ ( self ): return self . __str__ ()","title":"Module pyzkaccess.device"},{"location":"reference/pyzkaccess/device/#classes","text":"","title":"Classes"},{"location":"reference/pyzkaccess/device/#zk100","text":"class ZK100 ( / , * args , ** kwargs ) ZKAccess C3-100 View Source class ZK100 ( ZKModel ): \"\"\"ZKAccess C3-100\"\"\" name = 'C3-100' relays = 2 relays_def = ( 1 , 2 ) groups_def = ( RelayGroup . aux , RelayGroup . lock ) readers_def = ( 1 , ) # FIXME: fix ZKAccess.doors for C3-100 doors_def = ( 1 , ) aux_inputs_def = ( 1 , ) # FIXME: fix ZKAccess.doors for C3-100 anti_passback_rules = DocDict ({ 0 : 'Anti-passback disabled' , 1 : 'Enable the anti-passback function between the readers of Door1 (two-way)' , }) interlock_rules = DocDict ({ 0 : 'Interlock disabled' , })","title":"ZK100"},{"location":"reference/pyzkaccess/device/#ancestors-in-mro","text":"pyzkaccess.device.ZKModel","title":"Ancestors (in MRO)"},{"location":"reference/pyzkaccess/device/#class-variables","text":"anti_passback_rules aux_inputs_def doors_def doors_dev groups_def interlock_rules name readers_def relays relays_def","title":"Class variables"},{"location":"reference/pyzkaccess/device/#zk200","text":"class ZK200 ( / , * args , ** kwargs ) ZKAccess C3-200 View Source class ZK200 ( ZKModel ): \"\"\"ZKAccess C3-200\"\"\" name = 'C3-200' relays = 4 relays_def = ( 1 , 2 , 1 , 2 ) groups_def = ( RelayGroup . aux , RelayGroup . aux , RelayGroup . lock , RelayGroup . lock ) readers_def = ( 1 , 2 ) # FIXME: fix ZKAccess.doors for C3-200 doors_def = ( 1 , 2 ) aux_inputs_def = ( 1 , 2 ) anti_passback_rules = DocDict ({ 0 : 'Anti-passback disabled' , 1 : 'Enable the anti-passback function between Door 1 and Door 2 (one-way) ' 'or readers of Door 1 (two-way)' , 2 : 'Enable the anti-passback function between readers of Door 2 (two-way)' , 3 : 'Enable the anti-passback function between readers of Door 1 and between readers of ' 'Door 2 respectively (two-way)' , 4 : 'Enable the anti-passback function between Door 1 and Door 2 (two-way)' }) interlock_rules = DocDict ({ 0 : 'Interlock disabled' , 1 : 'Interlock Door 1 and Door 2 mutually' , })","title":"ZK200"},{"location":"reference/pyzkaccess/device/#ancestors-in-mro_1","text":"pyzkaccess.device.ZKModel","title":"Ancestors (in MRO)"},{"location":"reference/pyzkaccess/device/#class-variables_1","text":"anti_passback_rules aux_inputs_def doors_def doors_dev groups_def interlock_rules name readers_def relays relays_def","title":"Class variables"},{"location":"reference/pyzkaccess/device/#zk400","text":"class ZK400 ( / , * args , ** kwargs ) ZKAccess C3-400 model View Source class ZK400 ( ZKModel ): \"\"\"ZKAccess C3-400 model\"\"\" name = 'C3-400' relays = 8 relays_def = ( 1 , 2 , 3 , 4 , 1 , 2 , 3 , 4 ) groups_def = ( RelayGroup . aux , RelayGroup . aux , RelayGroup . aux , RelayGroup . aux , RelayGroup . lock , RelayGroup . lock , RelayGroup . lock , RelayGroup . lock ) readers_def = ( 1 , 2 , 3 , 4 ) doors_def = ( 1 , 2 , 3 , 4 ) aux_inputs_def = ( 1 , 2 , 3 , 4 ) anti_passback_rules = DocDict ({ 0 : 'Anti-passback disabled' , 1 : 'Enable the anti-passback function Door 1 and Door 2' , 2 : 'Enable the anti\u2022passback function between Door 3 and Door 4' , 3 : 'Enable the anti-passback function between Door 1 and Door 2, and between ' 'Door 3 and Door 4' , 4 : 'Enable the anti-passback function between Door 1,2 and Door 3,4' , 5 : 'Enable the anti-passback function between Door 1 and Door 2,3' , 6 : 'Enable the anti-passback function between Door 1 and Door 2,3,4' , 16 : 'Anti-passback is supported only between the readers of Door 1' , 32 : 'Anti-passback is supported only between the readers of Door 2' , 64 : 'Anti-passback is supported only between the readers of Door 3' , 128 : 'Anti-passback is supported only between the readers of Door 4' , 96 : 'Anti-passback is supported concurrently among Door 2 and Door 3 readers respectively' , 160 : 'Anti-passback is supported concurrently among Door 2 and Door 4 readers respectively' , 196 : 'Anti-passback is supported concurrently among Door 3 and Door 4 readers respectively' , 112 : 'Anti-passback is supported concurrently among Door 1, 2, 3 readers respectively' , 176 : 'Anti-passback is supported concurrently among Door 1, 2, 4 readers respectively' , 208 : 'Anti-passback is supported concurrently among Door 1, 3, 4 readers respectively' , 224 : 'Anti-passback is supported concurrently among Door 2, 3, 4 readers respectively' , 240 : 'Anti-passback is supported concurrently among Door 1, 2, 3, 4 readers respectively' , }) interlock_rules = DocDict ({ 0 : 'Interlock disabled' , 1 : 'Interlock Door 1 and Door 2 mutually' , 2 : 'Interlock Door 3 and Door 4 mutually' , 3 : 'Interlock Door 1, Door 2 and Door 3 mutually' , 4 : 'Interlock Door 1 and Door 2 mutually and interlock Door 3 and Door 4 mutually' , 5 : 'Interlock Door 1, Door 2, Door 3, Door 4 mutually' , })","title":"ZK400"},{"location":"reference/pyzkaccess/device/#ancestors-in-mro_2","text":"pyzkaccess.device.ZKModel","title":"Ancestors (in MRO)"},{"location":"reference/pyzkaccess/device/#class-variables_2","text":"anti_passback_rules aux_inputs_def doors_def doors_dev groups_def interlock_rules name readers_def relays relays_def","title":"Class variables"},{"location":"reference/pyzkaccess/device/#zkdevice","text":"class ZKDevice ( s = None , ** params ) Concrete ZK device info View Source class ZKDevice : \"\"\"Concrete ZK device info\"\"\" __slots__ = ( 'mac' , 'ip' , 'serial_number' , 'model' , 'version' ) parse_tokens = ( 'MAC' , 'IP' , 'SN' , 'Device' , 'Ver' ) # The same order as __slots__ available_models = ( ZK100 , ZK200 , ZK400 ) def __init__ ( self , s = None , ** params ) : if s is not None : params = self . parse ( s ) if not params : raise TypeError ( 'You must specify device string or object attributes as kwargs' ) self . mac = params [ 'mac' ] # type : Optional [ str ] self . ip = params [ 'ip' ] # type : str self . serial_number = params [ 'serial_number' ] # type : str self . model = self . _get_model_cls ( params [ 'model' ] ) # type : type ( ZKModel ) self . version = params [ 'version' ] # type : Optional [ str ] def parse ( self , device_line : str ) -> Mapping [ str, str ] : \"\"\" Parse and validate raw device string :param device_line: event string :return: dictionary where keys are slots and values are appropriate values extracted from string \"\"\" device_line = device_line . replace ( '\\r\\n' , '' ) res = {} tokens_mapping = dict ( zip ( self . parse_tokens , self . __slots__ )) pieces = device_line . split ( ',' ) for piece in pieces : tok , val = piece . split ( '=' ) if tok not in tokens_mapping : raise ValueError ( \"Unknown param '{}={}' found in device string '{}'\" . format ( tok , val , device_line )) res [ tokens_mapping[tok ] ] = val # { slot : value } if res . keys () != set ( self . __slots__ ) : raise ValueError ( \"Some keys was not found in device string '{}'\" . format ( device_line )) return res def _get_model_cls ( self , model_name ) -> type ( ZKModel ) : if isinstance ( model_name , type ) and issubclass ( model_name , ZKModel ) : return model_name for cls in self . available_models : if cls . name == model_name : return cls raise ValueError ( \"Unknown device model '{}'\" . format ( model_name )) def __eq__ ( self , other ) : if isinstance ( other , ZKDevice ) : return all ( getattr ( self , attr ) == getattr ( other , attr ) for attr in self . __slots__ ) return False def __ne__ ( self , other ) : return not self . __eq__ ( other ) def __str__ ( self ) : params = ', ' . join ( '{}={}' . format ( k , getattr ( self , k , '?' )) for k in self . __slots__ ) return 'Device[{}]({})' . format ( self . model . name , params ) def __repr__ ( self ) : return self . __str__ ()","title":"ZKDevice"},{"location":"reference/pyzkaccess/device/#class-variables_3","text":"available_models parse_tokens","title":"Class variables"},{"location":"reference/pyzkaccess/device/#instance-variables","text":"ip mac model serial_number version","title":"Instance variables"},{"location":"reference/pyzkaccess/device/#methods","text":"","title":"Methods"},{"location":"reference/pyzkaccess/device/#parse","text":"def parse ( self , device_line : str ) -> Mapping [ str , str ] Parse and validate raw device string :param device_line: event string :return: dictionary where keys are slots and values are appropriate values extracted from string View Source def parse ( self , device_line : str ) -> Mapping [ str, str ] : \"\"\" Parse and validate raw device string :param device_line: event string :return: dictionary where keys are slots and values are appropriate values extracted from string \"\"\" device_line = device_line . replace ( '\\r\\n' , '' ) res = {} tokens_mapping = dict ( zip ( self . parse_tokens , self . __slots__ )) pieces = device_line . split ( ',' ) for piece in pieces : tok , val = piece . split ( '=' ) if tok not in tokens_mapping : raise ValueError ( \"Unknown param '{}={}' found in device string '{}'\" . format ( tok , val , device_line )) res [ tokens_mapping[tok ] ] = val # { slot : value } if res . keys () != set ( self . __slots__ ) : raise ValueError ( \"Some keys was not found in device string '{}'\" . format ( device_line )) return res","title":"parse"},{"location":"reference/pyzkaccess/device/#zkmodel","text":"class ZKModel ( / , * args , ** kwargs ) Base class for concrete ZK model Contains model-specific definitions View Source class ZKModel : \"\"\"Base class for concrete ZK model Contains model-specific definitions \"\"\" #: Name of model name = None #: Relays count relays = None #: Definition of relay numbers (count must be equal to `relays`) relays_def = None #: Definition of relay groups (count must be equal to `relays`) groups_def = None #: Definition of reader numbers readers_def = None #: Definition of door numbers doors_dev = None #: Definition of aux input numbers aux_inputs_def = None #: Anti-passback rules available on concrete device model anti_passback_rules = None #: Interlock rules available on concrete device model interlock_rules = None","title":"ZKModel"},{"location":"reference/pyzkaccess/device/#descendants","text":"pyzkaccess.device.ZK400 pyzkaccess.device.ZK200 pyzkaccess.device.ZK100","title":"Descendants"},{"location":"reference/pyzkaccess/device/#class-variables_4","text":"anti_passback_rules aux_inputs_def doors_dev groups_def interlock_rules name readers_def relays relays_def","title":"Class variables"},{"location":"reference/pyzkaccess/door/","text":"Module pyzkaccess.door View Source __all__ = [ 'Door' , 'DoorList' ] from abc import ABCMeta , abstractmethod from typing import Iterable , Union from .aux_input import AuxInput , AuxInputList from .common import UserTuple from .event import EventLog from .param import DoorParameters from .reader import Reader , ReaderList from .relay import RelayList from .sdk import ZKSDK class DoorInterface ( metaclass = ABCMeta ): @property def events ( self ) -> EventLog : \"\"\"Event log of current door. This includes events of its relays, readers, aux inputs and so forth \"\"\" return self . _specific_event_log () @property @abstractmethod def relays ( self ) -> RelayList : \"\"\"Relays which belong to this door\"\"\" pass @abstractmethod def _specific_event_log ( self ) -> EventLog : pass class Door ( DoorInterface ): \"\"\"Concrete door\"\"\" def __init__ ( self , sdk : ZKSDK , event_log : EventLog , number : int , relays : RelayList , reader : Reader , aux_input : AuxInput , parameters : DoorParameters ): self . number = number self . _sdk = sdk self . _event_log = event_log self . _relays = relays self . _reader = reader self . _aux_input = aux_input self . _parameters = parameters @property def relays ( self ) -> RelayList : return self . _relays @property def reader ( self ) -> Reader : \"\"\"Reader which belong to this door\"\"\" return self . _reader @property def aux_input ( self ) -> AuxInput : \"\"\"Aux input which belong to this door\"\"\" return self . _aux_input @property def parameters ( self ) -> DoorParameters : \"\"\"Device parameters related to this door\"\"\" return self . _parameters def _specific_event_log ( self ) -> EventLog : return self . _event_log . only ( door = [ self . number ]) def __eq__ ( self , other ): if isinstance ( other , Door ): return self . number == other . number \\ and self . _sdk is other . _sdk \\ and self . _relays == other . _relays \\ and self . _reader == other . _reader \\ and self . _aux_input == other . _aux_input return False def __ne__ ( self , other ): return not self . __eq__ ( other ) def __str__ ( self ): return \"Door[{}]\" . format ( self . number ) def __repr__ ( self ): return self . __str__ () class DoorList ( DoorInterface , UserTuple ): \"\"\"Collection of door objects which is used to perform group operations over multiple doors \"\"\" def __init__ ( self , sdk : ZKSDK , event_log : EventLog , doors : Iterable [ Door ]): super () . __init__ ( doors ) self . _sdk = sdk self . _event_log = event_log @property def relays ( self ) -> RelayList : \"\"\"Relays which belong to this doors\"\"\" relays = [ relay for door in self for relay in door . relays ] return RelayList ( self . _sdk , relays = relays ) @property def readers ( self ) -> ReaderList : \"\"\"Readers which belong to this door\"\"\" readers = [ x . reader for x in self ] return ReaderList ( self . _sdk , event_log = self . _event_log , readers = readers ) @property def aux_inputs ( self ) -> AuxInputList : \"\"\"Aux inputs which belong to this door\"\"\" aux_inputs = [ x . aux_input for x in self ] return AuxInputList ( self . _sdk , event_log = self . _event_log , aux_inputs = aux_inputs ) def __getitem__ ( self , item : Union [ int , slice ]) -> Union [ Door , 'DoorList' ]: doors = self . data [ item ] if isinstance ( item , slice ): return self . __class__ ( self . _sdk , self . _event_log , doors = doors ) else : return doors def _specific_event_log ( self ) -> EventLog : doors = set ( x . number for x in self ) return self . _event_log . only ( door = doors ) Classes Door class Door ( sdk : pyzkaccess . sdk . ZKSDK , event_log : pyzkaccess . event . EventLog , number : int , relays : pyzkaccess . relay . RelayList , reader : pyzkaccess . reader . Reader , aux_input : pyzkaccess . aux_input . AuxInput , parameters : pyzkaccess . param . DoorParameters ) Concrete door View Source class Door ( DoorInterface ) : \"\"\"Concrete door\"\"\" def __init__ ( self , sdk : ZKSDK , event_log : EventLog , number : int , relays : RelayList , reader : Reader , aux_input : AuxInput , parameters : DoorParameters ) : self . number = number self . _sdk = sdk self . _event_log = event_log self . _relays = relays self . _reader = reader self . _aux_input = aux_input self . _parameters = parameters @property def relays ( self ) -> RelayList : return self . _relays @property def reader ( self ) -> Reader : \"\"\"Reader which belong to this door\"\"\" return self . _reader @property def aux_input ( self ) -> AuxInput : \"\"\"Aux input which belong to this door\"\"\" return self . _aux_input @property def parameters ( self ) -> DoorParameters : \"\"\"Device parameters related to this door\"\"\" return self . _parameters def _specific_event_log ( self ) -> EventLog : return self . _event_log . only ( door =[ self.number ] ) def __eq__ ( self , other ) : if isinstance ( other , Door ) : return self . number == other . number \\ and self . _sdk is other . _sdk \\ and self . _relays == other . _relays \\ and self . _reader == other . _reader \\ and self . _aux_input == other . _aux_input return False def __ne__ ( self , other ) : return not self . __eq__ ( other ) def __str__ ( self ) : return \"Door[{}]\" . format ( self . number ) def __repr__ ( self ) : return self . __str__ () Ancestors (in MRO) pyzkaccess.door.DoorInterface Instance variables aux_input Aux input which belong to this door events Event log of current door. This includes events of its relays, readers, aux inputs and so forth parameters Device parameters related to this door reader Reader which belong to this door relays DoorList class DoorList ( sdk : pyzkaccess . sdk . ZKSDK , event_log : pyzkaccess . event . EventLog , doors : Iterable [ pyzkaccess . door . Door ] ) Collection of door objects which is used to perform group operations over multiple doors View Source class DoorList ( DoorInterface , UserTuple ) : \"\"\"Collection of door objects which is used to perform group operations over multiple doors \"\"\" def __init__ ( self , sdk : ZKSDK , event_log : EventLog , doors : Iterable [ Door ] ) : super (). __init__ ( doors ) self . _sdk = sdk self . _event_log = event_log @property def relays ( self ) -> RelayList : \"\"\"Relays which belong to this doors\"\"\" relays = [ relay for door in self for relay in door.relays ] return RelayList ( self . _sdk , relays = relays ) @property def readers ( self ) -> ReaderList : \"\"\"Readers which belong to this door\"\"\" readers = [ x.reader for x in self ] return ReaderList ( self . _sdk , event_log = self . _event_log , readers = readers ) @property def aux_inputs ( self ) -> AuxInputList : \"\"\"Aux inputs which belong to this door\"\"\" aux_inputs = [ x.aux_input for x in self ] return AuxInputList ( self . _sdk , event_log = self . _event_log , aux_inputs = aux_inputs ) def __getitem__ ( self , item : Union [ int, slice ] ) -> Union [ Door, 'DoorList' ] : doors = self . data [ item ] if isinstance ( item , slice ) : return self . __class__ ( self . _sdk , self . _event_log , doors = doors ) else : return doors def _specific_event_log ( self ) -> EventLog : doors = set ( x . number for x in self ) return self . _event_log . only ( door = doors ) Ancestors (in MRO) pyzkaccess.door.DoorInterface pyzkaccess.common.UserTuple Instance variables aux_inputs Aux inputs which belong to this door events Event log of current door. This includes events of its relays, readers, aux inputs and so forth readers Readers which belong to this door relays Relays which belong to this doors Methods copy def copy ( self ) View Source def copy(self): return self.__class__(self) count def count ( self , item ) View Source def count(self, item): return self.data.count(item) index def index ( self , item , * args ) View Source def index(self, item, *args): return self.data.index(item, *args)","title":"Door"},{"location":"reference/pyzkaccess/door/#module-pyzkaccessdoor","text":"View Source __all__ = [ 'Door' , 'DoorList' ] from abc import ABCMeta , abstractmethod from typing import Iterable , Union from .aux_input import AuxInput , AuxInputList from .common import UserTuple from .event import EventLog from .param import DoorParameters from .reader import Reader , ReaderList from .relay import RelayList from .sdk import ZKSDK class DoorInterface ( metaclass = ABCMeta ): @property def events ( self ) -> EventLog : \"\"\"Event log of current door. This includes events of its relays, readers, aux inputs and so forth \"\"\" return self . _specific_event_log () @property @abstractmethod def relays ( self ) -> RelayList : \"\"\"Relays which belong to this door\"\"\" pass @abstractmethod def _specific_event_log ( self ) -> EventLog : pass class Door ( DoorInterface ): \"\"\"Concrete door\"\"\" def __init__ ( self , sdk : ZKSDK , event_log : EventLog , number : int , relays : RelayList , reader : Reader , aux_input : AuxInput , parameters : DoorParameters ): self . number = number self . _sdk = sdk self . _event_log = event_log self . _relays = relays self . _reader = reader self . _aux_input = aux_input self . _parameters = parameters @property def relays ( self ) -> RelayList : return self . _relays @property def reader ( self ) -> Reader : \"\"\"Reader which belong to this door\"\"\" return self . _reader @property def aux_input ( self ) -> AuxInput : \"\"\"Aux input which belong to this door\"\"\" return self . _aux_input @property def parameters ( self ) -> DoorParameters : \"\"\"Device parameters related to this door\"\"\" return self . _parameters def _specific_event_log ( self ) -> EventLog : return self . _event_log . only ( door = [ self . number ]) def __eq__ ( self , other ): if isinstance ( other , Door ): return self . number == other . number \\ and self . _sdk is other . _sdk \\ and self . _relays == other . _relays \\ and self . _reader == other . _reader \\ and self . _aux_input == other . _aux_input return False def __ne__ ( self , other ): return not self . __eq__ ( other ) def __str__ ( self ): return \"Door[{}]\" . format ( self . number ) def __repr__ ( self ): return self . __str__ () class DoorList ( DoorInterface , UserTuple ): \"\"\"Collection of door objects which is used to perform group operations over multiple doors \"\"\" def __init__ ( self , sdk : ZKSDK , event_log : EventLog , doors : Iterable [ Door ]): super () . __init__ ( doors ) self . _sdk = sdk self . _event_log = event_log @property def relays ( self ) -> RelayList : \"\"\"Relays which belong to this doors\"\"\" relays = [ relay for door in self for relay in door . relays ] return RelayList ( self . _sdk , relays = relays ) @property def readers ( self ) -> ReaderList : \"\"\"Readers which belong to this door\"\"\" readers = [ x . reader for x in self ] return ReaderList ( self . _sdk , event_log = self . _event_log , readers = readers ) @property def aux_inputs ( self ) -> AuxInputList : \"\"\"Aux inputs which belong to this door\"\"\" aux_inputs = [ x . aux_input for x in self ] return AuxInputList ( self . _sdk , event_log = self . _event_log , aux_inputs = aux_inputs ) def __getitem__ ( self , item : Union [ int , slice ]) -> Union [ Door , 'DoorList' ]: doors = self . data [ item ] if isinstance ( item , slice ): return self . __class__ ( self . _sdk , self . _event_log , doors = doors ) else : return doors def _specific_event_log ( self ) -> EventLog : doors = set ( x . number for x in self ) return self . _event_log . only ( door = doors )","title":"Module pyzkaccess.door"},{"location":"reference/pyzkaccess/door/#classes","text":"","title":"Classes"},{"location":"reference/pyzkaccess/door/#door","text":"class Door ( sdk : pyzkaccess . sdk . ZKSDK , event_log : pyzkaccess . event . EventLog , number : int , relays : pyzkaccess . relay . RelayList , reader : pyzkaccess . reader . Reader , aux_input : pyzkaccess . aux_input . AuxInput , parameters : pyzkaccess . param . DoorParameters ) Concrete door View Source class Door ( DoorInterface ) : \"\"\"Concrete door\"\"\" def __init__ ( self , sdk : ZKSDK , event_log : EventLog , number : int , relays : RelayList , reader : Reader , aux_input : AuxInput , parameters : DoorParameters ) : self . number = number self . _sdk = sdk self . _event_log = event_log self . _relays = relays self . _reader = reader self . _aux_input = aux_input self . _parameters = parameters @property def relays ( self ) -> RelayList : return self . _relays @property def reader ( self ) -> Reader : \"\"\"Reader which belong to this door\"\"\" return self . _reader @property def aux_input ( self ) -> AuxInput : \"\"\"Aux input which belong to this door\"\"\" return self . _aux_input @property def parameters ( self ) -> DoorParameters : \"\"\"Device parameters related to this door\"\"\" return self . _parameters def _specific_event_log ( self ) -> EventLog : return self . _event_log . only ( door =[ self.number ] ) def __eq__ ( self , other ) : if isinstance ( other , Door ) : return self . number == other . number \\ and self . _sdk is other . _sdk \\ and self . _relays == other . _relays \\ and self . _reader == other . _reader \\ and self . _aux_input == other . _aux_input return False def __ne__ ( self , other ) : return not self . __eq__ ( other ) def __str__ ( self ) : return \"Door[{}]\" . format ( self . number ) def __repr__ ( self ) : return self . __str__ ()","title":"Door"},{"location":"reference/pyzkaccess/door/#ancestors-in-mro","text":"pyzkaccess.door.DoorInterface","title":"Ancestors (in MRO)"},{"location":"reference/pyzkaccess/door/#instance-variables","text":"aux_input Aux input which belong to this door events Event log of current door. This includes events of its relays, readers, aux inputs and so forth parameters Device parameters related to this door reader Reader which belong to this door relays","title":"Instance variables"},{"location":"reference/pyzkaccess/door/#doorlist","text":"class DoorList ( sdk : pyzkaccess . sdk . ZKSDK , event_log : pyzkaccess . event . EventLog , doors : Iterable [ pyzkaccess . door . Door ] ) Collection of door objects which is used to perform group operations over multiple doors View Source class DoorList ( DoorInterface , UserTuple ) : \"\"\"Collection of door objects which is used to perform group operations over multiple doors \"\"\" def __init__ ( self , sdk : ZKSDK , event_log : EventLog , doors : Iterable [ Door ] ) : super (). __init__ ( doors ) self . _sdk = sdk self . _event_log = event_log @property def relays ( self ) -> RelayList : \"\"\"Relays which belong to this doors\"\"\" relays = [ relay for door in self for relay in door.relays ] return RelayList ( self . _sdk , relays = relays ) @property def readers ( self ) -> ReaderList : \"\"\"Readers which belong to this door\"\"\" readers = [ x.reader for x in self ] return ReaderList ( self . _sdk , event_log = self . _event_log , readers = readers ) @property def aux_inputs ( self ) -> AuxInputList : \"\"\"Aux inputs which belong to this door\"\"\" aux_inputs = [ x.aux_input for x in self ] return AuxInputList ( self . _sdk , event_log = self . _event_log , aux_inputs = aux_inputs ) def __getitem__ ( self , item : Union [ int, slice ] ) -> Union [ Door, 'DoorList' ] : doors = self . data [ item ] if isinstance ( item , slice ) : return self . __class__ ( self . _sdk , self . _event_log , doors = doors ) else : return doors def _specific_event_log ( self ) -> EventLog : doors = set ( x . number for x in self ) return self . _event_log . only ( door = doors )","title":"DoorList"},{"location":"reference/pyzkaccess/door/#ancestors-in-mro_1","text":"pyzkaccess.door.DoorInterface pyzkaccess.common.UserTuple","title":"Ancestors (in MRO)"},{"location":"reference/pyzkaccess/door/#instance-variables_1","text":"aux_inputs Aux inputs which belong to this door events Event log of current door. This includes events of its relays, readers, aux inputs and so forth readers Readers which belong to this door relays Relays which belong to this doors","title":"Instance variables"},{"location":"reference/pyzkaccess/door/#methods","text":"","title":"Methods"},{"location":"reference/pyzkaccess/door/#copy","text":"def copy ( self ) View Source def copy(self): return self.__class__(self)","title":"copy"},{"location":"reference/pyzkaccess/door/#count","text":"def count ( self , item ) View Source def count(self, item): return self.data.count(item)","title":"count"},{"location":"reference/pyzkaccess/door/#index","text":"def index ( self , item , * args ) View Source def index(self, item, *args): return self.data.index(item, *args)","title":"index"},{"location":"reference/pyzkaccess/enum/","text":"Module pyzkaccess.enum View Source __all__ = [ 'ControlOperation' , 'RelayGroup' , 'SensorType' , 'VerifyMode' , 'PassageDirection' , 'EVENT_TYPES' , 'PULL_SDK_ERRORS' , 'WSA_ERROR_CODES' ] from enum import Enum from .common import DocDict class ControlOperation ( Enum ): \"\"\"Device control operation. See `ControlOperation` SDK func docs\"\"\" output = 1 cancel_alarm = 2 restart = 3 class RelayGroup ( Enum ): \"\"\"Device relay group. There are either lock relays (door output) or aux relays (aux output) \"\"\" lock = 1 aux = 2 class SensorType ( Enum ): \"\"\"Sensor type of door. See DoorXSensorType parameter in SDK docs\"\"\" not_available = 0 normal_open = 1 normal_closed = 2 class VerifyMode ( Enum ): \"\"\"Which methods are used to authenticate user. See `DoorXVerifyType` parameter in SDK docs \"\"\" not_available = 0 only_finger = 1 only_password = 3 only_card = 4 card_or_finger = 6 card_and_finger = 10 card_and_password = 11 others = 200 class PassageDirection ( Enum ): \"\"\"Whether a user was entered or exited via door See event format description in SDK docs \"\"\" entry = 0 exit = 1 none = 2 #: Type of event which is returned by GetRTLog function #: See event format description in SDK docs EVENT_TYPES = DocDict ({ 0 : 'Normal Punch Open' , 1 : 'Punch during Normal Open Time Zone' , 2 : 'First Card Normal Open (Punch Card)' , 3 : 'Multi-Card Open (Punching Card)' , 4 : 'Emergency Password Open' , 5 : 'Open during Normal Open Time Zone' , 6 : 'Linkage Event Triggered' , 7 : 'Cancel Alarm' , 8 : 'Remote Opening' , 9 : 'Remote Closing' , 10 : 'Disable Intraday Normal Open Time Zone' , 11 : 'Enable Intraday Normal Open Time Zone' , 12 : 'Open Auxiliary Output' , 13 : 'Close Auxiliary Output' , 14 : 'Press Fingerprint Open' , 15 : 'Multi-Card Open (Press Fingerprint)' , 16 : 'Press Fingerprint during Normal Open Time Zone' , 17 : 'Card plus Fingerprint Open' , 18 : 'First Card Normal Open (Press Fingerprint)' , 19 : 'First Card Normal Open (Card plus Fingerprint)' , 20 : 'Too Short Punch Interval' , 21 : 'Door Inactive Time Zone (Punch Card)' , 22 : 'Illegal Time Zone' , 23 : 'Access Denied' , 24 : 'Anti-Passback' , 25 : 'Interlock' , 26 : 'Multi-Card Authentication (Punching Card)' , 27 : 'Unregistered Card' , 28 : 'Opening Timeout' , 29 : 'Card Expired' , 30 : 'Password Error' , 31 : 'Too Short Fingerprint Pressing Interval' , 32 : 'Multi-Card Authentication (Press Fingerprint)' , 33 : 'Fingerprint Expired' , 34 : 'Unregistered Fingerprint' , 35 : 'Door Inactive Time Zone (Press Fingerprint)' , 36 : 'Door Inactive Time Zone (Exit Button)' , 37 : 'Failed to Close during Normal Open Time Zone' , 101 : 'Duress Password Open' , 102 : 'Opened Accidentally' , 103 : 'Duress Fingerprint Open' , 200 : 'Door Opened Correctly' , 201 : 'Door Closed Correctly' , 202 : 'Exit button Open' , 203 : 'Multi-Card Open (Card plus Fingerprint)' , 204 : 'Normal Open Time Zone Over' , 205 : 'Remote Normal Opening' , 220 : 'Auxiliary Input Disconnected' , 221 : 'Auxiliary Input Shorted' , 255 : 'Actually that obtain door status and alarm status' , }) #: Errors which SDK functions may return. See errors description in SDK PULL_SDK_ERRORS = DocDict ({ - 1 : 'The command is not sent successfully' , - 2 : 'The command has no response' , - 3 : 'The buffer is not enough' , - 4 : 'The decompression fails' , - 5 : 'The length of the read data is not correct' , - 6 : 'The length of the decompressed data is not consistent with the expected length' , - 7 : 'The command is repeated' , - 8 : 'The connection is not authorized' , - 9 : 'Data error: The CRC result is failure' , - 10 : 'Data error: PullSDK cannot resolve the data' , - 11 : 'Data parameter error' , - 12 : 'The command is not executed correctly' , - 13 : 'Command error: This command is not available' , - 14 : 'The communication password is not correct' , - 15 : 'Fail to write the file' , - 16 : 'Fail to read the file' , - 17 : 'The file does not exist' , - 99 : 'Unknown error' , - 100 : 'The table structure does not exist' , - 101 : 'In the table structure, the Condition field does not exit' , - 102 : 'The total number of fields is not consistent' , - 103 : 'The sequence of fields is not consistent' , - 104 : 'Real-time event data error' , - 105 : 'Data errors occur during data resolution.' , - 106 : 'Data overflow: The delivered data is more than 4 MB in length' , - 107 : 'Fail to get the table structure' , - 108 : 'Invalid options' , - 201 : 'LoadLibrary failure' , - 202 : 'Fail to invoke the interface' , - 203 : 'Communication initialization fails' , - 206 : 'Start of a serial interface agent program fails and the cause generally relies in ' 'inexistence or occupation of the serial interface.' , - 301 : 'Requested TCP/IP version error' , - 302 : 'Incorrect version number' , - 303 : 'Fail to get the protocol type' , - 304 : 'Invalid SOCKET' , - 305 : 'SOCKET error' , - 306 : 'HOST error' , - 307 : 'Connection attempt failed' , }) #: SDK functions can also return WINSOCK errors using `PullLastError` #: function. See SDK docs and MSDN WSA_ERROR_CODES = DocDict ({ 6 : \"WSA_INVALID_HANDLE (Specified event object handle is invalid. An application attempts to \" \"use an event object, but the specified handle is not valid)\" , 8 : \"WSA_NOT_ENOUGH_MEMORY (Insufficient memory available. An application used a Windows \" \"Sockets function that directly maps to a Windows function. The Windows function is \" \"indicating a lack of required memory resources)\" , 87 : \"WSA_INVALID_PARAMETER (One or more parameters are invalid. An application used a Windows \" \"Sockets function which directly maps to a Windows function. The Windows function is \" \"indicating a problem with one or more parameters)\" , 995 : \"WSA_OPERATION_ABORTED (Overlapped operation aborted. An overlapped operation was \" \"canceled due to the closure of the socket, or the execution of the SIO_FLUSH command \" \"in WSAIoctl)\" , 996 : \"WSA_IO_INCOMPLETE (Overlapped I/O event object not in signaled state. The application \" \"has tried to determine the status of an overlapped operation which is not yet completed. \" \"Applications that use WSAGetOverlappedResult (with the fWait flag set to FALSE) in a \" \"polling mode to determine when an overlapped operation has completed, get this error \" \"code until the operation is complete)\" , 997 : \"WSA_IO_PENDING (Overlapped operations will complete later. The application has \" \"initiated an overlapped operation that cannot be completed immediately. A completion \" \"indication will be given later when the operation has been completed)\" , 10004 : \"WSAEINTR (Interrupted function call. A blocking operation was interrupted by a call \" \"to WSACancelBlockingCall)\" , 10009 : \"WSAEBADF (File handle is not valid. The file handle supplied is not valid)\" , 10013 : \"WSAEACCES (Permission denied. An attempt was made to access a socket in a way \" \"forbidden by its access permissions. An example is using a broadcast address for \" \"sendto without broadcast permission being set using setsockopt(SO_BROADCAST). \" \"Another possible reason for the WSAEACCES error is that when the bind function \" \"is called (on Windows NT 4.0 with SP4 and later), another application, service, \" \"or kernel mode driver is bound to the same address with exclusive access. Such \" \"exclusive access is a new feature of Windows NT 4.0 with SP4 and later, and is \" \"implemented by using the SO_EXCLUSIVEADDRUSE option)\" , 10014 : \"WSAEFAULT (Bad address. The system detected an invalid pointer address in \" \"attempting to use a pointer argument of a call. This error occurs if an application \" \"passes an invalid pointer value, or if the length of the buffer is too small. \" \"For instance, if the length of an argument, which is a sockaddr structure, is \" \"smaller than the sizeof(sockaddr))\" , 10022 : \"WSAEINVAL (Invalid argument. Some invalid argument was supplied (for example, \" \"specifying an invalid level to the setsockopt function). In some instances, it \" \"also refers to the current state of the socket\u2014for instance, calling accept on \" \"a socket that is not listening)\" , 10024 : \"WSAEMFILE (Too many open files. Too many open sockets. Each implementation may \" \"have a maximum number of socket handles available, either globally, per process, \" \"or per thread)\" , 10035 : \"WSAEWOULDBLOCK (Resource temporarily unavailable. This error is returned from \" \"operations on nonblocking sockets that cannot be completed immediately, for \" \"example recv when no data is queued to be read from the socket. It is a nonfatal \" \"error, and the operation should be retried later. It is normal for WSAEWOULDBLOCK \" \"to be reported as the result from calling connect on a nonblocking SOCK_STREAM \" \"socket, since some time must elapse for the connection to be established)\" , 10036 : \"WSAEINPROGRESS (Operation now in progress. A blocking operation is currently \" \"executing. Windows Sockets only allows a single blocking operation\u2014per- task or \" \"thread\u2014to be outstanding, and if any other function call is made (whether or \" \"not it references that or any other socket) the function fails with the \" \"WSAEINPROGRESS error)\" , 10037 : \"WSAEALREADY (Operation already in progress. An operation was attempted on a \" \"nonblocking socket with an operation already in progress\u2014that is, calling connect \" \"a second time on a nonblocking socket that is already connecting, or canceling \" \"an asynchronous request (WSAAsyncGetXbyY) that has already been canceled or \" \"completed)\" , 10038 : \"WSAENOTSOCK (Socket operation on nonsocket. An operation was attempted on \" \"something that is not a socket. Either the socket handle parameter did not \" \"reference a valid socket, or for select, a member of an fd_set was not valid)\" , 10039 : \"WSAEDESTADDRREQ (Destination address required. A required address was omitted \" \"from an operation on a socket. For example, this error is returned if sendto \" \"is called with the remote address of ADDR_ANY)\" , 10040 : \"WSAEMSGSIZE (Message too long. A message sent on a datagram socket was larger \" \"than the internal message buffer or some other network limit, or the buffer used \" \"to receive a datagram was smaller than the datagram itself)\" , 10041 : \"WSAEPROTOTYPE (Protocol wrong type for socket. A protocol was specified in the \" \"socket function call that does not support the semantics of the socket type \" \"requested. For example, the ARPA Internet UDP protocol cannot be specified with \" \"a socket type of SOCK_STREAM)\" , 10042 : \"WSAENOPROTOOPT (Bad protocol option. An unknown, invalid or unsupported option \" \"or level was specified in a getsockopt or setsockopt call)\" , 10043 : \"WSAEPROTONOSUPPORT (Protocol not supported. The requested protocol has not been \" \"configured into the system, or no implementation for it exists. For example, a \" \"socket call requests a SOCK_DGRAM socket, but specifies a stream protocol)\" , 10044 : \"WSAESOCKTNOSUPPORT (Socket type not supported. The support for the specified \" \"socket type does not exist in this address family. For example, the optional \" \"type SOCK_RAW might be selected in a socket call, and the implementation does \" \"not support SOCK_RAW sockets at all)\" , 10045 : \"WSAEOPNOTSUPP (Operation not supported. The attempted operation is not supported \" \"for the type of object referenced. Usually this occurs when a socket descriptor \" \"to a socket that cannot support this operation is trying to accept a connection \" \"on a datagram socket)\" , 10046 : \"WSAEPFNOSUPPORT (Protocol family not supported. The protocol family has not been \" \"configured into the system or no implementation for it exists. This message has \" \"a slightly different meaning from WSAEAFNOSUPPORT. However, it is interchangeable \" \"in most cases, and all Windows Sockets functions that return one of these messages \" \"also specify WSAEAFNOSUPPORT)\" , 10047 : \"WSAEAFNOSUPPORT (Address family not supported by protocol family. An address \" \"incompatible with the requested protocol was used. All sockets are created with \" \"an associated address family (that is, AF_INET for Internet Protocols) and a \" \"generic protocol type (that is, SOCK_STREAM). This error is returned if an \" \"incorrect protocol is explicitly requested in the socket call, or if an address \" \"of the wrong family is used for a socket, for example, in sendto)\" , 10048 : \"WSAEADDRINUSE (Address already in use. Typically, only one usage of each socket \" \"address (protocol/IP address/port) is permitted. This error occurs if an \" \"application attempts to bind a socket to an IP address/port that has already \" \"been used for an existing socket, or a socket that was not closed properly, or \" \"one that is still in the process of closing. For server applications that need \" \"to bind multiple sockets to the same port number, consider using setsockopt \" \"(SO_REUSEADDR). Client applications usually need not call bind at all\u2014connect \" \"chooses an unused port automatically. When bind is called with a wildcard address \" \"(involving ADDR_ANY), a WSAEADDRINUSE error could be delayed until the specific \" \"address is committed. This could happen with a call to another function later, \" \"including connect, listen, WSAConnect, or WSAJoinLeaf)\" , 10049 : \"WSAEADDRNOTAVAIL (Cannot assign requested address. The requested address is not \" \"valid in its context. This normally results from an attempt to bind to an address \" \"that is not valid for the local computer. This can also result from connect, \" \"sendto, WSAConnect, WSAJoinLeaf, or WSASendTo when the remote address or port \" \"is not valid for a remote computer (for example, address or port 0))\" , 10050 : \"WSAENETDOWN (Network is down. A socket operation encountered a dead network. \" \"This could indicate a serious failure of the network system (that is, the \" \"protocol stack that the Windows Sockets DLL runs over), the network interface, \" \"or the local network itself)\" , 10051 : \"WSAENETUNREACH (Network is unreachable. A socket operation was attempted to \" \"an unreachable network. This usually means the local software knows no route \" \"to reach the remote host)\" , 10052 : \"WSAENETRESET (Network dropped connection on reset. The connection has been \" \"broken due to keep-alive activity detecting a failure while the operation was \" \"in progress. It can also be returned by setsockopt if an attempt is made to set \" \"SO_KEEPALIVE on a connection that has already failed)\" , 10053 : \"WSAECONNABORTED (Software caused connection abort. An established connection was \" \"aborted by the software in your host computer, possibly due to a data transmission \" \"time-out or protocol error)\" , 10054 : \"WSAECONNRESET (Connection reset by peer. An existing connection was forcibly \" \"closed by the remote host. This normally results if the peer application on the \" \"remote host is suddenly stopped, the host is rebooted, the host or remote network \" \"interface is disabled, or the remote host uses a hard close (see setsockopt for \" \"more information on the SO_LINGER option on the remote socket). This error may \" \"also result if a connection was broken due to keep-alive activity detecting a \" \"failure while one or more operations are in progress. Operations that were in \" \"progress fail with WSAENETRESET. Subsequent operations fail with WSAECONNRESET)\" , 10055 : \"WSAENOBUFS (No buffer space available. An operation on a socket could not be \" \"performed because the system lacked sufficient buffer space or because a queue \" \"was full)\" , 10056 : \"WSAEISCONN (Socket is already connected. A connect request was made on an \" \"already-connected socket. Some implementations also return this error if \" \"sendto is called on a connected SOCK_DGRAM socket (for SOCK_STREAM sockets, the \" \"to parameter in sendto is ignored) although other implementations treat this as \" \"a legal occurrence)\" , 10057 : \"WSAENOTCONN (Socket is not connected. A request to send or receive data was \" \"disallowed because the socket is not connected and (when sending on a datagram \" \"socket using sendto) no address was supplied. Any other type of operation might \" \"also return this error\u2014for example, setsockopt setting SO_KEEPALIVE if the \" \"connection has been reset)\" , 10058 : \"WSAESHUTDOWN (Cannot send after socket shutdown. A request to send or receive \" \"data was disallowed because the socket had already been shut down in that \" \"direction with a previous shutdown call. By calling shutdown a partial close \" \"of a socket is requested, which is a signal that sending or receiving, or both \" \"have been discontinued)\" , 10059 : \"WSAETOOMANYREFS (Too many references. Too many references to some kernel object)\" , 10060 : \"WSAETIMEDOUT (Connection timed out. A connection attempt failed because the \" \"connected party did not properly respond after a period of time, or the \" \"established connection failed because the connected host has failed to respond)\" , 10061 : \"WSAECONNREFUSED (Connection refused. No connection could be made because the \" \"target computer actively refused it. This usually results from trying to \" \"connect to a service that is inactive on the foreign host\u2014that is, one with \" \"no server application running)\" , 10062 : \"WSAELOOP (Cannot translate name. Cannot translate a name)\" , 10063 : \"WSAENAMETOOLONG (Name too long. A name component or a name was too long)\" , 10064 : \"WSAEHOSTDOWN (Host is down. A socket operation failed because the destination \" \"host is down. A socket operation encountered a dead host. Networking activity \" \"on the local host has not been initiated. These conditions are more likely to be \" \"indicated by the error WSAETIMEDOUT)\" , 10065 : \"WSAEHOSTUNREACH (No route to host. A socket operation was attempted to an \" \"unreachable host. See WSAENETUNREACH)\" , 10066 : \"WSAENOTEMPTY (Directory not empty. Cannot remove a directory that is not empty)\" , 10067 : \"WSAEPROCLIM (Too many processes. A Windows Sockets implementation may have a \" \"limit on the number of applications that can use it simultaneously. WSAStartup \" \"may fail with this error if the limit has been reached)\" , 10068 : \"WSAEUSERS (User quota exceeded. Ran out of user quota)\" , 10069 : \"WSAEDQUOT (Disk quota exceeded. Ran out of disk quota)\" , 10070 : \"WSAESTALE (Stale file handle reference. The file handle reference is no longer \" \"available)\" , 10071 : \"WSAEREMOTE (Item is remote. The item is not available locally)\" , 10091 : \"WSASYSNOTREADY (Network subsystem is unavailable. This error is returned by \" \"WSAStartup if the Windows Sockets implementation cannot function at this time \" \"because the underlying system it uses to provide network services is currently \" \"unavailable. Users should check: That the appropriate Windows Sockets DLL file \" \"is in the current path. That they are not trying to use more than one Windows \" \"Sockets implementation simultaneously. If there is more than one Winsock DLL on \" \"your system, be sure the first one in the path is appropriate for the network \" \"subsystem currently loaded. The Windows Sockets implementation documentation to \" \"be sure all necessary components are currently installed and configured correctly)\" , 10092 : \"WSAVERNOTSUPPORTED (Winsock.dll version out of range. The current Windows Sockets \" \"implementation does not support the Windows Sockets specification version \" \"requested by the application. Check that no old Windows Sockets DLL files are \" \"being accessed)\" , 10093 : \"WSANOTINITIALISED (Successful WSAStartup not yet performed. Either the application \" \"has not called WSAStartup or WSAStartup failed. The application may be accessing \" \"a socket that the current active task does not own (that is, trying to share a \" \"socket between tasks), or WSACleanup has been called too many times)\" , 10101 : \"WSAEDISCON (Graceful shutdown in progress. Returned by WSARecv and WSARecvFrom \" \"to indicate that the remote party has initiated a graceful shutdown sequence)\" , 10102 : \"WSAENOMORE (No more results. No more results can be returned by the \" \"WSALookupServiceNext function)\" , 10103 : \"WSAECANCELLED (Call has been canceled. A call to the WSALookupServiceEnd function \" \"was made while this call was still processing. The call has been canceled)\" , 10104 : \"WSAEINVALIDPROCTABLE (Procedure call table is invalid. The service provider \" \"procedure call table is invalid. A service provider returned a bogus procedure \" \"table to Ws2_32.dll. This is usually caused by one or more of the function \" \"pointers being NULL)\" , 10105 : \"WSAEINVALIDPROVIDER (Service provider is invalid. The requested service provider \" \"is invalid. This error is returned by the WSCGetProviderInfo and \" \"WSCGetProviderInfo32 functions if the protocol entry specified could not be found. \" \"This error is also returned if the service provider returned a version number \" \"other than 2.0)\" , 10106 : \"WSAEPROVIDERFAILEDINIT (Service provider failed to initialize. The requested \" \"service provider could not be loaded or initialized. This error is returned if \" \"either a service provider's DLL could not be loaded (LoadLibrary failed) or the \" \"provider's WSPStartup or NSPStartup function failed)\" , 10107 : \"WSASYSCALLFAILURE (System call failure. A system call that should never fail has \" \"failed. This is a generic error code, returned under various conditions. Returned \" \"when a system call that should never fail does fail. For example, if a call to \" \"WaitForMultipleEvents fails or one of the registry functions fails trying to \" \"manipulate the protocol/namespace catalogs. Returned when a provider does not \" \"return SUCCESS and does not provide an extended error code. Can indicate a \" \"service provider implementation error)\" , 10108 : \"WSASERVICE_NOT_FOUND (Service not found. No such service is known. The service \" \"cannot be found in the specified name space)\" , 10109 : \"WSATYPE_NOT_FOUND (Class type not found. The specified class was not found)\" , 10110 : \"WSA_E_NO_MORE (No more results. No more results can be returned by the \" \"WSALookupServiceNext function)\" , 10111 : \"WSA_E_CANCELLED (Call was canceled. A call to the WSALookupServiceEnd function \" \"was made while this call was still processing. The call has been canceled)\" , 10112 : \"WSAEREFUSED (Database query was refused. A database query failed because it \" \"was actively refused)\" , 11001 : \"WSAHOST_NOT_FOUND (Host not found. No such host is known. The name is not an \" \"official host name or alias, or it cannot be found in the database(s) being \" \"queried. This error may also be returned for protocol and service queries, and \" \"means that the specified name could not be found in the relevant database)\" , 11002 : \"WSATRY_AGAIN (Nonauthoritative host not found. This is usually a temporary error \" \"during host name resolution and means that the local server did not receive a \" \"response from an authoritative server. A retry at some time later may be successful)\" , 11003 : \"WSANO_RECOVERY (This is a nonrecoverable error. This indicates that some sort \" \"of nonrecoverable error occurred during a database lookup. This may be because \" \"the database files (for example, BSD-compatible HOSTS, SERVICES, or PROTOCOLS \" \"files) could not be found, or a DNS request was returned by the server with a \" \"severe error)\" , 11004 : \"WSANO_DATA (Valid name, no data record of requested type. The requested name is \" \"valid and was found in the database, but it does not have the correct associated \" \"data being resolved for. The usual example for this is a host name-to-address \" \"translation attempt (using gethostbyname or WSAAsyncGetHostByName) which uses \" \"the DNS (Domain Name Server). An MX record is returned but no A record\u2014indicating \" \"the host itself exists, but is not directly reachable)\" , 11005 : \"WSA_QOS_RECEIVERS (QoS receivers. At least one QoS reserve has arrived)\" , 11006 : \"WSA_QOS_SENDERS (QoS senders. At least one QoS send path has arrived)\" , 11007 : \"WSA_QOS_NO_SENDERS (No QoS senders. There are no QoS senders)\" , 11008 : \"WSA_QOS_NO_RECEIVERS (QoS no receivers. There are no QoS receivers)\" , 11009 : \"WSA_QOS_REQUEST_CONFIRMED (QoS request confirmed. The QoS reserve request has \" \"been confirmed)\" , 11010 : \"WSA_QOS_ADMISSION_FAILURE (QoS admission error. A QoS error occurred due to lack \" \"of resources)\" , 11011 : \"WSA_QOS_POLICY_FAILURE (QoS policy failure. The QoS request was rejected because \" \"the policy system couldn't allocate the requested resource within the existing \" \"policy)\" , 11012 : \"WSA_QOS_BAD_STYLE (QoS bad style. An unknown or conflicting QoS style was \" \"encountered)\" , 11013 : \"WSA_QOS_BAD_OBJECT (QoS bad object. A problem was encountered with some part \" \"of the filterspec or the provider-specific buffer in general)\" , 11014 : \"WSA_QOS_TRAFFIC_CTRL_ERROR (QoS traffic control error. An error with the \" \"underlying traffic control (TC) API as the generic QoS request was converted \" \"for local enforcement by the TC API. This could be due to an out of memory \" \"error or to an internal QoS provider error)\" , 11015 : \"WSA_QOS_GENERIC_ERROR (QoS generic error. A general QoS error)\" , 11016 : \"WSA_QOS_ESERVICETYPE (QoS service type error. An invalid or unrecognized service \" \"type was found in the QoS flowspec)\" , 11017 : \"WSA_QOS_EFLOWSPEC (QoS flowspec error. An invalid or inconsistent flowspec was \" \"found in the QOS structure)\" , 11018 : \"WSA_QOS_EPROVSPECBUF (Invalid QoS provider buffer. An invalid QoS provider-specific \" \"buffer)\" , 11019 : \"WSA_QOS_EFILTERSTYLE (Invalid QoS filter style. An invalid QoS filter style was used)\" , 11020 : \"WSA_QOS_EFILTERTYPE (Invalid QoS filter type. An invalid QoS filter type was used)\" , 11021 : \"WSA_QOS_EFILTERCOUNT (Incorrect QoS filter count. An incorrect number of QoS \" \"FILTERSPECs were specified in the FLOWDESCRIPTOR)\" , 11022 : \"WSA_QOS_EOBJLENGTH (Invalid QoS object length. An object with an invalid \" \"ObjectLength field was specified in the QoS provider-specific buffer)\" , 11023 : \"WSA_QOS_EFLOWCOUNT (Incorrect QoS flow count. An incorrect number of flow \" \"descriptors was specified in the QoS structure)\" , 11024 : \"WSA_QOS_EUNKOWNPSOBJ (Unrecognized QoS object. An unrecognized object was found \" \"in the QoS provider-specific buffer)\" , 11025 : \"WSA_QOS_EPOLICYOBJ (Invalid QoS policy object. An invalid policy object was found \" \"in the QoS provider-specific buffer)\" , 11026 : \"WSA_QOS_EFLOWDESC (Invalid QoS flow descriptor. An invalid QoS flow descriptor was \" \"found in the flow descriptor list)\" , 11027 : \"WSA_QOS_EPSFLOWSPEC (Invalid QoS provider-specific flowspec. An invalid or \" \"inconsistent flowspec was found in the QoS provider-specific buffer)\" , 11028 : \"WSA_QOS_EPSFILTERSPEC (Invalid QoS provider-specific filterspec. An invalid \" \"FILTERSPEC was found in the QoS provider-specific buffer)\" , 11029 : \"WSA_QOS_ESDMODEOBJ (Invalid QoS shape discard mode object. An invalid shape discard \" \"mode object was found in the QoS provider-specific buffer)\" , 11030 : \"WSA_QOS_ESHAPERATEOBJ (Invalid QoS shaping rate object. An invalid shaping rate \" \"object was found in the QoS provider-specific buffer)\" , 11031 : \"WSA_QOS_RESERVED_PETYPE (Reserved policy QoS element type. A reserved policy \" \"element was found in the QoS provider-specific buffer)\" , }) Variables EVENT_TYPES PULL_SDK_ERRORS WSA_ERROR_CODES Classes ControlOperation class ControlOperation ( / , * args , ** kwargs ) Device control operation. See ControlOperation SDK func docs View Source class ControlOperation ( Enum ): \"\"\"Device control operation. See `ControlOperation` SDK func docs\"\"\" output = 1 cancel_alarm = 2 restart = 3 Ancestors (in MRO) enum.Enum Class variables cancel_alarm name output restart value PassageDirection class PassageDirection ( / , * args , ** kwargs ) Whether a user was entered or exited via door See event format description in SDK docs View Source class PassageDirection ( Enum ): \"\"\"Whether a user was entered or exited via door See event format description in SDK docs \"\"\" entry = 0 exit = 1 none = 2 Ancestors (in MRO) enum.Enum Class variables entry exit name none value RelayGroup class RelayGroup ( / , * args , ** kwargs ) Device relay group. There are either lock relays (door output) or aux relays (aux output) View Source class RelayGroup ( Enum ): \"\"\"Device relay group. There are either lock relays (door output) or aux relays (aux output) \"\"\" lock = 1 aux = 2 Ancestors (in MRO) enum.Enum Class variables aux lock name value SensorType class SensorType ( / , * args , ** kwargs ) Sensor type of door. See DoorXSensorType parameter in SDK docs View Source class SensorType ( Enum ): \"\"\"Sensor type of door. See DoorXSensorType parameter in SDK docs\"\"\" not_available = 0 normal_open = 1 normal_closed = 2 Ancestors (in MRO) enum.Enum Class variables name normal_closed normal_open not_available value VerifyMode class VerifyMode ( / , * args , ** kwargs ) Which methods are used to authenticate user. See DoorXVerifyType parameter in SDK docs View Source class VerifyMode ( Enum ): \"\"\"Which methods are used to authenticate user. See `DoorXVerifyType` parameter in SDK docs \"\"\" not_available = 0 only_finger = 1 only_password = 3 only_card = 4 card_or_finger = 6 card_and_finger = 10 card_and_password = 11 others = 200 Ancestors (in MRO) enum.Enum Class variables card_and_finger card_and_password card_or_finger name not_available only_card only_finger only_password others value","title":"Enum"},{"location":"reference/pyzkaccess/enum/#module-pyzkaccessenum","text":"View Source __all__ = [ 'ControlOperation' , 'RelayGroup' , 'SensorType' , 'VerifyMode' , 'PassageDirection' , 'EVENT_TYPES' , 'PULL_SDK_ERRORS' , 'WSA_ERROR_CODES' ] from enum import Enum from .common import DocDict class ControlOperation ( Enum ): \"\"\"Device control operation. See `ControlOperation` SDK func docs\"\"\" output = 1 cancel_alarm = 2 restart = 3 class RelayGroup ( Enum ): \"\"\"Device relay group. There are either lock relays (door output) or aux relays (aux output) \"\"\" lock = 1 aux = 2 class SensorType ( Enum ): \"\"\"Sensor type of door. See DoorXSensorType parameter in SDK docs\"\"\" not_available = 0 normal_open = 1 normal_closed = 2 class VerifyMode ( Enum ): \"\"\"Which methods are used to authenticate user. See `DoorXVerifyType` parameter in SDK docs \"\"\" not_available = 0 only_finger = 1 only_password = 3 only_card = 4 card_or_finger = 6 card_and_finger = 10 card_and_password = 11 others = 200 class PassageDirection ( Enum ): \"\"\"Whether a user was entered or exited via door See event format description in SDK docs \"\"\" entry = 0 exit = 1 none = 2 #: Type of event which is returned by GetRTLog function #: See event format description in SDK docs EVENT_TYPES = DocDict ({ 0 : 'Normal Punch Open' , 1 : 'Punch during Normal Open Time Zone' , 2 : 'First Card Normal Open (Punch Card)' , 3 : 'Multi-Card Open (Punching Card)' , 4 : 'Emergency Password Open' , 5 : 'Open during Normal Open Time Zone' , 6 : 'Linkage Event Triggered' , 7 : 'Cancel Alarm' , 8 : 'Remote Opening' , 9 : 'Remote Closing' , 10 : 'Disable Intraday Normal Open Time Zone' , 11 : 'Enable Intraday Normal Open Time Zone' , 12 : 'Open Auxiliary Output' , 13 : 'Close Auxiliary Output' , 14 : 'Press Fingerprint Open' , 15 : 'Multi-Card Open (Press Fingerprint)' , 16 : 'Press Fingerprint during Normal Open Time Zone' , 17 : 'Card plus Fingerprint Open' , 18 : 'First Card Normal Open (Press Fingerprint)' , 19 : 'First Card Normal Open (Card plus Fingerprint)' , 20 : 'Too Short Punch Interval' , 21 : 'Door Inactive Time Zone (Punch Card)' , 22 : 'Illegal Time Zone' , 23 : 'Access Denied' , 24 : 'Anti-Passback' , 25 : 'Interlock' , 26 : 'Multi-Card Authentication (Punching Card)' , 27 : 'Unregistered Card' , 28 : 'Opening Timeout' , 29 : 'Card Expired' , 30 : 'Password Error' , 31 : 'Too Short Fingerprint Pressing Interval' , 32 : 'Multi-Card Authentication (Press Fingerprint)' , 33 : 'Fingerprint Expired' , 34 : 'Unregistered Fingerprint' , 35 : 'Door Inactive Time Zone (Press Fingerprint)' , 36 : 'Door Inactive Time Zone (Exit Button)' , 37 : 'Failed to Close during Normal Open Time Zone' , 101 : 'Duress Password Open' , 102 : 'Opened Accidentally' , 103 : 'Duress Fingerprint Open' , 200 : 'Door Opened Correctly' , 201 : 'Door Closed Correctly' , 202 : 'Exit button Open' , 203 : 'Multi-Card Open (Card plus Fingerprint)' , 204 : 'Normal Open Time Zone Over' , 205 : 'Remote Normal Opening' , 220 : 'Auxiliary Input Disconnected' , 221 : 'Auxiliary Input Shorted' , 255 : 'Actually that obtain door status and alarm status' , }) #: Errors which SDK functions may return. See errors description in SDK PULL_SDK_ERRORS = DocDict ({ - 1 : 'The command is not sent successfully' , - 2 : 'The command has no response' , - 3 : 'The buffer is not enough' , - 4 : 'The decompression fails' , - 5 : 'The length of the read data is not correct' , - 6 : 'The length of the decompressed data is not consistent with the expected length' , - 7 : 'The command is repeated' , - 8 : 'The connection is not authorized' , - 9 : 'Data error: The CRC result is failure' , - 10 : 'Data error: PullSDK cannot resolve the data' , - 11 : 'Data parameter error' , - 12 : 'The command is not executed correctly' , - 13 : 'Command error: This command is not available' , - 14 : 'The communication password is not correct' , - 15 : 'Fail to write the file' , - 16 : 'Fail to read the file' , - 17 : 'The file does not exist' , - 99 : 'Unknown error' , - 100 : 'The table structure does not exist' , - 101 : 'In the table structure, the Condition field does not exit' , - 102 : 'The total number of fields is not consistent' , - 103 : 'The sequence of fields is not consistent' , - 104 : 'Real-time event data error' , - 105 : 'Data errors occur during data resolution.' , - 106 : 'Data overflow: The delivered data is more than 4 MB in length' , - 107 : 'Fail to get the table structure' , - 108 : 'Invalid options' , - 201 : 'LoadLibrary failure' , - 202 : 'Fail to invoke the interface' , - 203 : 'Communication initialization fails' , - 206 : 'Start of a serial interface agent program fails and the cause generally relies in ' 'inexistence or occupation of the serial interface.' , - 301 : 'Requested TCP/IP version error' , - 302 : 'Incorrect version number' , - 303 : 'Fail to get the protocol type' , - 304 : 'Invalid SOCKET' , - 305 : 'SOCKET error' , - 306 : 'HOST error' , - 307 : 'Connection attempt failed' , }) #: SDK functions can also return WINSOCK errors using `PullLastError` #: function. See SDK docs and MSDN WSA_ERROR_CODES = DocDict ({ 6 : \"WSA_INVALID_HANDLE (Specified event object handle is invalid. An application attempts to \" \"use an event object, but the specified handle is not valid)\" , 8 : \"WSA_NOT_ENOUGH_MEMORY (Insufficient memory available. An application used a Windows \" \"Sockets function that directly maps to a Windows function. The Windows function is \" \"indicating a lack of required memory resources)\" , 87 : \"WSA_INVALID_PARAMETER (One or more parameters are invalid. An application used a Windows \" \"Sockets function which directly maps to a Windows function. The Windows function is \" \"indicating a problem with one or more parameters)\" , 995 : \"WSA_OPERATION_ABORTED (Overlapped operation aborted. An overlapped operation was \" \"canceled due to the closure of the socket, or the execution of the SIO_FLUSH command \" \"in WSAIoctl)\" , 996 : \"WSA_IO_INCOMPLETE (Overlapped I/O event object not in signaled state. The application \" \"has tried to determine the status of an overlapped operation which is not yet completed. \" \"Applications that use WSAGetOverlappedResult (with the fWait flag set to FALSE) in a \" \"polling mode to determine when an overlapped operation has completed, get this error \" \"code until the operation is complete)\" , 997 : \"WSA_IO_PENDING (Overlapped operations will complete later. The application has \" \"initiated an overlapped operation that cannot be completed immediately. A completion \" \"indication will be given later when the operation has been completed)\" , 10004 : \"WSAEINTR (Interrupted function call. A blocking operation was interrupted by a call \" \"to WSACancelBlockingCall)\" , 10009 : \"WSAEBADF (File handle is not valid. The file handle supplied is not valid)\" , 10013 : \"WSAEACCES (Permission denied. An attempt was made to access a socket in a way \" \"forbidden by its access permissions. An example is using a broadcast address for \" \"sendto without broadcast permission being set using setsockopt(SO_BROADCAST). \" \"Another possible reason for the WSAEACCES error is that when the bind function \" \"is called (on Windows NT 4.0 with SP4 and later), another application, service, \" \"or kernel mode driver is bound to the same address with exclusive access. Such \" \"exclusive access is a new feature of Windows NT 4.0 with SP4 and later, and is \" \"implemented by using the SO_EXCLUSIVEADDRUSE option)\" , 10014 : \"WSAEFAULT (Bad address. The system detected an invalid pointer address in \" \"attempting to use a pointer argument of a call. This error occurs if an application \" \"passes an invalid pointer value, or if the length of the buffer is too small. \" \"For instance, if the length of an argument, which is a sockaddr structure, is \" \"smaller than the sizeof(sockaddr))\" , 10022 : \"WSAEINVAL (Invalid argument. Some invalid argument was supplied (for example, \" \"specifying an invalid level to the setsockopt function). In some instances, it \" \"also refers to the current state of the socket\u2014for instance, calling accept on \" \"a socket that is not listening)\" , 10024 : \"WSAEMFILE (Too many open files. Too many open sockets. Each implementation may \" \"have a maximum number of socket handles available, either globally, per process, \" \"or per thread)\" , 10035 : \"WSAEWOULDBLOCK (Resource temporarily unavailable. This error is returned from \" \"operations on nonblocking sockets that cannot be completed immediately, for \" \"example recv when no data is queued to be read from the socket. It is a nonfatal \" \"error, and the operation should be retried later. It is normal for WSAEWOULDBLOCK \" \"to be reported as the result from calling connect on a nonblocking SOCK_STREAM \" \"socket, since some time must elapse for the connection to be established)\" , 10036 : \"WSAEINPROGRESS (Operation now in progress. A blocking operation is currently \" \"executing. Windows Sockets only allows a single blocking operation\u2014per- task or \" \"thread\u2014to be outstanding, and if any other function call is made (whether or \" \"not it references that or any other socket) the function fails with the \" \"WSAEINPROGRESS error)\" , 10037 : \"WSAEALREADY (Operation already in progress. An operation was attempted on a \" \"nonblocking socket with an operation already in progress\u2014that is, calling connect \" \"a second time on a nonblocking socket that is already connecting, or canceling \" \"an asynchronous request (WSAAsyncGetXbyY) that has already been canceled or \" \"completed)\" , 10038 : \"WSAENOTSOCK (Socket operation on nonsocket. An operation was attempted on \" \"something that is not a socket. Either the socket handle parameter did not \" \"reference a valid socket, or for select, a member of an fd_set was not valid)\" , 10039 : \"WSAEDESTADDRREQ (Destination address required. A required address was omitted \" \"from an operation on a socket. For example, this error is returned if sendto \" \"is called with the remote address of ADDR_ANY)\" , 10040 : \"WSAEMSGSIZE (Message too long. A message sent on a datagram socket was larger \" \"than the internal message buffer or some other network limit, or the buffer used \" \"to receive a datagram was smaller than the datagram itself)\" , 10041 : \"WSAEPROTOTYPE (Protocol wrong type for socket. A protocol was specified in the \" \"socket function call that does not support the semantics of the socket type \" \"requested. For example, the ARPA Internet UDP protocol cannot be specified with \" \"a socket type of SOCK_STREAM)\" , 10042 : \"WSAENOPROTOOPT (Bad protocol option. An unknown, invalid or unsupported option \" \"or level was specified in a getsockopt or setsockopt call)\" , 10043 : \"WSAEPROTONOSUPPORT (Protocol not supported. The requested protocol has not been \" \"configured into the system, or no implementation for it exists. For example, a \" \"socket call requests a SOCK_DGRAM socket, but specifies a stream protocol)\" , 10044 : \"WSAESOCKTNOSUPPORT (Socket type not supported. The support for the specified \" \"socket type does not exist in this address family. For example, the optional \" \"type SOCK_RAW might be selected in a socket call, and the implementation does \" \"not support SOCK_RAW sockets at all)\" , 10045 : \"WSAEOPNOTSUPP (Operation not supported. The attempted operation is not supported \" \"for the type of object referenced. Usually this occurs when a socket descriptor \" \"to a socket that cannot support this operation is trying to accept a connection \" \"on a datagram socket)\" , 10046 : \"WSAEPFNOSUPPORT (Protocol family not supported. The protocol family has not been \" \"configured into the system or no implementation for it exists. This message has \" \"a slightly different meaning from WSAEAFNOSUPPORT. However, it is interchangeable \" \"in most cases, and all Windows Sockets functions that return one of these messages \" \"also specify WSAEAFNOSUPPORT)\" , 10047 : \"WSAEAFNOSUPPORT (Address family not supported by protocol family. An address \" \"incompatible with the requested protocol was used. All sockets are created with \" \"an associated address family (that is, AF_INET for Internet Protocols) and a \" \"generic protocol type (that is, SOCK_STREAM). This error is returned if an \" \"incorrect protocol is explicitly requested in the socket call, or if an address \" \"of the wrong family is used for a socket, for example, in sendto)\" , 10048 : \"WSAEADDRINUSE (Address already in use. Typically, only one usage of each socket \" \"address (protocol/IP address/port) is permitted. This error occurs if an \" \"application attempts to bind a socket to an IP address/port that has already \" \"been used for an existing socket, or a socket that was not closed properly, or \" \"one that is still in the process of closing. For server applications that need \" \"to bind multiple sockets to the same port number, consider using setsockopt \" \"(SO_REUSEADDR). Client applications usually need not call bind at all\u2014connect \" \"chooses an unused port automatically. When bind is called with a wildcard address \" \"(involving ADDR_ANY), a WSAEADDRINUSE error could be delayed until the specific \" \"address is committed. This could happen with a call to another function later, \" \"including connect, listen, WSAConnect, or WSAJoinLeaf)\" , 10049 : \"WSAEADDRNOTAVAIL (Cannot assign requested address. The requested address is not \" \"valid in its context. This normally results from an attempt to bind to an address \" \"that is not valid for the local computer. This can also result from connect, \" \"sendto, WSAConnect, WSAJoinLeaf, or WSASendTo when the remote address or port \" \"is not valid for a remote computer (for example, address or port 0))\" , 10050 : \"WSAENETDOWN (Network is down. A socket operation encountered a dead network. \" \"This could indicate a serious failure of the network system (that is, the \" \"protocol stack that the Windows Sockets DLL runs over), the network interface, \" \"or the local network itself)\" , 10051 : \"WSAENETUNREACH (Network is unreachable. A socket operation was attempted to \" \"an unreachable network. This usually means the local software knows no route \" \"to reach the remote host)\" , 10052 : \"WSAENETRESET (Network dropped connection on reset. The connection has been \" \"broken due to keep-alive activity detecting a failure while the operation was \" \"in progress. It can also be returned by setsockopt if an attempt is made to set \" \"SO_KEEPALIVE on a connection that has already failed)\" , 10053 : \"WSAECONNABORTED (Software caused connection abort. An established connection was \" \"aborted by the software in your host computer, possibly due to a data transmission \" \"time-out or protocol error)\" , 10054 : \"WSAECONNRESET (Connection reset by peer. An existing connection was forcibly \" \"closed by the remote host. This normally results if the peer application on the \" \"remote host is suddenly stopped, the host is rebooted, the host or remote network \" \"interface is disabled, or the remote host uses a hard close (see setsockopt for \" \"more information on the SO_LINGER option on the remote socket). This error may \" \"also result if a connection was broken due to keep-alive activity detecting a \" \"failure while one or more operations are in progress. Operations that were in \" \"progress fail with WSAENETRESET. Subsequent operations fail with WSAECONNRESET)\" , 10055 : \"WSAENOBUFS (No buffer space available. An operation on a socket could not be \" \"performed because the system lacked sufficient buffer space or because a queue \" \"was full)\" , 10056 : \"WSAEISCONN (Socket is already connected. A connect request was made on an \" \"already-connected socket. Some implementations also return this error if \" \"sendto is called on a connected SOCK_DGRAM socket (for SOCK_STREAM sockets, the \" \"to parameter in sendto is ignored) although other implementations treat this as \" \"a legal occurrence)\" , 10057 : \"WSAENOTCONN (Socket is not connected. A request to send or receive data was \" \"disallowed because the socket is not connected and (when sending on a datagram \" \"socket using sendto) no address was supplied. Any other type of operation might \" \"also return this error\u2014for example, setsockopt setting SO_KEEPALIVE if the \" \"connection has been reset)\" , 10058 : \"WSAESHUTDOWN (Cannot send after socket shutdown. A request to send or receive \" \"data was disallowed because the socket had already been shut down in that \" \"direction with a previous shutdown call. By calling shutdown a partial close \" \"of a socket is requested, which is a signal that sending or receiving, or both \" \"have been discontinued)\" , 10059 : \"WSAETOOMANYREFS (Too many references. Too many references to some kernel object)\" , 10060 : \"WSAETIMEDOUT (Connection timed out. A connection attempt failed because the \" \"connected party did not properly respond after a period of time, or the \" \"established connection failed because the connected host has failed to respond)\" , 10061 : \"WSAECONNREFUSED (Connection refused. No connection could be made because the \" \"target computer actively refused it. This usually results from trying to \" \"connect to a service that is inactive on the foreign host\u2014that is, one with \" \"no server application running)\" , 10062 : \"WSAELOOP (Cannot translate name. Cannot translate a name)\" , 10063 : \"WSAENAMETOOLONG (Name too long. A name component or a name was too long)\" , 10064 : \"WSAEHOSTDOWN (Host is down. A socket operation failed because the destination \" \"host is down. A socket operation encountered a dead host. Networking activity \" \"on the local host has not been initiated. These conditions are more likely to be \" \"indicated by the error WSAETIMEDOUT)\" , 10065 : \"WSAEHOSTUNREACH (No route to host. A socket operation was attempted to an \" \"unreachable host. See WSAENETUNREACH)\" , 10066 : \"WSAENOTEMPTY (Directory not empty. Cannot remove a directory that is not empty)\" , 10067 : \"WSAEPROCLIM (Too many processes. A Windows Sockets implementation may have a \" \"limit on the number of applications that can use it simultaneously. WSAStartup \" \"may fail with this error if the limit has been reached)\" , 10068 : \"WSAEUSERS (User quota exceeded. Ran out of user quota)\" , 10069 : \"WSAEDQUOT (Disk quota exceeded. Ran out of disk quota)\" , 10070 : \"WSAESTALE (Stale file handle reference. The file handle reference is no longer \" \"available)\" , 10071 : \"WSAEREMOTE (Item is remote. The item is not available locally)\" , 10091 : \"WSASYSNOTREADY (Network subsystem is unavailable. This error is returned by \" \"WSAStartup if the Windows Sockets implementation cannot function at this time \" \"because the underlying system it uses to provide network services is currently \" \"unavailable. Users should check: That the appropriate Windows Sockets DLL file \" \"is in the current path. That they are not trying to use more than one Windows \" \"Sockets implementation simultaneously. If there is more than one Winsock DLL on \" \"your system, be sure the first one in the path is appropriate for the network \" \"subsystem currently loaded. The Windows Sockets implementation documentation to \" \"be sure all necessary components are currently installed and configured correctly)\" , 10092 : \"WSAVERNOTSUPPORTED (Winsock.dll version out of range. The current Windows Sockets \" \"implementation does not support the Windows Sockets specification version \" \"requested by the application. Check that no old Windows Sockets DLL files are \" \"being accessed)\" , 10093 : \"WSANOTINITIALISED (Successful WSAStartup not yet performed. Either the application \" \"has not called WSAStartup or WSAStartup failed. The application may be accessing \" \"a socket that the current active task does not own (that is, trying to share a \" \"socket between tasks), or WSACleanup has been called too many times)\" , 10101 : \"WSAEDISCON (Graceful shutdown in progress. Returned by WSARecv and WSARecvFrom \" \"to indicate that the remote party has initiated a graceful shutdown sequence)\" , 10102 : \"WSAENOMORE (No more results. No more results can be returned by the \" \"WSALookupServiceNext function)\" , 10103 : \"WSAECANCELLED (Call has been canceled. A call to the WSALookupServiceEnd function \" \"was made while this call was still processing. The call has been canceled)\" , 10104 : \"WSAEINVALIDPROCTABLE (Procedure call table is invalid. The service provider \" \"procedure call table is invalid. A service provider returned a bogus procedure \" \"table to Ws2_32.dll. This is usually caused by one or more of the function \" \"pointers being NULL)\" , 10105 : \"WSAEINVALIDPROVIDER (Service provider is invalid. The requested service provider \" \"is invalid. This error is returned by the WSCGetProviderInfo and \" \"WSCGetProviderInfo32 functions if the protocol entry specified could not be found. \" \"This error is also returned if the service provider returned a version number \" \"other than 2.0)\" , 10106 : \"WSAEPROVIDERFAILEDINIT (Service provider failed to initialize. The requested \" \"service provider could not be loaded or initialized. This error is returned if \" \"either a service provider's DLL could not be loaded (LoadLibrary failed) or the \" \"provider's WSPStartup or NSPStartup function failed)\" , 10107 : \"WSASYSCALLFAILURE (System call failure. A system call that should never fail has \" \"failed. This is a generic error code, returned under various conditions. Returned \" \"when a system call that should never fail does fail. For example, if a call to \" \"WaitForMultipleEvents fails or one of the registry functions fails trying to \" \"manipulate the protocol/namespace catalogs. Returned when a provider does not \" \"return SUCCESS and does not provide an extended error code. Can indicate a \" \"service provider implementation error)\" , 10108 : \"WSASERVICE_NOT_FOUND (Service not found. No such service is known. The service \" \"cannot be found in the specified name space)\" , 10109 : \"WSATYPE_NOT_FOUND (Class type not found. The specified class was not found)\" , 10110 : \"WSA_E_NO_MORE (No more results. No more results can be returned by the \" \"WSALookupServiceNext function)\" , 10111 : \"WSA_E_CANCELLED (Call was canceled. A call to the WSALookupServiceEnd function \" \"was made while this call was still processing. The call has been canceled)\" , 10112 : \"WSAEREFUSED (Database query was refused. A database query failed because it \" \"was actively refused)\" , 11001 : \"WSAHOST_NOT_FOUND (Host not found. No such host is known. The name is not an \" \"official host name or alias, or it cannot be found in the database(s) being \" \"queried. This error may also be returned for protocol and service queries, and \" \"means that the specified name could not be found in the relevant database)\" , 11002 : \"WSATRY_AGAIN (Nonauthoritative host not found. This is usually a temporary error \" \"during host name resolution and means that the local server did not receive a \" \"response from an authoritative server. A retry at some time later may be successful)\" , 11003 : \"WSANO_RECOVERY (This is a nonrecoverable error. This indicates that some sort \" \"of nonrecoverable error occurred during a database lookup. This may be because \" \"the database files (for example, BSD-compatible HOSTS, SERVICES, or PROTOCOLS \" \"files) could not be found, or a DNS request was returned by the server with a \" \"severe error)\" , 11004 : \"WSANO_DATA (Valid name, no data record of requested type. The requested name is \" \"valid and was found in the database, but it does not have the correct associated \" \"data being resolved for. The usual example for this is a host name-to-address \" \"translation attempt (using gethostbyname or WSAAsyncGetHostByName) which uses \" \"the DNS (Domain Name Server). An MX record is returned but no A record\u2014indicating \" \"the host itself exists, but is not directly reachable)\" , 11005 : \"WSA_QOS_RECEIVERS (QoS receivers. At least one QoS reserve has arrived)\" , 11006 : \"WSA_QOS_SENDERS (QoS senders. At least one QoS send path has arrived)\" , 11007 : \"WSA_QOS_NO_SENDERS (No QoS senders. There are no QoS senders)\" , 11008 : \"WSA_QOS_NO_RECEIVERS (QoS no receivers. There are no QoS receivers)\" , 11009 : \"WSA_QOS_REQUEST_CONFIRMED (QoS request confirmed. The QoS reserve request has \" \"been confirmed)\" , 11010 : \"WSA_QOS_ADMISSION_FAILURE (QoS admission error. A QoS error occurred due to lack \" \"of resources)\" , 11011 : \"WSA_QOS_POLICY_FAILURE (QoS policy failure. The QoS request was rejected because \" \"the policy system couldn't allocate the requested resource within the existing \" \"policy)\" , 11012 : \"WSA_QOS_BAD_STYLE (QoS bad style. An unknown or conflicting QoS style was \" \"encountered)\" , 11013 : \"WSA_QOS_BAD_OBJECT (QoS bad object. A problem was encountered with some part \" \"of the filterspec or the provider-specific buffer in general)\" , 11014 : \"WSA_QOS_TRAFFIC_CTRL_ERROR (QoS traffic control error. An error with the \" \"underlying traffic control (TC) API as the generic QoS request was converted \" \"for local enforcement by the TC API. This could be due to an out of memory \" \"error or to an internal QoS provider error)\" , 11015 : \"WSA_QOS_GENERIC_ERROR (QoS generic error. A general QoS error)\" , 11016 : \"WSA_QOS_ESERVICETYPE (QoS service type error. An invalid or unrecognized service \" \"type was found in the QoS flowspec)\" , 11017 : \"WSA_QOS_EFLOWSPEC (QoS flowspec error. An invalid or inconsistent flowspec was \" \"found in the QOS structure)\" , 11018 : \"WSA_QOS_EPROVSPECBUF (Invalid QoS provider buffer. An invalid QoS provider-specific \" \"buffer)\" , 11019 : \"WSA_QOS_EFILTERSTYLE (Invalid QoS filter style. An invalid QoS filter style was used)\" , 11020 : \"WSA_QOS_EFILTERTYPE (Invalid QoS filter type. An invalid QoS filter type was used)\" , 11021 : \"WSA_QOS_EFILTERCOUNT (Incorrect QoS filter count. An incorrect number of QoS \" \"FILTERSPECs were specified in the FLOWDESCRIPTOR)\" , 11022 : \"WSA_QOS_EOBJLENGTH (Invalid QoS object length. An object with an invalid \" \"ObjectLength field was specified in the QoS provider-specific buffer)\" , 11023 : \"WSA_QOS_EFLOWCOUNT (Incorrect QoS flow count. An incorrect number of flow \" \"descriptors was specified in the QoS structure)\" , 11024 : \"WSA_QOS_EUNKOWNPSOBJ (Unrecognized QoS object. An unrecognized object was found \" \"in the QoS provider-specific buffer)\" , 11025 : \"WSA_QOS_EPOLICYOBJ (Invalid QoS policy object. An invalid policy object was found \" \"in the QoS provider-specific buffer)\" , 11026 : \"WSA_QOS_EFLOWDESC (Invalid QoS flow descriptor. An invalid QoS flow descriptor was \" \"found in the flow descriptor list)\" , 11027 : \"WSA_QOS_EPSFLOWSPEC (Invalid QoS provider-specific flowspec. An invalid or \" \"inconsistent flowspec was found in the QoS provider-specific buffer)\" , 11028 : \"WSA_QOS_EPSFILTERSPEC (Invalid QoS provider-specific filterspec. An invalid \" \"FILTERSPEC was found in the QoS provider-specific buffer)\" , 11029 : \"WSA_QOS_ESDMODEOBJ (Invalid QoS shape discard mode object. An invalid shape discard \" \"mode object was found in the QoS provider-specific buffer)\" , 11030 : \"WSA_QOS_ESHAPERATEOBJ (Invalid QoS shaping rate object. An invalid shaping rate \" \"object was found in the QoS provider-specific buffer)\" , 11031 : \"WSA_QOS_RESERVED_PETYPE (Reserved policy QoS element type. A reserved policy \" \"element was found in the QoS provider-specific buffer)\" , })","title":"Module pyzkaccess.enum"},{"location":"reference/pyzkaccess/enum/#variables","text":"EVENT_TYPES PULL_SDK_ERRORS WSA_ERROR_CODES","title":"Variables"},{"location":"reference/pyzkaccess/enum/#classes","text":"","title":"Classes"},{"location":"reference/pyzkaccess/enum/#controloperation","text":"class ControlOperation ( / , * args , ** kwargs ) Device control operation. See ControlOperation SDK func docs View Source class ControlOperation ( Enum ): \"\"\"Device control operation. See `ControlOperation` SDK func docs\"\"\" output = 1 cancel_alarm = 2 restart = 3","title":"ControlOperation"},{"location":"reference/pyzkaccess/enum/#ancestors-in-mro","text":"enum.Enum","title":"Ancestors (in MRO)"},{"location":"reference/pyzkaccess/enum/#class-variables","text":"cancel_alarm name output restart value","title":"Class variables"},{"location":"reference/pyzkaccess/enum/#passagedirection","text":"class PassageDirection ( / , * args , ** kwargs ) Whether a user was entered or exited via door See event format description in SDK docs View Source class PassageDirection ( Enum ): \"\"\"Whether a user was entered or exited via door See event format description in SDK docs \"\"\" entry = 0 exit = 1 none = 2","title":"PassageDirection"},{"location":"reference/pyzkaccess/enum/#ancestors-in-mro_1","text":"enum.Enum","title":"Ancestors (in MRO)"},{"location":"reference/pyzkaccess/enum/#class-variables_1","text":"entry exit name none value","title":"Class variables"},{"location":"reference/pyzkaccess/enum/#relaygroup","text":"class RelayGroup ( / , * args , ** kwargs ) Device relay group. There are either lock relays (door output) or aux relays (aux output) View Source class RelayGroup ( Enum ): \"\"\"Device relay group. There are either lock relays (door output) or aux relays (aux output) \"\"\" lock = 1 aux = 2","title":"RelayGroup"},{"location":"reference/pyzkaccess/enum/#ancestors-in-mro_2","text":"enum.Enum","title":"Ancestors (in MRO)"},{"location":"reference/pyzkaccess/enum/#class-variables_2","text":"aux lock name value","title":"Class variables"},{"location":"reference/pyzkaccess/enum/#sensortype","text":"class SensorType ( / , * args , ** kwargs ) Sensor type of door. See DoorXSensorType parameter in SDK docs View Source class SensorType ( Enum ): \"\"\"Sensor type of door. See DoorXSensorType parameter in SDK docs\"\"\" not_available = 0 normal_open = 1 normal_closed = 2","title":"SensorType"},{"location":"reference/pyzkaccess/enum/#ancestors-in-mro_3","text":"enum.Enum","title":"Ancestors (in MRO)"},{"location":"reference/pyzkaccess/enum/#class-variables_3","text":"name normal_closed normal_open not_available value","title":"Class variables"},{"location":"reference/pyzkaccess/enum/#verifymode","text":"class VerifyMode ( / , * args , ** kwargs ) Which methods are used to authenticate user. See DoorXVerifyType parameter in SDK docs View Source class VerifyMode ( Enum ): \"\"\"Which methods are used to authenticate user. See `DoorXVerifyType` parameter in SDK docs \"\"\" not_available = 0 only_finger = 1 only_password = 3 only_card = 4 card_or_finger = 6 card_and_finger = 10 card_and_password = 11 others = 200","title":"VerifyMode"},{"location":"reference/pyzkaccess/enum/#ancestors-in-mro_4","text":"enum.Enum","title":"Ancestors (in MRO)"},{"location":"reference/pyzkaccess/enum/#class-variables_4","text":"card_and_finger card_and_password card_or_finger name not_available only_card only_finger only_password others value","title":"Class variables"},{"location":"reference/pyzkaccess/event/","text":"Module pyzkaccess.event View Source __ all__ = [ 'Event' , 'EventLog' ] import itertools import time from collections import deque from copy import deepcopy from datetime import datetime from typing import Optional , List , Iterable , Union , Sequence from . common import DocValue from . enum import VerifyMode , PassageDirection , EVENT_TYPES from . sdk import ZKSDK class Event : \"\"\" One realtime event occured on the device Since the device returns event as string we need to parse it to the structured view. This class does this. \"\"\" __ slots__ = ( 'time' , 'pin' , 'card' , 'door' , 'event_type' , 'entry_exit' , 'verify_mode' ) def __ init__ ( self , s ) : \"\"\" :param s: Event string to be parsed. \"\"\" parsed = self . parse ( s ) self . time = datetime . strptime ( parsed [ 0 ], '%Y-%m-%d %H:%M:%S' ) # type : datetime self . pin = parsed [ 1 ] # type : str self . card = parsed [ 2 ] # type : str self . door = int ( parsed [ 3 ]) # type : int self . event_type = EVENT_TYPES [ int ( parsed [ 4 ])] # type : DocValue self . entry_exit = PassageDirection ( int ( parsed [ 5 ])) # type : PassageDirection self . verify_mode = VerifyMode ( int ( parsed [ 6 ])) # type : VerifyMode @property def description ( self ) -> str : msg = 'Event[{}]: \"{}\" at door \"{}\" for card \"{}\" -- {}' . format ( str ( self . time ), self . event_type . doc , self . door , self . card , self . entry_exit . name . capitalize () ) return msg @staticmethod def parse ( event_line: str ) -> Sequence [ str ] : \"\"\" Parse raw event string :param event_line: event string :return: parsed string parts of event string \"\"\" event_line = event_line . replace ( '\\r\\n' , '' ) items = event_line . split ( ',' ) if len ( items ) ! = 7 : raise ValueError ( \"Event string must have exactly 7 parts: {}\" . format ( event_line )) return items def __ eq__ ( self , other ) : if isinstance ( other , Event ) : return all ( getattr ( self , attr ) == getattr ( other , attr ) for attr in self . __ slots__ ) return False def __ ne__ ( self , other ) : return not self . __ eq__ ( other ) def __ str__ ( self ) : return 'Event(' \\ + ', ' . join ( '{}={}' . format ( k , getattr ( self , k )) for k in self . __ slots__ ) \\ + ')' def __ repr__ ( self ) : return self . __ str__ () class EventLog : \"\"\"Log of realtime events Keep in mind that log is not filled out automatically and should be refreshed periodically by hand using `refresh()` method. This is because working with ZKAccess has request-response nature and cannot up a tunnel which may be used to feed events. But you can use `poll()` method which awaits new events from a device and return them if any. Log is implemented at top of deque structure, so accessing by index and filtering could be slow. \"\"\" def __ init__ ( self , sdk : ZKSDK , buffer_size: int , maxlen : Optional [ int ] = None , only_filters: Optional [ dict ] = None , _ data : Optional [ deque ] = None ) : self . buffer_size = buffer_size self . data = _ data if _ data is not None else deque ( maxlen = maxlen ) self . only_filters = only_filters or {} self . _ sdk = sdk def refresh ( self ) -> int : \"\"\"Make a request to a device for new records and append to the end if any. :return: count of records which was added \"\"\" # ZKAccess always returns single event with code 255 # on every log query if no other events occured . So , skip it new_events = [ e for e in self . _ pull_events () if e . event_type ! = 255 ] count = 0 while new_events: self . data . extend ( new_events ) count += sum ( 1 for _ in self . _ filtered_events ( new_events )) new_events = [ e for e in self . _ pull_events () if e . event_type ! = 255 ] return count def after_time ( self , after_time: datetime ) -> Iterable [ Event ] : \"\"\" Return events which was occured after given time :param after_time: datetime object to filter (included) :return: \"\"\" return filter ( lambda x : x . time >= after_time , self . _ filtered_events ( self . data )) def before_time ( self , before_time: datetime ) -> Iterable [ Event ] : \"\"\" Return events which was occured before given time :param before_time: datetime object to filter (excluded) :return: \"\"\" return filter ( lambda x : x . time < before_time , self . _ filtered_events ( self . data )) def between_time ( self , from_time: datetime , to_time: datetime ) -> Iterable [ Event ] : \"\"\" Return events which was occured between two given time moments :param from_time: datetime object to filter (included) :param to_time: datetime object to filter (excluded) :return: \"\"\" return filter ( lambda x : from_time <= x . time < to_time , self . _ filtered_events ( self . data )) def poll ( self , timeout : float = 60 , polling_interval: float = 1 ) -> List [ Event ] : \"\"\" Wait for new events by making periodically requests to a device. If events was appeared then return them. If no event was appeared until timeout was expired then return empty iterable. :param timeout: timeout in seconds. Default: 60 seconds :param polling_interval: interval to make a requests in seconds. Default: every 1 second :return: iterable with new events if any or empty iterable if timeout has expired \"\"\" deadline = datetime . now (). timestamp () + timeout while datetime . now (). timestamp () < deadline : count = self . refresh () # Can run up to several seconds depending on network if count : reversed_events = self . _ filtered_events ( reversed ( self . data )) res = list ( itertools . islice ( reversed_events , None , count ))[ ::- 1 ] return res time . sleep ( polling_interval ) return [] def only ( self , **filters ) -> 'EventLog': \"\"\" Return new EventLog instance with given filters applied. Kwargs names must be the same as Event slots. Event log returned by this method will contain entries in which attribute value is contained in appropriate filter (if any). Filters passed here will be ANDed during comparison. On repeatable call of only, given filters which was also set on previous call will be ORed, i.e. their values will be concatenated. In other words: ```log.only(a=2, b=['x', 'y'])` => filtering(entry.a == 2 AND entry.b in ('x', 'y'))``` ```log.only(a=2, b=['x', 'y']).only(a=3, b=5, c=1) => filtering(entry.a in (2, 3) AND entry.b in ('x', 'y', 5) and entry.c == 1)``` Ex: `new_log = log.only(door=1, event_type=221)` :param filters: :return: new fitlered EventLog instance \"\"\" only_filters = self . _ merge_filters ( self . only_filters , filters ) obj = self . __ class__ ( self . _ sdk , self . buffer_size , self . data . maxlen , only_filters , _ data = self . data ) return obj def clear ( self ) -> None : \"\"\"Clear log\"\"\" self . data . clear () @staticmethod def _ merge_filters ( initial : dict , fltr : dict ) -> dict : \"\"\" Merge two filter dicts, fltr updates initial. Key-values which does not exist in initial will be copied. Value of existent keys are combined (values always are lists). :param initial: updating initial filter dict :param fltr: filter dict which updates initial :return: merged filter dict \"\"\" seq_types = ( tuple , list , set , frozenset ) res = deepcopy ( initial ) for key , value in fltr . items () : if not isinstance ( value , seq_types ) : value = { value } if key in res : res [ key ]. update ( value ) else : res [ key ] = set ( value ) return res def _ filtered_events ( self , data : Iterable [ Event ]) -> Iterable [ Event ] : \"\"\" Apply current filters to given events and return only events which meet them :param data: unfiltered events :return: filtered events \"\"\" if not self . only_filters: yield from data return for event in data : if not self . only_filters: yield event else : all_match = all ( getattr ( event , field ) in fltr for field , fltr in self . only_filters . items ()) if all_match: yield event def _ pull_events ( self ) -> Iterable [ Event ] : events = self . _ sdk . get_rt_log ( self . buffer_size ) return ( Event ( s ) for s in events ) def __ getitem__ ( self , item : Union [ int , slice ]) -> Union [ Iterable [ Event ], Event ] : seq = self . _ filtered_events ( self . data ) if not isinstance ( item , slice ) : try : return next ( itertools . islice ( seq , item , None )) except StopIteration : raise IndexError ( 'Index is out of range' ) from None start , stop , step = item . start , item . stop , item . step return itertools . islice ( seq , start , stop , step ) def __ len__ ( self ) -> int : if not self . only_filters: return len ( self . data ) return sum ( 1 for _ in self . _ filtered_events ( self . data )) def __ iter__ ( self ) : return iter ( self . _ filtered_events ( self . data )) def __ str__ ( self ) : items_str = ', ' . join ( str ( x ) for x in self [ : 3 ]) if len ( self ) > 6 : items_str += ', ..., ' + ', ' . join ( str ( x ) for x in self [ 3 : ]) return 'EventLog[{}]({})' . format ( len ( self ), items_str ) def __ repr__ ( self ) : return self . __ str__ () Classes Event class Event ( s ) One realtime event occured on the device Since the device returns event as string we need to parse it to the structured view. This class does this. View Source class Event : \"\"\" One realtime event occured on the device Since the device returns event as string we need to parse it to the structured view. This class does this. \"\"\" __slots__ = ( 'time' , 'pin' , 'card' , 'door' , 'event_type' , 'entry_exit' , 'verify_mode' ) def __init__ ( self , s ) : \"\"\" :param s: Event string to be parsed. \"\"\" parsed = self . parse ( s ) self . time = datetime . strptime ( parsed [ 0 ] , '%Y-%m-%d %H:%M:%S' ) # type : datetime self . pin = parsed [ 1 ] # type : str self . card = parsed [ 2 ] # type : str self . door = int ( parsed [ 3 ] ) # type : int self . event_type = EVENT_TYPES [ int(parsed[4 ] ) ] # type : DocValue self . entry_exit = PassageDirection ( int ( parsed [ 5 ] )) # type : PassageDirection self . verify_mode = VerifyMode ( int ( parsed [ 6 ] )) # type : VerifyMode @property def description ( self ) -> str : msg = 'Event[{}]: \"{}\" at door \"{}\" for card \"{}\" -- {}' . format ( str ( self . time ), self . event_type . doc , self . door , self . card , self . entry_exit . name . capitalize () ) return msg @staticmethod def parse ( event_line : str ) -> Sequence [ str ] : \"\"\" Parse raw event string :param event_line: event string :return: parsed string parts of event string \"\"\" event_line = event_line . replace ( '\\r\\n' , '' ) items = event_line . split ( ',' ) if len ( items ) != 7 : raise ValueError ( \"Event string must have exactly 7 parts: {}\" . format ( event_line )) return items def __eq__ ( self , other ) : if isinstance ( other , Event ) : return all ( getattr ( self , attr ) == getattr ( other , attr ) for attr in self . __slots__ ) return False def __ne__ ( self , other ) : return not self . __eq__ ( other ) def __str__ ( self ) : return 'Event(' \\ + ', ' . join ( '{}={}' . format ( k , getattr ( self , k )) for k in self . __slots__ ) \\ + ')' def __repr__ ( self ) : return self . __str__ () Static methods parse def parse ( event_line : str ) -> Sequence [ str ] Parse raw event string :param event_line: event string :return: parsed string parts of event string View Source @staticmethod def parse ( event_line : str ) -> Sequence [ str ] : \"\"\" Parse raw event string :param event_line: event string :return: parsed string parts of event string \"\"\" event_line = event_line . replace ( '\\r\\n' , '' ) items = event_line . split ( ',' ) if len ( items ) != 7 : raise ValueError ( \"Event string must have exactly 7 parts: {}\" . format ( event_line )) return items Instance variables card description door entry_exit event_type pin time verify_mode EventLog class EventLog ( sdk : pyzkaccess . sdk . ZKSDK , buffer_size : int , maxlen : Union [ int , NoneType ] = None , only_filters : Union [ dict , NoneType ] = None , _data : Union [ collections . deque , NoneType ] = None ) Log of realtime events Keep in mind that log is not filled out automatically and should be refreshed periodically by hand using refresh() method. This is because working with ZKAccess has request-response nature and cannot up a tunnel which may be used to feed events. But you can use poll() method which awaits new events from a device and return them if any. Log is implemented at top of deque structure, so accessing by index and filtering could be slow. View Source class EventLog : \"\"\"Log of realtime events Keep in mind that log is not filled out automatically and should be refreshed periodically by hand using `refresh()` method. This is because working with ZKAccess has request-response nature and cannot up a tunnel which may be used to feed events. But you can use `poll()` method which awaits new events from a device and return them if any. Log is implemented at top of deque structure, so accessing by index and filtering could be slow. \"\"\" def __ init__ ( self , sdk : ZKSDK , buffer_size: int , maxlen : Optional [ int ] = None , only_filters: Optional [ dict ] = None , _ data : Optional [ deque ] = None ) : self . buffer_size = buffer_size self . data = _ data if _ data is not None else deque ( maxlen = maxlen ) self . only_filters = only_filters or {} self . _ sdk = sdk def refresh ( self ) -> int : \"\"\"Make a request to a device for new records and append to the end if any. :return: count of records which was added \"\"\" # ZKAccess always returns single event with code 255 # on every log query if no other events occured . So , skip it new_events = [ e for e in self . _ pull_events () if e . event_type ! = 255 ] count = 0 while new_events: self . data . extend ( new_events ) count += sum ( 1 for _ in self . _ filtered_events ( new_events )) new_events = [ e for e in self . _ pull_events () if e . event_type ! = 255 ] return count def after_time ( self , after_time: datetime ) -> Iterable [ Event ] : \"\"\" Return events which was occured after given time :param after_time: datetime object to filter (included) :return: \"\"\" return filter ( lambda x : x . time >= after_time , self . _ filtered_events ( self . data )) def before_time ( self , before_time: datetime ) -> Iterable [ Event ] : \"\"\" Return events which was occured before given time :param before_time: datetime object to filter (excluded) :return: \"\"\" return filter ( lambda x : x . time < before_time , self . _ filtered_events ( self . data )) def between_time ( self , from_time: datetime , to_time: datetime ) -> Iterable [ Event ] : \"\"\" Return events which was occured between two given time moments :param from_time: datetime object to filter (included) :param to_time: datetime object to filter (excluded) :return: \"\"\" return filter ( lambda x : from_time <= x . time < to_time , self . _ filtered_events ( self . data )) def poll ( self , timeout : float = 60 , polling_interval: float = 1 ) -> List [ Event ] : \"\"\" Wait for new events by making periodically requests to a device. If events was appeared then return them. If no event was appeared until timeout was expired then return empty iterable. :param timeout: timeout in seconds. Default: 60 seconds :param polling_interval: interval to make a requests in seconds. Default: every 1 second :return: iterable with new events if any or empty iterable if timeout has expired \"\"\" deadline = datetime . now (). timestamp () + timeout while datetime . now (). timestamp () < deadline : count = self . refresh () # Can run up to several seconds depending on network if count : reversed_events = self . _ filtered_events ( reversed ( self . data )) res = list ( itertools . islice ( reversed_events , None , count ))[ ::- 1 ] return res time . sleep ( polling_interval ) return [] def only ( self , **filters ) -> 'EventLog': \"\"\" Return new EventLog instance with given filters applied. Kwargs names must be the same as Event slots. Event log returned by this method will contain entries in which attribute value is contained in appropriate filter (if any). Filters passed here will be ANDed during comparison. On repeatable call of only, given filters which was also set on previous call will be ORed, i.e. their values will be concatenated. In other words: ```log.only(a=2, b=['x', 'y'])` => filtering(entry.a == 2 AND entry.b in ('x', 'y'))``` ```log.only(a=2, b=['x', 'y']).only(a=3, b=5, c=1) => filtering(entry.a in (2, 3) AND entry.b in ('x', 'y', 5) and entry.c == 1)``` Ex: `new_log = log.only(door=1, event_type=221)` :param filters: :return: new fitlered EventLog instance \"\"\" only_filters = self . _ merge_filters ( self . only_filters , filters ) obj = self . __ class__ ( self . _ sdk , self . buffer_size , self . data . maxlen , only_filters , _ data = self . data ) return obj def clear ( self ) -> None : \"\"\"Clear log\"\"\" self . data . clear () @staticmethod def _ merge_filters ( initial : dict , fltr : dict ) -> dict : \"\"\" Merge two filter dicts, fltr updates initial. Key-values which does not exist in initial will be copied. Value of existent keys are combined (values always are lists). :param initial: updating initial filter dict :param fltr: filter dict which updates initial :return: merged filter dict \"\"\" seq_types = ( tuple , list , set , frozenset ) res = deepcopy ( initial ) for key , value in fltr . items () : if not isinstance ( value , seq_types ) : value = { value } if key in res : res [ key ]. update ( value ) else : res [ key ] = set ( value ) return res def _ filtered_events ( self , data : Iterable [ Event ]) -> Iterable [ Event ] : \"\"\" Apply current filters to given events and return only events which meet them :param data: unfiltered events :return: filtered events \"\"\" if not self . only_filters: yield from data return for event in data : if not self . only_filters: yield event else : all_match = all ( getattr ( event , field ) in fltr for field , fltr in self . only_filters . items ()) if all_match: yield event def _ pull_events ( self ) -> Iterable [ Event ] : events = self . _ sdk . get_rt_log ( self . buffer_size ) return ( Event ( s ) for s in events ) def __ getitem__ ( self , item : Union [ int , slice ]) -> Union [ Iterable [ Event ], Event ] : seq = self . _ filtered_events ( self . data ) if not isinstance ( item , slice ) : try : return next ( itertools . islice ( seq , item , None )) except StopIteration : raise IndexError ( 'Index is out of range' ) from None start , stop , step = item . start , item . stop , item . step return itertools . islice ( seq , start , stop , step ) def __ len__ ( self ) -> int : if not self . only_filters: return len ( self . data ) return sum ( 1 for _ in self . _ filtered_events ( self . data )) def __ iter__ ( self ) : return iter ( self . _ filtered_events ( self . data )) def __ str__ ( self ) : items_str = ', ' . join ( str ( x ) for x in self [ : 3 ]) if len ( self ) > 6 : items_str += ', ..., ' + ', ' . join ( str ( x ) for x in self [ 3 : ]) return 'EventLog[{}]({})' . format ( len ( self ), items_str ) def __ repr__ ( self ) : return self . __ str__ () Methods after_time def after_time ( self , after_time : datetime . datetime ) -> Iterable [ pyzkaccess . event . Event ] Return events which was occured after given time :param after_time: datetime object to filter (included) :return: View Source def after_time ( self , after_time : datetime ) -> Iterable [ Event ] : \"\"\" Return events which was occured after given time :param after_time: datetime object to filter (included) :return: \"\"\" return filter ( lambda x : x . time >= after_time , self . _filtered_events ( self . data )) before_time def before_time ( self , before_time : datetime . datetime ) -> Iterable [ pyzkaccess . event . Event ] Return events which was occured before given time :param before_time: datetime object to filter (excluded) :return: View Source def before_time ( self , before_time : datetime ) -> Iterable [ Event ] : \"\"\" Return events which was occured before given time :param before_time: datetime object to filter (excluded) :return: \"\"\" return filter ( lambda x : x . time < before_time , self . _filtered_events ( self . data )) between_time def between_time ( self , from_time : datetime . datetime , to_time : datetime . datetime ) -> Iterable [ pyzkaccess . event . Event ] Return events which was occured between two given time moments :param from_time: datetime object to filter (included) :param to_time: datetime object to filter (excluded) :return: View Source def between_time ( self , from_time : datetime , to_time : datetime ) -> Iterable [ Event ] : \"\"\" Return events which was occured between two given time moments :param from_time: datetime object to filter (included) :param to_time: datetime object to filter (excluded) :return: \"\"\" return filter ( lambda x : from_time <= x . time < to_time , self . _filtered_events ( self . data )) clear def clear ( self ) -> None Clear log View Source def clear ( self ) -> None : \"\"\"Clear log\"\"\" self . data . clear () only def only ( self , ** filters ) -> 'EventLog' Return new EventLog instance with given filters applied. Kwargs names must be the same as Event slots. Event log returned by this method will contain entries in which attribute value is contained in appropriate filter (if any). Filters passed here will be ANDed during comparison. On repeatable call of only, given filters which was also set on previous call will be ORed, i.e. their values will be concatenated. In other words: log.only(a=2, b=['x', 'y'])` => filtering(entry.a == 2 AND entry.b in ('x', 'y')) log.only(a=2, b=['x', 'y']).only(a=3, b=5, c=1) => filtering(entry.a in (2, 3) AND entry.b in ('x', 'y', 5) and entry.c == 1) Ex: new_log = log.only(door=1, event_type=221) :param filters: :return: new fitlered EventLog instance View Source def only ( self , ** filters ) -> 'EventLog' : \"\"\" Return new EventLog instance with given filters applied. Kwargs names must be the same as Event slots. Event log returned by this method will contain entries in which attribute value is contained in appropriate filter (if any). Filters passed here will be ANDed during comparison. On repeatable call of only, given filters which was also set on previous call will be ORed, i.e. their values will be concatenated. In other words: ```log.only(a=2, b=['x', 'y'])` => filtering(entry.a == 2 AND entry.b in ('x', 'y'))``` ```log.only(a=2, b=['x', 'y']).only(a=3, b=5, c=1) => filtering(entry.a in (2, 3) AND entry.b in ('x', 'y', 5) and entry.c == 1)``` Ex: `new_log = log.only(door=1, event_type=221)` :param filters: :return: new fitlered EventLog instance \"\"\" only_filters = self . _merge_filters ( self . only_filters , filters ) obj = self . __class__ ( self . _sdk , self . buffer_size , self . data . maxlen , only_filters , _data = self . data ) return obj poll def poll ( self , timeout : float = 60 , polling_interval : float = 1 ) -> List [ pyzkaccess . event . Event ] Wait for new events by making periodically requests to a device. If events was appeared then return them. If no event was appeared until timeout was expired then return empty iterable. :param timeout: timeout in seconds. Default: 60 seconds :param polling_interval: interval to make a requests in seconds. Default: every 1 second :return: iterable with new events if any or empty iterable if timeout has expired View Source def poll ( self , timeout : float = 60 , polling_interval: float = 1 ) -> List [ Event ] : \"\"\" Wait for new events by making periodically requests to a device. If events was appeared then return them. If no event was appeared until timeout was expired then return empty iterable. :param timeout: timeout in seconds. Default: 60 seconds :param polling_interval: interval to make a requests in seconds. Default: every 1 second :return: iterable with new events if any or empty iterable if timeout has expired \"\"\" deadline = datetime . now (). timestamp () + timeout while datetime . now (). timestamp () < deadline : count = self . refresh () # Can run up to several seconds depending on network if count : reversed_events = self . _ filtered_events ( reversed ( self . data )) res = list ( itertools . islice ( reversed_events , None , count ))[ ::- 1 ] return res time . sleep ( polling_interval ) return [] refresh def refresh ( self ) -> int Make a request to a device for new records and append to the end if any. :return: count of records which was added View Source def refresh ( self ) -> int : \"\"\"Make a request to a device for new records and append to the end if any. :return: count of records which was added \"\"\" # ZKAccess always returns single event with code 255 # on every log query if no other events occured . So , skip it new_events = [ e for e in self . _pull_events () if e . event_type != 255 ] count = 0 while new_events : self . data . extend ( new_events ) count += sum ( 1 for _ in self . _filtered_events ( new_events )) new_events = [ e for e in self . _pull_events () if e . event_type != 255 ] return count","title":"Event"},{"location":"reference/pyzkaccess/event/#module-pyzkaccessevent","text":"View Source __ all__ = [ 'Event' , 'EventLog' ] import itertools import time from collections import deque from copy import deepcopy from datetime import datetime from typing import Optional , List , Iterable , Union , Sequence from . common import DocValue from . enum import VerifyMode , PassageDirection , EVENT_TYPES from . sdk import ZKSDK class Event : \"\"\" One realtime event occured on the device Since the device returns event as string we need to parse it to the structured view. This class does this. \"\"\" __ slots__ = ( 'time' , 'pin' , 'card' , 'door' , 'event_type' , 'entry_exit' , 'verify_mode' ) def __ init__ ( self , s ) : \"\"\" :param s: Event string to be parsed. \"\"\" parsed = self . parse ( s ) self . time = datetime . strptime ( parsed [ 0 ], '%Y-%m-%d %H:%M:%S' ) # type : datetime self . pin = parsed [ 1 ] # type : str self . card = parsed [ 2 ] # type : str self . door = int ( parsed [ 3 ]) # type : int self . event_type = EVENT_TYPES [ int ( parsed [ 4 ])] # type : DocValue self . entry_exit = PassageDirection ( int ( parsed [ 5 ])) # type : PassageDirection self . verify_mode = VerifyMode ( int ( parsed [ 6 ])) # type : VerifyMode @property def description ( self ) -> str : msg = 'Event[{}]: \"{}\" at door \"{}\" for card \"{}\" -- {}' . format ( str ( self . time ), self . event_type . doc , self . door , self . card , self . entry_exit . name . capitalize () ) return msg @staticmethod def parse ( event_line: str ) -> Sequence [ str ] : \"\"\" Parse raw event string :param event_line: event string :return: parsed string parts of event string \"\"\" event_line = event_line . replace ( '\\r\\n' , '' ) items = event_line . split ( ',' ) if len ( items ) ! = 7 : raise ValueError ( \"Event string must have exactly 7 parts: {}\" . format ( event_line )) return items def __ eq__ ( self , other ) : if isinstance ( other , Event ) : return all ( getattr ( self , attr ) == getattr ( other , attr ) for attr in self . __ slots__ ) return False def __ ne__ ( self , other ) : return not self . __ eq__ ( other ) def __ str__ ( self ) : return 'Event(' \\ + ', ' . join ( '{}={}' . format ( k , getattr ( self , k )) for k in self . __ slots__ ) \\ + ')' def __ repr__ ( self ) : return self . __ str__ () class EventLog : \"\"\"Log of realtime events Keep in mind that log is not filled out automatically and should be refreshed periodically by hand using `refresh()` method. This is because working with ZKAccess has request-response nature and cannot up a tunnel which may be used to feed events. But you can use `poll()` method which awaits new events from a device and return them if any. Log is implemented at top of deque structure, so accessing by index and filtering could be slow. \"\"\" def __ init__ ( self , sdk : ZKSDK , buffer_size: int , maxlen : Optional [ int ] = None , only_filters: Optional [ dict ] = None , _ data : Optional [ deque ] = None ) : self . buffer_size = buffer_size self . data = _ data if _ data is not None else deque ( maxlen = maxlen ) self . only_filters = only_filters or {} self . _ sdk = sdk def refresh ( self ) -> int : \"\"\"Make a request to a device for new records and append to the end if any. :return: count of records which was added \"\"\" # ZKAccess always returns single event with code 255 # on every log query if no other events occured . So , skip it new_events = [ e for e in self . _ pull_events () if e . event_type ! = 255 ] count = 0 while new_events: self . data . extend ( new_events ) count += sum ( 1 for _ in self . _ filtered_events ( new_events )) new_events = [ e for e in self . _ pull_events () if e . event_type ! = 255 ] return count def after_time ( self , after_time: datetime ) -> Iterable [ Event ] : \"\"\" Return events which was occured after given time :param after_time: datetime object to filter (included) :return: \"\"\" return filter ( lambda x : x . time >= after_time , self . _ filtered_events ( self . data )) def before_time ( self , before_time: datetime ) -> Iterable [ Event ] : \"\"\" Return events which was occured before given time :param before_time: datetime object to filter (excluded) :return: \"\"\" return filter ( lambda x : x . time < before_time , self . _ filtered_events ( self . data )) def between_time ( self , from_time: datetime , to_time: datetime ) -> Iterable [ Event ] : \"\"\" Return events which was occured between two given time moments :param from_time: datetime object to filter (included) :param to_time: datetime object to filter (excluded) :return: \"\"\" return filter ( lambda x : from_time <= x . time < to_time , self . _ filtered_events ( self . data )) def poll ( self , timeout : float = 60 , polling_interval: float = 1 ) -> List [ Event ] : \"\"\" Wait for new events by making periodically requests to a device. If events was appeared then return them. If no event was appeared until timeout was expired then return empty iterable. :param timeout: timeout in seconds. Default: 60 seconds :param polling_interval: interval to make a requests in seconds. Default: every 1 second :return: iterable with new events if any or empty iterable if timeout has expired \"\"\" deadline = datetime . now (). timestamp () + timeout while datetime . now (). timestamp () < deadline : count = self . refresh () # Can run up to several seconds depending on network if count : reversed_events = self . _ filtered_events ( reversed ( self . data )) res = list ( itertools . islice ( reversed_events , None , count ))[ ::- 1 ] return res time . sleep ( polling_interval ) return [] def only ( self , **filters ) -> 'EventLog': \"\"\" Return new EventLog instance with given filters applied. Kwargs names must be the same as Event slots. Event log returned by this method will contain entries in which attribute value is contained in appropriate filter (if any). Filters passed here will be ANDed during comparison. On repeatable call of only, given filters which was also set on previous call will be ORed, i.e. their values will be concatenated. In other words: ```log.only(a=2, b=['x', 'y'])` => filtering(entry.a == 2 AND entry.b in ('x', 'y'))``` ```log.only(a=2, b=['x', 'y']).only(a=3, b=5, c=1) => filtering(entry.a in (2, 3) AND entry.b in ('x', 'y', 5) and entry.c == 1)``` Ex: `new_log = log.only(door=1, event_type=221)` :param filters: :return: new fitlered EventLog instance \"\"\" only_filters = self . _ merge_filters ( self . only_filters , filters ) obj = self . __ class__ ( self . _ sdk , self . buffer_size , self . data . maxlen , only_filters , _ data = self . data ) return obj def clear ( self ) -> None : \"\"\"Clear log\"\"\" self . data . clear () @staticmethod def _ merge_filters ( initial : dict , fltr : dict ) -> dict : \"\"\" Merge two filter dicts, fltr updates initial. Key-values which does not exist in initial will be copied. Value of existent keys are combined (values always are lists). :param initial: updating initial filter dict :param fltr: filter dict which updates initial :return: merged filter dict \"\"\" seq_types = ( tuple , list , set , frozenset ) res = deepcopy ( initial ) for key , value in fltr . items () : if not isinstance ( value , seq_types ) : value = { value } if key in res : res [ key ]. update ( value ) else : res [ key ] = set ( value ) return res def _ filtered_events ( self , data : Iterable [ Event ]) -> Iterable [ Event ] : \"\"\" Apply current filters to given events and return only events which meet them :param data: unfiltered events :return: filtered events \"\"\" if not self . only_filters: yield from data return for event in data : if not self . only_filters: yield event else : all_match = all ( getattr ( event , field ) in fltr for field , fltr in self . only_filters . items ()) if all_match: yield event def _ pull_events ( self ) -> Iterable [ Event ] : events = self . _ sdk . get_rt_log ( self . buffer_size ) return ( Event ( s ) for s in events ) def __ getitem__ ( self , item : Union [ int , slice ]) -> Union [ Iterable [ Event ], Event ] : seq = self . _ filtered_events ( self . data ) if not isinstance ( item , slice ) : try : return next ( itertools . islice ( seq , item , None )) except StopIteration : raise IndexError ( 'Index is out of range' ) from None start , stop , step = item . start , item . stop , item . step return itertools . islice ( seq , start , stop , step ) def __ len__ ( self ) -> int : if not self . only_filters: return len ( self . data ) return sum ( 1 for _ in self . _ filtered_events ( self . data )) def __ iter__ ( self ) : return iter ( self . _ filtered_events ( self . data )) def __ str__ ( self ) : items_str = ', ' . join ( str ( x ) for x in self [ : 3 ]) if len ( self ) > 6 : items_str += ', ..., ' + ', ' . join ( str ( x ) for x in self [ 3 : ]) return 'EventLog[{}]({})' . format ( len ( self ), items_str ) def __ repr__ ( self ) : return self . __ str__ ()","title":"Module pyzkaccess.event"},{"location":"reference/pyzkaccess/event/#classes","text":"","title":"Classes"},{"location":"reference/pyzkaccess/event/#event","text":"class Event ( s ) One realtime event occured on the device Since the device returns event as string we need to parse it to the structured view. This class does this. View Source class Event : \"\"\" One realtime event occured on the device Since the device returns event as string we need to parse it to the structured view. This class does this. \"\"\" __slots__ = ( 'time' , 'pin' , 'card' , 'door' , 'event_type' , 'entry_exit' , 'verify_mode' ) def __init__ ( self , s ) : \"\"\" :param s: Event string to be parsed. \"\"\" parsed = self . parse ( s ) self . time = datetime . strptime ( parsed [ 0 ] , '%Y-%m-%d %H:%M:%S' ) # type : datetime self . pin = parsed [ 1 ] # type : str self . card = parsed [ 2 ] # type : str self . door = int ( parsed [ 3 ] ) # type : int self . event_type = EVENT_TYPES [ int(parsed[4 ] ) ] # type : DocValue self . entry_exit = PassageDirection ( int ( parsed [ 5 ] )) # type : PassageDirection self . verify_mode = VerifyMode ( int ( parsed [ 6 ] )) # type : VerifyMode @property def description ( self ) -> str : msg = 'Event[{}]: \"{}\" at door \"{}\" for card \"{}\" -- {}' . format ( str ( self . time ), self . event_type . doc , self . door , self . card , self . entry_exit . name . capitalize () ) return msg @staticmethod def parse ( event_line : str ) -> Sequence [ str ] : \"\"\" Parse raw event string :param event_line: event string :return: parsed string parts of event string \"\"\" event_line = event_line . replace ( '\\r\\n' , '' ) items = event_line . split ( ',' ) if len ( items ) != 7 : raise ValueError ( \"Event string must have exactly 7 parts: {}\" . format ( event_line )) return items def __eq__ ( self , other ) : if isinstance ( other , Event ) : return all ( getattr ( self , attr ) == getattr ( other , attr ) for attr in self . __slots__ ) return False def __ne__ ( self , other ) : return not self . __eq__ ( other ) def __str__ ( self ) : return 'Event(' \\ + ', ' . join ( '{}={}' . format ( k , getattr ( self , k )) for k in self . __slots__ ) \\ + ')' def __repr__ ( self ) : return self . __str__ ()","title":"Event"},{"location":"reference/pyzkaccess/event/#static-methods","text":"","title":"Static methods"},{"location":"reference/pyzkaccess/event/#parse","text":"def parse ( event_line : str ) -> Sequence [ str ] Parse raw event string :param event_line: event string :return: parsed string parts of event string View Source @staticmethod def parse ( event_line : str ) -> Sequence [ str ] : \"\"\" Parse raw event string :param event_line: event string :return: parsed string parts of event string \"\"\" event_line = event_line . replace ( '\\r\\n' , '' ) items = event_line . split ( ',' ) if len ( items ) != 7 : raise ValueError ( \"Event string must have exactly 7 parts: {}\" . format ( event_line )) return items","title":"parse"},{"location":"reference/pyzkaccess/event/#instance-variables","text":"card description door entry_exit event_type pin time verify_mode","title":"Instance variables"},{"location":"reference/pyzkaccess/event/#eventlog","text":"class EventLog ( sdk : pyzkaccess . sdk . ZKSDK , buffer_size : int , maxlen : Union [ int , NoneType ] = None , only_filters : Union [ dict , NoneType ] = None , _data : Union [ collections . deque , NoneType ] = None ) Log of realtime events Keep in mind that log is not filled out automatically and should be refreshed periodically by hand using refresh() method. This is because working with ZKAccess has request-response nature and cannot up a tunnel which may be used to feed events. But you can use poll() method which awaits new events from a device and return them if any. Log is implemented at top of deque structure, so accessing by index and filtering could be slow. View Source class EventLog : \"\"\"Log of realtime events Keep in mind that log is not filled out automatically and should be refreshed periodically by hand using `refresh()` method. This is because working with ZKAccess has request-response nature and cannot up a tunnel which may be used to feed events. But you can use `poll()` method which awaits new events from a device and return them if any. Log is implemented at top of deque structure, so accessing by index and filtering could be slow. \"\"\" def __ init__ ( self , sdk : ZKSDK , buffer_size: int , maxlen : Optional [ int ] = None , only_filters: Optional [ dict ] = None , _ data : Optional [ deque ] = None ) : self . buffer_size = buffer_size self . data = _ data if _ data is not None else deque ( maxlen = maxlen ) self . only_filters = only_filters or {} self . _ sdk = sdk def refresh ( self ) -> int : \"\"\"Make a request to a device for new records and append to the end if any. :return: count of records which was added \"\"\" # ZKAccess always returns single event with code 255 # on every log query if no other events occured . So , skip it new_events = [ e for e in self . _ pull_events () if e . event_type ! = 255 ] count = 0 while new_events: self . data . extend ( new_events ) count += sum ( 1 for _ in self . _ filtered_events ( new_events )) new_events = [ e for e in self . _ pull_events () if e . event_type ! = 255 ] return count def after_time ( self , after_time: datetime ) -> Iterable [ Event ] : \"\"\" Return events which was occured after given time :param after_time: datetime object to filter (included) :return: \"\"\" return filter ( lambda x : x . time >= after_time , self . _ filtered_events ( self . data )) def before_time ( self , before_time: datetime ) -> Iterable [ Event ] : \"\"\" Return events which was occured before given time :param before_time: datetime object to filter (excluded) :return: \"\"\" return filter ( lambda x : x . time < before_time , self . _ filtered_events ( self . data )) def between_time ( self , from_time: datetime , to_time: datetime ) -> Iterable [ Event ] : \"\"\" Return events which was occured between two given time moments :param from_time: datetime object to filter (included) :param to_time: datetime object to filter (excluded) :return: \"\"\" return filter ( lambda x : from_time <= x . time < to_time , self . _ filtered_events ( self . data )) def poll ( self , timeout : float = 60 , polling_interval: float = 1 ) -> List [ Event ] : \"\"\" Wait for new events by making periodically requests to a device. If events was appeared then return them. If no event was appeared until timeout was expired then return empty iterable. :param timeout: timeout in seconds. Default: 60 seconds :param polling_interval: interval to make a requests in seconds. Default: every 1 second :return: iterable with new events if any or empty iterable if timeout has expired \"\"\" deadline = datetime . now (). timestamp () + timeout while datetime . now (). timestamp () < deadline : count = self . refresh () # Can run up to several seconds depending on network if count : reversed_events = self . _ filtered_events ( reversed ( self . data )) res = list ( itertools . islice ( reversed_events , None , count ))[ ::- 1 ] return res time . sleep ( polling_interval ) return [] def only ( self , **filters ) -> 'EventLog': \"\"\" Return new EventLog instance with given filters applied. Kwargs names must be the same as Event slots. Event log returned by this method will contain entries in which attribute value is contained in appropriate filter (if any). Filters passed here will be ANDed during comparison. On repeatable call of only, given filters which was also set on previous call will be ORed, i.e. their values will be concatenated. In other words: ```log.only(a=2, b=['x', 'y'])` => filtering(entry.a == 2 AND entry.b in ('x', 'y'))``` ```log.only(a=2, b=['x', 'y']).only(a=3, b=5, c=1) => filtering(entry.a in (2, 3) AND entry.b in ('x', 'y', 5) and entry.c == 1)``` Ex: `new_log = log.only(door=1, event_type=221)` :param filters: :return: new fitlered EventLog instance \"\"\" only_filters = self . _ merge_filters ( self . only_filters , filters ) obj = self . __ class__ ( self . _ sdk , self . buffer_size , self . data . maxlen , only_filters , _ data = self . data ) return obj def clear ( self ) -> None : \"\"\"Clear log\"\"\" self . data . clear () @staticmethod def _ merge_filters ( initial : dict , fltr : dict ) -> dict : \"\"\" Merge two filter dicts, fltr updates initial. Key-values which does not exist in initial will be copied. Value of existent keys are combined (values always are lists). :param initial: updating initial filter dict :param fltr: filter dict which updates initial :return: merged filter dict \"\"\" seq_types = ( tuple , list , set , frozenset ) res = deepcopy ( initial ) for key , value in fltr . items () : if not isinstance ( value , seq_types ) : value = { value } if key in res : res [ key ]. update ( value ) else : res [ key ] = set ( value ) return res def _ filtered_events ( self , data : Iterable [ Event ]) -> Iterable [ Event ] : \"\"\" Apply current filters to given events and return only events which meet them :param data: unfiltered events :return: filtered events \"\"\" if not self . only_filters: yield from data return for event in data : if not self . only_filters: yield event else : all_match = all ( getattr ( event , field ) in fltr for field , fltr in self . only_filters . items ()) if all_match: yield event def _ pull_events ( self ) -> Iterable [ Event ] : events = self . _ sdk . get_rt_log ( self . buffer_size ) return ( Event ( s ) for s in events ) def __ getitem__ ( self , item : Union [ int , slice ]) -> Union [ Iterable [ Event ], Event ] : seq = self . _ filtered_events ( self . data ) if not isinstance ( item , slice ) : try : return next ( itertools . islice ( seq , item , None )) except StopIteration : raise IndexError ( 'Index is out of range' ) from None start , stop , step = item . start , item . stop , item . step return itertools . islice ( seq , start , stop , step ) def __ len__ ( self ) -> int : if not self . only_filters: return len ( self . data ) return sum ( 1 for _ in self . _ filtered_events ( self . data )) def __ iter__ ( self ) : return iter ( self . _ filtered_events ( self . data )) def __ str__ ( self ) : items_str = ', ' . join ( str ( x ) for x in self [ : 3 ]) if len ( self ) > 6 : items_str += ', ..., ' + ', ' . join ( str ( x ) for x in self [ 3 : ]) return 'EventLog[{}]({})' . format ( len ( self ), items_str ) def __ repr__ ( self ) : return self . __ str__ ()","title":"EventLog"},{"location":"reference/pyzkaccess/event/#methods","text":"","title":"Methods"},{"location":"reference/pyzkaccess/event/#after_time","text":"def after_time ( self , after_time : datetime . datetime ) -> Iterable [ pyzkaccess . event . Event ] Return events which was occured after given time :param after_time: datetime object to filter (included) :return: View Source def after_time ( self , after_time : datetime ) -> Iterable [ Event ] : \"\"\" Return events which was occured after given time :param after_time: datetime object to filter (included) :return: \"\"\" return filter ( lambda x : x . time >= after_time , self . _filtered_events ( self . data ))","title":"after_time"},{"location":"reference/pyzkaccess/event/#before_time","text":"def before_time ( self , before_time : datetime . datetime ) -> Iterable [ pyzkaccess . event . Event ] Return events which was occured before given time :param before_time: datetime object to filter (excluded) :return: View Source def before_time ( self , before_time : datetime ) -> Iterable [ Event ] : \"\"\" Return events which was occured before given time :param before_time: datetime object to filter (excluded) :return: \"\"\" return filter ( lambda x : x . time < before_time , self . _filtered_events ( self . data ))","title":"before_time"},{"location":"reference/pyzkaccess/event/#between_time","text":"def between_time ( self , from_time : datetime . datetime , to_time : datetime . datetime ) -> Iterable [ pyzkaccess . event . Event ] Return events which was occured between two given time moments :param from_time: datetime object to filter (included) :param to_time: datetime object to filter (excluded) :return: View Source def between_time ( self , from_time : datetime , to_time : datetime ) -> Iterable [ Event ] : \"\"\" Return events which was occured between two given time moments :param from_time: datetime object to filter (included) :param to_time: datetime object to filter (excluded) :return: \"\"\" return filter ( lambda x : from_time <= x . time < to_time , self . _filtered_events ( self . data ))","title":"between_time"},{"location":"reference/pyzkaccess/event/#clear","text":"def clear ( self ) -> None Clear log View Source def clear ( self ) -> None : \"\"\"Clear log\"\"\" self . data . clear ()","title":"clear"},{"location":"reference/pyzkaccess/event/#only","text":"def only ( self , ** filters ) -> 'EventLog' Return new EventLog instance with given filters applied. Kwargs names must be the same as Event slots. Event log returned by this method will contain entries in which attribute value is contained in appropriate filter (if any). Filters passed here will be ANDed during comparison. On repeatable call of only, given filters which was also set on previous call will be ORed, i.e. their values will be concatenated. In other words: log.only(a=2, b=['x', 'y'])` => filtering(entry.a == 2 AND entry.b in ('x', 'y')) log.only(a=2, b=['x', 'y']).only(a=3, b=5, c=1) => filtering(entry.a in (2, 3) AND entry.b in ('x', 'y', 5) and entry.c == 1) Ex: new_log = log.only(door=1, event_type=221) :param filters: :return: new fitlered EventLog instance View Source def only ( self , ** filters ) -> 'EventLog' : \"\"\" Return new EventLog instance with given filters applied. Kwargs names must be the same as Event slots. Event log returned by this method will contain entries in which attribute value is contained in appropriate filter (if any). Filters passed here will be ANDed during comparison. On repeatable call of only, given filters which was also set on previous call will be ORed, i.e. their values will be concatenated. In other words: ```log.only(a=2, b=['x', 'y'])` => filtering(entry.a == 2 AND entry.b in ('x', 'y'))``` ```log.only(a=2, b=['x', 'y']).only(a=3, b=5, c=1) => filtering(entry.a in (2, 3) AND entry.b in ('x', 'y', 5) and entry.c == 1)``` Ex: `new_log = log.only(door=1, event_type=221)` :param filters: :return: new fitlered EventLog instance \"\"\" only_filters = self . _merge_filters ( self . only_filters , filters ) obj = self . __class__ ( self . _sdk , self . buffer_size , self . data . maxlen , only_filters , _data = self . data ) return obj","title":"only"},{"location":"reference/pyzkaccess/event/#poll","text":"def poll ( self , timeout : float = 60 , polling_interval : float = 1 ) -> List [ pyzkaccess . event . Event ] Wait for new events by making periodically requests to a device. If events was appeared then return them. If no event was appeared until timeout was expired then return empty iterable. :param timeout: timeout in seconds. Default: 60 seconds :param polling_interval: interval to make a requests in seconds. Default: every 1 second :return: iterable with new events if any or empty iterable if timeout has expired View Source def poll ( self , timeout : float = 60 , polling_interval: float = 1 ) -> List [ Event ] : \"\"\" Wait for new events by making periodically requests to a device. If events was appeared then return them. If no event was appeared until timeout was expired then return empty iterable. :param timeout: timeout in seconds. Default: 60 seconds :param polling_interval: interval to make a requests in seconds. Default: every 1 second :return: iterable with new events if any or empty iterable if timeout has expired \"\"\" deadline = datetime . now (). timestamp () + timeout while datetime . now (). timestamp () < deadline : count = self . refresh () # Can run up to several seconds depending on network if count : reversed_events = self . _ filtered_events ( reversed ( self . data )) res = list ( itertools . islice ( reversed_events , None , count ))[ ::- 1 ] return res time . sleep ( polling_interval ) return []","title":"poll"},{"location":"reference/pyzkaccess/event/#refresh","text":"def refresh ( self ) -> int Make a request to a device for new records and append to the end if any. :return: count of records which was added View Source def refresh ( self ) -> int : \"\"\"Make a request to a device for new records and append to the end if any. :return: count of records which was added \"\"\" # ZKAccess always returns single event with code 255 # on every log query if no other events occured . So , skip it new_events = [ e for e in self . _pull_events () if e . event_type != 255 ] count = 0 while new_events : self . data . extend ( new_events ) count += sum ( 1 for _ in self . _filtered_events ( new_events )) new_events = [ e for e in self . _pull_events () if e . event_type != 255 ] return count","title":"refresh"},{"location":"reference/pyzkaccess/exceptions/","text":"Module pyzkaccess.exceptions View Source __all__ = [ 'ZKSDKError' ] from .enum import PULL_SDK_ERRORS , WSA_ERROR_CODES class ZKSDKError ( Exception ): \"\"\"Error occured in PULL SDK function. Supports description of errors caused by PULL SDK and WINSOCK \"\"\" def __init__ ( self , msg : str , err : int , * args ): super () . __init__ (( msg , * args )) self . err = int ( err ) self . msg = msg def __str__ ( self ): if self . err in PULL_SDK_ERRORS : descr = 'SDK error {}: {}' . format ( self . err , PULL_SDK_ERRORS [ self . err ] . __doc__ ) elif self . err in WSA_ERROR_CODES : descr = 'WINSOCK error {}: {}' . format ( self . err , WSA_ERROR_CODES [ self . err ] . __doc__ ) else : descr = 'Unknown error {}' . format ( self . err ) return '{}: {}' . format ( self . msg , descr ) Classes ZKSDKError class ZKSDKError ( msg : str , err : int , * args ) Error occured in PULL SDK function. Supports description of errors caused by PULL SDK and WINSOCK View Source class ZKSDKError ( Exception ): \"\"\"Error occured in PULL SDK function. Supports description of errors caused by PULL SDK and WINSOCK \"\"\" def __init__ ( self , msg: str , err: int , * args ): super (). __init__ (( msg , * args )) self . err = int ( err ) self . msg = msg def __str__ ( self ): if self . err in PULL_SDK_ERRORS: descr = 'SDK error {}: {}' . format ( self . err , PULL_SDK_ERRORS [ self . err ]. __doc__ ) elif self . err in WSA_ERROR_CODES: descr = 'WINSOCK error {}: {}' . format ( self . err , WSA_ERROR_CODES [ self . err ]. __doc__ ) else: descr = 'Unknown error {}' . format ( self . err ) return '{}: {}' . format ( self . msg , descr ) Ancestors (in MRO) builtins.Exception builtins.BaseException Class variables args Methods with_traceback def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self.","title":"Exceptions"},{"location":"reference/pyzkaccess/exceptions/#module-pyzkaccessexceptions","text":"View Source __all__ = [ 'ZKSDKError' ] from .enum import PULL_SDK_ERRORS , WSA_ERROR_CODES class ZKSDKError ( Exception ): \"\"\"Error occured in PULL SDK function. Supports description of errors caused by PULL SDK and WINSOCK \"\"\" def __init__ ( self , msg : str , err : int , * args ): super () . __init__ (( msg , * args )) self . err = int ( err ) self . msg = msg def __str__ ( self ): if self . err in PULL_SDK_ERRORS : descr = 'SDK error {}: {}' . format ( self . err , PULL_SDK_ERRORS [ self . err ] . __doc__ ) elif self . err in WSA_ERROR_CODES : descr = 'WINSOCK error {}: {}' . format ( self . err , WSA_ERROR_CODES [ self . err ] . __doc__ ) else : descr = 'Unknown error {}' . format ( self . err ) return '{}: {}' . format ( self . msg , descr )","title":"Module pyzkaccess.exceptions"},{"location":"reference/pyzkaccess/exceptions/#classes","text":"","title":"Classes"},{"location":"reference/pyzkaccess/exceptions/#zksdkerror","text":"class ZKSDKError ( msg : str , err : int , * args ) Error occured in PULL SDK function. Supports description of errors caused by PULL SDK and WINSOCK View Source class ZKSDKError ( Exception ): \"\"\"Error occured in PULL SDK function. Supports description of errors caused by PULL SDK and WINSOCK \"\"\" def __init__ ( self , msg: str , err: int , * args ): super (). __init__ (( msg , * args )) self . err = int ( err ) self . msg = msg def __str__ ( self ): if self . err in PULL_SDK_ERRORS: descr = 'SDK error {}: {}' . format ( self . err , PULL_SDK_ERRORS [ self . err ]. __doc__ ) elif self . err in WSA_ERROR_CODES: descr = 'WINSOCK error {}: {}' . format ( self . err , WSA_ERROR_CODES [ self . err ]. __doc__ ) else: descr = 'Unknown error {}' . format ( self . err ) return '{}: {}' . format ( self . msg , descr )","title":"ZKSDKError"},{"location":"reference/pyzkaccess/exceptions/#ancestors-in-mro","text":"builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"reference/pyzkaccess/exceptions/#class-variables","text":"args","title":"Class variables"},{"location":"reference/pyzkaccess/exceptions/#methods","text":"","title":"Methods"},{"location":"reference/pyzkaccess/exceptions/#with_traceback","text":"def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self.","title":"with_traceback"},{"location":"reference/pyzkaccess/param/","text":"Module pyzkaccess.param View Source __all__ = [ 'DaylightSavingMomentMode1' , 'DaylightSavingMomentMode2' , 'BaseParameters' , 'DeviceParameters' , 'DoorParameters' ] import re from datetime import datetime from enum import Enum from .device import ZKModel from .enum import SensorType , VerifyMode from .sdk import ZKSDK def _make_daylight_prop ( query_name_spring , query_name_fall , minimum , maximum ): def read ( self ): query = query_name_spring if self . is_daylight else query_name_fall res = self . _sdk . get_device_param ( parameters = ( query ,), buffer_size = self . buffer_size ) res = int ( res [ query ]) if not ( minimum <= res <= maximum ): raise ValueError ( 'Value {} is not in range {}..{}' . format ( res , minimum , maximum )) return res def write ( self , value ): query = query_name_spring if self . is_daylight else query_name_fall if not isinstance ( value , int ): raise TypeError ( 'Bad value type, should be int' ) if not ( minimum <= value <= maximum ): raise ValueError ( 'Value {} is not in range {}..{}' . format ( value , minimum , maximum )) self . _sdk . set_device_param ( parameters = { query : str ( value )}) return property ( fget = read , fset = write , fdel = None , doc = None ) class DaylightSavingMomentMode1 : \"\"\"Daylight saving parameters used in mode1 setting (all parameters in one request). See `DLSTMode`, `DaylightSavingTime`, `StandardTime` parameters in SDK docs \"\"\" def __init__ ( self , month , day , hour , minute ): self . month = int ( month ) self . day = int ( day ) self . hour = int ( hour ) self . minute = int ( minute ) if not ( 1 <= self . month <= 12 ): raise ValueError ( 'Month must have value in range 1..12' ) if not ( 1 <= self . day <= 7 ): raise ValueError ( 'Day of week must have value in range 1..7' ) if not ( 0 <= self . hour <= 23 ): raise ValueError ( 'Hour must have value in range 0..23' ) if not ( 0 <= self . minute <= 59 ): raise ValueError ( 'Minute must have value in range 0..59' ) def __str__ ( self ): return '-' . join ( str ( x ) for x in ( self . month , self . day , self . hour , self . minute )) def __repr__ ( self ): pieces = 'month' , 'day' , 'hour' , 'minute' return '{}({})' . format ( self . __class__ . __name__ , ', ' . join ( '{}={}' . format ( x , getattr ( self , x )) for x in pieces )) class DaylightSavingMomentMode2 : \"\"\"Daylight saving parameters used in mode2 setting (each parameter in a separate request). See `DLSTMode`, `WeekOfMonth*` parameters in SDK docs \"\"\" def __init__ ( self , sdk : ZKSDK , is_daylight : bool , buffer_size : int ): self . is_daylight = is_daylight self . buffer_size = buffer_size self . _sdk = sdk month = _make_daylight_prop ( 'WeekOfMonth1' , 'WeekOfMonth6' , 1 , 12 ) week_of_month = _make_daylight_prop ( 'WeekOfMonth2' , 'WeekOfMonth7' , 1 , 6 ) day_of_week = _make_daylight_prop ( 'WeekOfMonth3' , 'WeekOfMonth8' , 1 , 7 ) hour = _make_daylight_prop ( 'WeekOfMonth4' , 'WeekOfMonth9' , 0 , 23 ) minute = _make_daylight_prop ( 'WeekOfMonth5' , 'WeekOfMonth10' , 0 , 59 ) def __str__ ( self ): pieces = 'month' , 'week_of_month' , 'day_of_week' , 'hour' , 'minute' return '{}({})' . format ( self . __class__ . __name__ , ', ' . join ( '{}={}' . format ( x , getattr ( self , x )) for x in pieces )) def __repr__ ( self ): return self . __str__ () def _make_prop ( query_tpl : str , data_type , prop_type , readable = True , writable = True , doc = None , restriction_f = None ): assert readable or writable def read ( self ) -> prop_type : query = query_tpl . format ( self = self ) res = self . _sdk . get_device_param ( parameters = ( query ,), buffer_size = self . buffer_size ) res = res [ query ] res = data_type ( res ) if data_type != prop_type : res = prop_type ( res ) if not ( restriction_f is None or restriction_f ( res )): raise ValueError ( 'Value {} does not meet to parameter restrictions, ' 'see property docstring and SDK documentation' . format ( res )) return res def write ( self , value : prop_type ): # Check incoming value type. If prop_type is specified then # check against it, otherwise check against data_type if not isinstance ( value , prop_type ): raise TypeError ( 'Bad value type, should be {}' . format ( prop_type )) # Pass original value to restriction function if not ( restriction_f is None or restriction_f ( value )): raise ValueError ( 'Value {} does not meet to parameter restrictions, ' 'see property docstring and SDK documentation' . format ( value )) if issubclass ( prop_type , Enum ): value = value . value value = data_type ( value ) query = query_tpl . format ( self = self ) self . _sdk . set_device_param ( parameters = { query : str ( value )}) doc_readable_msg = '-' . join ( x for x in [ 'read' if readable else '' , 'write' if writable else '' , 'only' if readable != writable else '' ] if x ) return property ( fget = read if readable else None , fset = write if writable else None , fdel = None , doc = '{} ({})' . format ( doc , doc_readable_msg ) ) class BaseParameters : #: Size in bytes of c-string buffer which is used to accept #: text data from PULL SDK functions buffer_size = 4096 def __init__ ( self , sdk : ZKSDK , device_model : type ( ZKModel )): self . device_model = device_model self . _sdk = sdk def _check_ip ( addr : str ): return re . match ( r '^[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}$' , addr ) \\ and all ( 0 <= int ( x ) <= 255 for x in addr . split ( '.' )) class DeviceParameters ( BaseParameters ): \"\"\"Parameters related to the whole device\"\"\" serial_number = _make_prop ( '~SerialNumber' , str , str , True , False , 'Serial number of device' ) lock_count = _make_prop ( 'LockCount' , int , int , True , False , 'Doors count' ) reader_count = _make_prop ( 'ReaderCount' , int , int , True , False , 'Readers count' ) aux_in_count = _make_prop ( 'AuxInCount' , int , int , True , False , 'Auxiliary inputs count' ) aux_out_count = _make_prop ( 'AuxOutCount' , int , int , True , False , 'Auxiliary output count' ) communication_password = _make_prop ( 'ComPwd' , str , str , True , True , 'Password to connect to a device. Maximum is 15 symbols' , lambda x : len ( x ) <= 15 ) ip_address = _make_prop ( 'IPAddress' , str , str , True , True , 'Device IPv4 address' , _check_ip ) netmask = _make_prop ( 'NetMask' , str , str , True , True , 'Subnet mask' , _check_ip ) gateway_ip_address = _make_prop ( 'GATEIPAddress' , str , str , True , True , 'Gateway IPv4 address' , _check_ip ) rs232_baud_rate = _make_prop ( 'RS232BaudRate' , int , int , True , True , 'RS232 baud rate' , lambda x : x > 0 ) watchdog_enabled = _make_prop ( 'WatchDog' , int , bool , True , True , 'MCU watchdog enabled' ) door4_to_door2 = _make_prop ( 'Door4ToDoor2' , int , bool , True , True , '4 doors turn 2 doors' ) backup_hour = _make_prop ( 'BackupTime' , int , int , True , True , 'The time (hour) of backup SD card. Number 1..24' , lambda x : 1 <= x <= 24 ) reboot = _make_prop ( 'Reboot' , int , bool , False , True , 'Reboot a device, accepts only True value' , lambda x : x is True ) reader_direction = _make_prop ( 'InBIOTowWay' , str , str , True , True , 'One-way/Two-way reader' ) fingerprint_version = _make_prop ( '~ZKFPVersion' , int , int , True , False , 'Device fingerprint identification version. Available values: 9, 10' , lambda x : x in ( 9 , 10 ) ) display_daylight_saving = _make_prop ( '~DSTF' , int , bool , True , True , 'Display parameters of daylight saving time' ) enable_daylight_saving = _make_prop ( 'DaylightSavingTimeOn' , int , bool , True , True , 'Enable time daylight saving' ) daylight_saving_mode = _make_prop ( 'DLSTMode' , int , int , True , True , 'Daylight saving mode, available values 0 (mode 1), 1 (mode 2)' , lambda x : x in ( 0 , 1 ) ) @property def anti_passback_rule ( self ) -> int : \"\"\"Passback rule for doors. Possible values depend on device model. Passback is when the second door can be opened only after the first door has opened, not otherwise. Or a door can be opened only by its readers from one side. \"\"\" res = self . _sdk . get_device_param ( parameters = ( 'AntiPassback' ,), buffer_size = self . buffer_size ) res = int ( res [ 'AntiPassback' ]) if res not in self . device_model . anti_passback_rules : raise ValueError ( 'Value {} not in possible values for {}: {}' . format ( res , self . device_model . name , self . device_model . anti_passback_rules . keys () )) return self . device_model . anti_passback_rules [ res ] @anti_passback_rule.setter def anti_passback_rule ( self , value : int ): if value not in self . device_model . anti_passback_rules : raise ValueError ( 'Value {} not in possible values for {}: {}' . format ( value , self . device_model . name , tuple ( self . device_model . anti_passback_rules . keys ()) )) self . _sdk . set_device_param ( parameters = { 'AntiPassback' : str ( value )}) @property def interlock ( self ) -> int : \"\"\"Interlock rule for doors. Possible values depend on device model. Interlock is when the second door can be opened only after the first door was opened and closed, and vice versa\"\"\" res = self . _sdk . get_device_param ( parameters = ( 'InterLock' ,), buffer_size = self . buffer_size ) if not res : return self . device_model . interlock_rules [ 0 ] res = int ( res [ 'InterLock' ]) if res not in self . device_model . interlock_rules : raise ValueError ( 'Value {} not in possible values for {}: {}' . format ( res , self . device_model . name , self . device_model . interlock_rules . keys () )) return self . device_model . interlock_rules [ res ] @interlock.setter def interlock ( self , value : int ): if value not in self . device_model . anti_passback_rules : raise ValueError ( 'Value {} not in possible values for {}: {}' . format ( value , self . device_model . name , self . device_model . anti_passback_rules . keys () )) self . _sdk . set_device_param ( parameters = { 'InterLock' : str ( value )}) @property def spring_daylight_time_mode1 ( self ) -> DaylightSavingMomentMode1 : \"\"\"Spring forward daylight saving time (mode 1) (read-write)\"\"\" res = self . _sdk . get_device_param ( parameters = ( 'DaylightSavingTime' ,), buffer_size = self . buffer_size ) res = [ int ( x ) for x in res [ 'DaylightSavingTime' ] . split ( '-' )] # FIXME: extract bytes? return DaylightSavingMomentMode1 ( month = res [ 0 ], day = res [ 1 ], hour = res [ 2 ], minute = res [ 3 ]) @spring_daylight_time_mode1.setter def spring_daylight_time_mode1 ( self , value : DaylightSavingMomentMode1 ): self . _sdk . set_device_param ( parameters = { 'DaylightSavingTime' : str ( value )}) @property def fall_daylight_time_mode1 ( self ) -> DaylightSavingMomentMode1 : \"\"\"Fall back daylight saving time (mode 1) (read-write)\"\"\" res = self . _sdk . get_device_param ( parameters = ( 'StandardTime' ,), buffer_size = self . buffer_size ) res = [ int ( x ) for x in res [ 'StandardTime' ] . split ( '-' )] return DaylightSavingMomentMode1 ( month = res [ 0 ], day = res [ 1 ], hour = res [ 2 ], minute = res [ 3 ]) @fall_daylight_time_mode1.setter def fall_daylight_time_mode1 ( self , value : DaylightSavingMomentMode1 ): self . _sdk . set_device_param ( parameters = { 'StandardTime' : str ( value )}) @property def spring_daylight_time_mode2 ( self ) -> DaylightSavingMomentMode2 : \"\"\"Spring forward daylight saving time (mode 2) (read-write)\"\"\" return DaylightSavingMomentMode2 ( self . _sdk , True , self . buffer_size ) @spring_daylight_time_mode2.setter def spring_daylight_time_mode2 ( self , value : DaylightSavingMomentMode2 ): t = DaylightSavingMomentMode2 ( self . _sdk , True , self . buffer_size ) for attr in ( 'month' , 'week_of_month' , 'day_of_week' , 'hour' , 'minute' ): setattr ( t , attr , getattr ( value , attr )) @property def fall_daylight_time_mode2 ( self ) -> DaylightSavingMomentMode2 : \"\"\"Fall back daylight saving time (mode 2) (read-write)\"\"\" return DaylightSavingMomentMode2 ( self . _sdk , False , self . buffer_size ) @fall_daylight_time_mode2.setter def fall_daylight_time_mode2 ( self , value : DaylightSavingMomentMode2 ): t = DaylightSavingMomentMode2 ( self . _sdk , False , self . buffer_size ) for attr in ( 'month' , 'week_of_month' , 'day_of_week' , 'hour' , 'minute' ): setattr ( t , attr , getattr ( value , attr )) def _set_datetime ( self , value : datetime ): # Amazing DIY ctime calculating from ZKTeco guys. # Simply put this is a count of seconds starting from # 2000-01-01T00:00:00 without considering leap years/seconds # or different length of months (always 31 day) # See PULL SDK docs if value . year < 2000 : raise ValueError ( 'Minimum year is 2000' ) value = sum (( sum (( ( value . year - 2000 ) * 12 * 31 , ( value . month - 1 ) * 31 , ( value . day - 1 ) )) * 24 * 60 * 60 , value . hour * 60 * 60 , value . minute * 60 , value . second )) self . _sdk . set_device_param ( parameters = { 'DateTime' : str ( value )}) def _get_datetime ( self ): res = self . _sdk . get_device_param ( parameters = ( 'DateTime' ,), buffer_size = self . buffer_size ) res = int ( res [ 'DateTime' ]) dt = datetime ( year = res // 32140800 + 2000 , month = ( res // 2678400 ) % 12 + 1 , day = ( res // 86400 ) % 31 + 1 , hour = ( res // 3600 ) % 24 , minute = ( res // 60 ) % 60 , second = res % 60 ) return dt datetime = property ( _get_datetime , _set_datetime , None , 'Current datetime (read-write)' ) class DoorParameters ( BaseParameters ): \"\"\"Parameters related to a concrete door\"\"\" def __init__ ( self , sdk : ZKSDK , device_model : type ( ZKModel ), door_number : int ): super () . __init__ ( sdk , device_model ) self . door_number = door_number duress_password = _make_prop ( 'Door{self.door_number}ForcePassWord' , str , str , True , True , 'Duress password for door. Maximum length is 8 digits' , lambda x : x == '' or x . isdigit () and len ( x ) <= 8 ) emergency_password = _make_prop ( 'Door{self.door_number}SupperPassWord' , str , str , True , True , 'Emergency password for door. Maximum length is 8 digits' , lambda x : x == '' or x . isdigit () and len ( x ) <= 8 ) lock_on_close = _make_prop ( 'Door{self.door_number}CloseAndLock' , int , bool , True , True , 'Lock on door closing' ) sensor_type = _make_prop ( 'Door{self.door_number}SensorType' , int , SensorType , True , True , 'Lock on door closing' ) lock_driver_time = _make_prop ( 'Door{self.door_number}Drivertime' , int , int , True , True , 'Lock driver time length. 0 - Normal closed, 1-254 - Door opening duration, ' '255 - Normal open' , lambda x : 0 <= x <= 255 ) magnet_alarm_duration = _make_prop ( 'Door{self.door_number}Detectortime' , int , int , True , True , 'Timeout alarm duration of door magnet' , lambda x : 0 <= x <= 255 ) verify_mode = _make_prop ( 'Door{self.door_number}VerifyType' , int , VerifyMode , True , True , 'VerifyMode' ) multi_card_open = _make_prop ( 'Door{self.door_number}MultiCardOpenDoor' , int , bool , True , True , 'Open a door by several cards' ) first_card_open = _make_prop ( 'Door{self.door_number}FirstCardOpenDoor' , int , bool , True , True , 'Open a door by first card' ) active_time_tz = _make_prop ( 'Door{self.door_number}ValidTZ' , int , int , True , True , 'Active time segment for a door (0 - door is inactive)' ) open_time_tz = _make_prop ( 'Door{self.door_number}KeepOpenTimeZone' , int , int , True , True , 'Normal-open time segment of door (0 - not set)' ) punch_interval = _make_prop ( 'Door{self.door_number}Intertime' , int , int , True , True , 'Punch interval in seconds (0 - no interval)' ) cancel_open_day = _make_prop ( 'Door{self.door_number}CancelKeepOpenDay' , int , int , True , True , 'The date of Cancel Normal Open' ) Classes BaseParameters class BaseParameters ( sdk : pyzkaccess . sdk . ZKSDK , device_model : type ) View Source class BaseParameters: #: Size in bytes of c-string buffer which is used to accept #: text data from PULL SDK functions buffer_size = 4096 def __init__ ( self , sdk: ZKSDK , device_model: type ( ZKModel )): self . device_model = device_model self . _sdk = sdk Descendants pyzkaccess.param.DeviceParameters pyzkaccess.param.DoorParameters Class variables buffer_size DaylightSavingMomentMode1 class DaylightSavingMomentMode1 ( month , day , hour , minute ) Daylight saving parameters used in mode1 setting (all parameters in one request). See DLSTMode , DaylightSavingTime , StandardTime parameters in SDK docs View Source class DaylightSavingMomentMode1 : \"\"\"Daylight saving parameters used in mode1 setting (all parameters in one request). See `DLSTMode`, `DaylightSavingTime`, `StandardTime` parameters in SDK docs \"\"\" def __init__ ( self , month , day , hour , minute ): self . month = int ( month ) self . day = int ( day ) self . hour = int ( hour ) self . minute = int ( minute ) if not ( 1 <= self . month <= 12 ): raise ValueError ( 'Month must have value in range 1..12' ) if not ( 1 <= self . day <= 7 ): raise ValueError ( 'Day of week must have value in range 1..7' ) if not ( 0 <= self . hour <= 23 ): raise ValueError ( 'Hour must have value in range 0..23' ) if not ( 0 <= self . minute <= 59 ): raise ValueError ( 'Minute must have value in range 0..59' ) def __str__ ( self ): return '-' . join ( str ( x ) for x in ( self . month , self . day , self . hour , self . minute )) def __repr__ ( self ): pieces = 'month' , 'day' , 'hour' , 'minute' return '{}({})' . format ( self . __class__ . __name__ , ', ' . join ( '{}={}' . format ( x , getattr ( self , x )) for x in pieces )) DaylightSavingMomentMode2 class DaylightSavingMomentMode2 ( sdk : pyzkaccess . sdk . ZKSDK , is_daylight : bool , buffer_size : int ) Daylight saving parameters used in mode2 setting (each parameter in a separate request). See DLSTMode , WeekOfMonth* parameters in SDK docs View Source class DaylightSavingMomentMode2 : \"\"\"Daylight saving parameters used in mode2 setting (each parameter in a separate request). See `DLSTMode`, `WeekOfMonth*` parameters in SDK docs \"\"\" def __init__ ( self , sdk : ZKSDK , is_daylight : bool , buffer_size : int ): self . is_daylight = is_daylight self . buffer_size = buffer_size self . _sdk = sdk month = _make_daylight_prop ( 'WeekOfMonth1' , 'WeekOfMonth6' , 1 , 12 ) week_of_month = _make_daylight_prop ( 'WeekOfMonth2' , 'WeekOfMonth7' , 1 , 6 ) day_of_week = _make_daylight_prop ( 'WeekOfMonth3' , 'WeekOfMonth8' , 1 , 7 ) hour = _make_daylight_prop ( 'WeekOfMonth4' , 'WeekOfMonth9' , 0 , 23 ) minute = _make_daylight_prop ( 'WeekOfMonth5' , 'WeekOfMonth10' , 0 , 59 ) def __str__ ( self ): pieces = 'month' , 'week_of_month' , 'day_of_week' , 'hour' , 'minute' return '{}({})' . format ( self . __class__ . __name__ , ', ' . join ( '{}={}' . format ( x , getattr ( self , x )) for x in pieces )) def __repr__ ( self ): return self . __str__ () Class variables day_of_week hour minute month week_of_month Instance variables day_of_week hour minute month week_of_month DeviceParameters class DeviceParameters ( sdk : pyzkaccess . sdk . ZKSDK , device_model : type ) Parameters related to the whole device View Source class DeviceParameters ( BaseParameters ) : \"\"\"Parameters related to the whole device\"\"\" serial_number = _make_prop ( '~SerialNumber' , str , str , True , False , 'Serial number of device' ) lock_count = _make_prop ( 'LockCount' , int , int , True , False , 'Doors count' ) reader_count = _make_prop ( 'ReaderCount' , int , int , True , False , 'Readers count' ) aux_in_count = _make_prop ( 'AuxInCount' , int , int , True , False , 'Auxiliary inputs count' ) aux_out_count = _make_prop ( 'AuxOutCount' , int , int , True , False , 'Auxiliary output count' ) communication_password = _make_prop ( 'ComPwd' , str , str , True , True , 'Password to connect to a device. Maximum is 15 symbols' , lambda x : len ( x ) <= 15 ) ip_address = _make_prop ( 'IPAddress' , str , str , True , True , 'Device IPv4 address' , _check_ip ) netmask = _make_prop ( 'NetMask' , str , str , True , True , 'Subnet mask' , _check_ip ) gateway_ip_address = _make_prop ( 'GATEIPAddress' , str , str , True , True , 'Gateway IPv4 address' , _check_ip ) rs232_baud_rate = _make_prop ( 'RS232BaudRate' , int , int , True , True , 'RS232 baud rate' , lambda x : x > 0 ) watchdog_enabled = _make_prop ( 'WatchDog' , int , bool , True , True , 'MCU watchdog enabled' ) door4_to_door2 = _make_prop ( 'Door4ToDoor2' , int , bool , True , True , '4 doors turn 2 doors' ) backup_hour = _make_prop ( 'BackupTime' , int , int , True , True , 'The time (hour) of backup SD card. Number 1..24' , lambda x : 1 <= x <= 24 ) reboot = _make_prop ( 'Reboot' , int , bool , False , True , 'Reboot a device, accepts only True value' , lambda x : x is True ) reader_direction = _make_prop ( 'InBIOTowWay' , str , str , True , True , 'One-way/Two-way reader' ) fingerprint_version = _make_prop ( '~ZKFPVersion' , int , int , True , False , 'Device fingerprint identification version. Available values: 9, 10' , lambda x : x in ( 9 , 10 ) ) display_daylight_saving = _make_prop ( '~DSTF' , int , bool , True , True , 'Display parameters of daylight saving time' ) enable_daylight_saving = _make_prop ( 'DaylightSavingTimeOn' , int , bool , True , True , 'Enable time daylight saving' ) daylight_saving_mode = _make_prop ( 'DLSTMode' , int , int , True , True , 'Daylight saving mode, available values 0 (mode 1), 1 (mode 2)' , lambda x : x in ( 0 , 1 ) ) @property def anti_passback_rule ( self ) -> int : \"\"\"Passback rule for doors. Possible values depend on device model. Passback is when the second door can be opened only after the first door has opened, not otherwise. Or a door can be opened only by its readers from one side. \"\"\" res = self . _sdk . get_device_param ( parameters = ( 'AntiPassback' ,), buffer_size = self . buffer_size ) res = int ( res [ 'AntiPassback' ] ) if res not in self . device_model . anti_passback_rules : raise ValueError ( 'Value {} not in possible values for {}: {}' . format ( res , self . device_model . name , self . device_model . anti_passback_rules . keys () )) return self . device_model . anti_passback_rules [ res ] @anti_passback_rule . setter def anti_passback_rule ( self , value : int ) : if value not in self . device_model . anti_passback_rules : raise ValueError ( 'Value {} not in possible values for {}: {}' . format ( value , self . device_model . name , tuple ( self . device_model . anti_passback_rules . keys ()) )) self . _sdk . set_device_param ( parameters = { 'AntiPassback' : str ( value ) } ) @property def interlock ( self ) -> int : \"\"\"Interlock rule for doors. Possible values depend on device model. Interlock is when the second door can be opened only after the first door was opened and closed, and vice versa\"\"\" res = self . _sdk . get_device_param ( parameters = ( 'InterLock' ,), buffer_size = self . buffer_size ) if not res : return self . device_model . interlock_rules [ 0 ] res = int ( res [ 'InterLock' ] ) if res not in self . device_model . interlock_rules : raise ValueError ( 'Value {} not in possible values for {}: {}' . format ( res , self . device_model . name , self . device_model . interlock_rules . keys () )) return self . device_model . interlock_rules [ res ] @interlock . setter def interlock ( self , value : int ) : if value not in self . device_model . anti_passback_rules : raise ValueError ( 'Value {} not in possible values for {}: {}' . format ( value , self . device_model . name , self . device_model . anti_passback_rules . keys () )) self . _sdk . set_device_param ( parameters = { 'InterLock' : str ( value ) } ) @property def spring_daylight_time_mode1 ( self ) -> DaylightSavingMomentMode1 : \"\"\"Spring forward daylight saving time (mode 1) (read-write)\"\"\" res = self . _sdk . get_device_param ( parameters = ( 'DaylightSavingTime' ,), buffer_size = self . buffer_size ) res = [ int(x) for x in res['DaylightSavingTime' ] . split ( '-' ) ] # FIXME : extract bytes ? return DaylightSavingMomentMode1 ( month = res [ 0 ] , day = res [ 1 ] , hour = res [ 2 ] , minute = res [ 3 ] ) @spring_daylight_time_mode1 . setter def spring_daylight_time_mode1 ( self , value : DaylightSavingMomentMode1 ) : self . _sdk . set_device_param ( parameters = { 'DaylightSavingTime' : str ( value ) } ) @property def fall_daylight_time_mode1 ( self ) -> DaylightSavingMomentMode1 : \"\"\"Fall back daylight saving time (mode 1) (read-write)\"\"\" res = self . _sdk . get_device_param ( parameters = ( 'StandardTime' ,), buffer_size = self . buffer_size ) res = [ int(x) for x in res['StandardTime' ] . split ( '-' ) ] return DaylightSavingMomentMode1 ( month = res [ 0 ] , day = res [ 1 ] , hour = res [ 2 ] , minute = res [ 3 ] ) @fall_daylight_time_mode1 . setter def fall_daylight_time_mode1 ( self , value : DaylightSavingMomentMode1 ) : self . _sdk . set_device_param ( parameters = { 'StandardTime' : str ( value ) } ) @property def spring_daylight_time_mode2 ( self ) -> DaylightSavingMomentMode2 : \"\"\"Spring forward daylight saving time (mode 2) (read-write)\"\"\" return DaylightSavingMomentMode2 ( self . _sdk , True , self . buffer_size ) @spring_daylight_time_mode2 . setter def spring_daylight_time_mode2 ( self , value : DaylightSavingMomentMode2 ) : t = DaylightSavingMomentMode2 ( self . _sdk , True , self . buffer_size ) for attr in ( 'month' , 'week_of_month' , 'day_of_week' , 'hour' , 'minute' ) : setattr ( t , attr , getattr ( value , attr )) @property def fall_daylight_time_mode2 ( self ) -> DaylightSavingMomentMode2 : \"\"\"Fall back daylight saving time (mode 2) (read-write)\"\"\" return DaylightSavingMomentMode2 ( self . _sdk , False , self . buffer_size ) @fall_daylight_time_mode2 . setter def fall_daylight_time_mode2 ( self , value : DaylightSavingMomentMode2 ) : t = DaylightSavingMomentMode2 ( self . _sdk , False , self . buffer_size ) for attr in ( 'month' , 'week_of_month' , 'day_of_week' , 'hour' , 'minute' ) : setattr ( t , attr , getattr ( value , attr )) def _set_datetime ( self , value : datetime ) : # Amazing DIY ctime calculating from ZKTeco guys . # Simply put this is a count of seconds starting from # 2000 - 01 - 01 T00 : 00 : 00 without considering leap years / seconds # or different length of months ( always 31 day ) # See PULL SDK docs if value . year < 2000 : raise ValueError ( 'Minimum year is 2000' ) value = sum (( sum (( ( value . year - 2000 ) * 12 * 31 , ( value . month - 1 ) * 31 , ( value . day - 1 ) )) * 24 * 60 * 60 , value . hour * 60 * 60 , value . minute * 60 , value . second )) self . _sdk . set_device_param ( parameters = { 'DateTime' : str ( value ) } ) def _get_datetime ( self ) : res = self . _sdk . get_device_param ( parameters = ( 'DateTime' ,), buffer_size = self . buffer_size ) res = int ( res [ 'DateTime' ] ) dt = datetime ( year = res // 32140800 + 2000 , month = ( res // 2678400 ) % 12 + 1 , day = ( res // 86400 ) % 31 + 1 , hour = ( res // 3600 ) % 24 , minute = ( res // 60 ) % 60 , second = res % 60 ) return dt datetime = property ( _get_datetime , _set_datetime , None , 'Current datetime (read-write)' ) Ancestors (in MRO) pyzkaccess.param.BaseParameters Class variables aux_in_count aux_out_count backup_hour buffer_size communication_password datetime daylight_saving_mode display_daylight_saving door4_to_door2 enable_daylight_saving fingerprint_version gateway_ip_address ip_address lock_count netmask reader_count reader_direction reboot rs232_baud_rate serial_number watchdog_enabled Instance variables anti_passback_rule Passback rule for doors. Possible values depend on device model. Passback is when the second door can be opened only after the first door has opened, not otherwise. Or a door can be opened only by its readers from one side. aux_in_count Auxiliary inputs count (read-only) aux_out_count Auxiliary output count (read-only) backup_hour The time (hour) of backup SD card. Number 1..24 (read-write) communication_password Password to connect to a device. Maximum is 15 symbols (read-write) datetime Current datetime (read-write) daylight_saving_mode Daylight saving mode, available values 0 (mode 1), 1 (mode 2) (read-write) display_daylight_saving Display parameters of daylight saving time (read-write) door4_to_door2 4 doors turn 2 doors (read-write) enable_daylight_saving Enable time daylight saving (read-write) fall_daylight_time_mode1 Fall back daylight saving time (mode 1) (read-write) fall_daylight_time_mode2 Fall back daylight saving time (mode 2) (read-write) fingerprint_version Device fingerprint identification version. Available values: 9, 10 (read-only) gateway_ip_address Gateway IPv4 address (read-write) interlock Interlock rule for doors. Possible values depend on device model. Interlock is when the second door can be opened only after the first door was opened and closed, and vice versa ip_address Device IPv4 address (read-write) lock_count Doors count (read-only) netmask Subnet mask (read-write) reader_count Readers count (read-only) reader_direction One-way/Two-way reader (read-write) reboot Reboot a device, accepts only True value (write-only) rs232_baud_rate RS232 baud rate (read-write) serial_number Serial number of device (read-only) spring_daylight_time_mode1 Spring forward daylight saving time (mode 1) (read-write) spring_daylight_time_mode2 Spring forward daylight saving time (mode 2) (read-write) watchdog_enabled MCU watchdog enabled (read-write) DoorParameters class DoorParameters ( sdk : pyzkaccess . sdk . ZKSDK , device_model : type , door_number : int ) Parameters related to a concrete door View Source class DoorParameters ( BaseParameters ): \"\"\"Parameters related to a concrete door\"\"\" def __init__ ( self , sdk: ZKSDK , device_model: type ( ZKModel ), door_number: int ): super (). __init__ ( sdk , device_model ) self . door_number = door_number duress_password = _make_prop ( 'Door{self.door_number}ForcePassWord' , str , str , True , True , 'Duress password for door. Maximum length is 8 digits' , lambda x : x == '' or x . isdigit () and len ( x ) <= 8 ) emergency_password = _make_prop ( 'Door{self.door_number}SupperPassWord' , str , str , True , True , 'Emergency password for door. Maximum length is 8 digits' , lambda x : x == '' or x . isdigit () and len ( x ) <= 8 ) lock_on_close = _make_prop ( 'Door{self.door_number}CloseAndLock' , int , bool , True , True , 'Lock on door closing' ) sensor_type = _make_prop ( 'Door{self.door_number}SensorType' , int , SensorType , True , True , 'Lock on door closing' ) lock_driver_time = _make_prop ( 'Door{self.door_number}Drivertime' , int , int , True , True , 'Lock driver time length. 0 - Normal closed, 1-254 - Door opening duration, ' '255 - Normal open' , lambda x : 0 <= x <= 255 ) magnet_alarm_duration = _make_prop ( 'Door{self.door_number}Detectortime' , int , int , True , True , 'Timeout alarm duration of door magnet' , lambda x : 0 <= x <= 255 ) verify_mode = _make_prop ( 'Door{self.door_number}VerifyType' , int , VerifyMode , True , True , 'VerifyMode' ) multi_card_open = _make_prop ( 'Door{self.door_number}MultiCardOpenDoor' , int , bool , True , True , 'Open a door by several cards' ) first_card_open = _make_prop ( 'Door{self.door_number}FirstCardOpenDoor' , int , bool , True , True , 'Open a door by first card' ) active_time_tz = _make_prop ( 'Door{self.door_number}ValidTZ' , int , int , True , True , 'Active time segment for a door (0 - door is inactive)' ) open_time_tz = _make_prop ( 'Door{self.door_number}KeepOpenTimeZone' , int , int , True , True , 'Normal-open time segment of door (0 - not set)' ) punch_interval = _make_prop ( 'Door{self.door_number}Intertime' , int , int , True , True , 'Punch interval in seconds (0 - no interval)' ) cancel_open_day = _make_prop ( 'Door{self.door_number}CancelKeepOpenDay' , int , int , True , True , 'The date of Cancel Normal Open' ) Ancestors (in MRO) pyzkaccess.param.BaseParameters Class variables active_time_tz buffer_size cancel_open_day duress_password emergency_password first_card_open lock_driver_time lock_on_close magnet_alarm_duration multi_card_open open_time_tz punch_interval sensor_type verify_mode Instance variables active_time_tz Active time segment for a door (0 - door is inactive) (read-write) cancel_open_day The date of Cancel Normal Open (read-write) duress_password Duress password for door. Maximum length is 8 digits (read-write) emergency_password Emergency password for door. Maximum length is 8 digits (read-write) first_card_open Open a door by first card (read-write) lock_driver_time Lock driver time length. 0 - Normal closed, 1-254 - Door opening duration, 255 - Normal open (read-write) lock_on_close Lock on door closing (read-write) magnet_alarm_duration Timeout alarm duration of door magnet (read-write) multi_card_open Open a door by several cards (read-write) open_time_tz Normal-open time segment of door (0 - not set) (read-write) punch_interval Punch interval in seconds (0 - no interval) (read-write) sensor_type Lock on door closing (read-write) verify_mode VerifyMode (read-write)","title":"Param"},{"location":"reference/pyzkaccess/param/#module-pyzkaccessparam","text":"View Source __all__ = [ 'DaylightSavingMomentMode1' , 'DaylightSavingMomentMode2' , 'BaseParameters' , 'DeviceParameters' , 'DoorParameters' ] import re from datetime import datetime from enum import Enum from .device import ZKModel from .enum import SensorType , VerifyMode from .sdk import ZKSDK def _make_daylight_prop ( query_name_spring , query_name_fall , minimum , maximum ): def read ( self ): query = query_name_spring if self . is_daylight else query_name_fall res = self . _sdk . get_device_param ( parameters = ( query ,), buffer_size = self . buffer_size ) res = int ( res [ query ]) if not ( minimum <= res <= maximum ): raise ValueError ( 'Value {} is not in range {}..{}' . format ( res , minimum , maximum )) return res def write ( self , value ): query = query_name_spring if self . is_daylight else query_name_fall if not isinstance ( value , int ): raise TypeError ( 'Bad value type, should be int' ) if not ( minimum <= value <= maximum ): raise ValueError ( 'Value {} is not in range {}..{}' . format ( value , minimum , maximum )) self . _sdk . set_device_param ( parameters = { query : str ( value )}) return property ( fget = read , fset = write , fdel = None , doc = None ) class DaylightSavingMomentMode1 : \"\"\"Daylight saving parameters used in mode1 setting (all parameters in one request). See `DLSTMode`, `DaylightSavingTime`, `StandardTime` parameters in SDK docs \"\"\" def __init__ ( self , month , day , hour , minute ): self . month = int ( month ) self . day = int ( day ) self . hour = int ( hour ) self . minute = int ( minute ) if not ( 1 <= self . month <= 12 ): raise ValueError ( 'Month must have value in range 1..12' ) if not ( 1 <= self . day <= 7 ): raise ValueError ( 'Day of week must have value in range 1..7' ) if not ( 0 <= self . hour <= 23 ): raise ValueError ( 'Hour must have value in range 0..23' ) if not ( 0 <= self . minute <= 59 ): raise ValueError ( 'Minute must have value in range 0..59' ) def __str__ ( self ): return '-' . join ( str ( x ) for x in ( self . month , self . day , self . hour , self . minute )) def __repr__ ( self ): pieces = 'month' , 'day' , 'hour' , 'minute' return '{}({})' . format ( self . __class__ . __name__ , ', ' . join ( '{}={}' . format ( x , getattr ( self , x )) for x in pieces )) class DaylightSavingMomentMode2 : \"\"\"Daylight saving parameters used in mode2 setting (each parameter in a separate request). See `DLSTMode`, `WeekOfMonth*` parameters in SDK docs \"\"\" def __init__ ( self , sdk : ZKSDK , is_daylight : bool , buffer_size : int ): self . is_daylight = is_daylight self . buffer_size = buffer_size self . _sdk = sdk month = _make_daylight_prop ( 'WeekOfMonth1' , 'WeekOfMonth6' , 1 , 12 ) week_of_month = _make_daylight_prop ( 'WeekOfMonth2' , 'WeekOfMonth7' , 1 , 6 ) day_of_week = _make_daylight_prop ( 'WeekOfMonth3' , 'WeekOfMonth8' , 1 , 7 ) hour = _make_daylight_prop ( 'WeekOfMonth4' , 'WeekOfMonth9' , 0 , 23 ) minute = _make_daylight_prop ( 'WeekOfMonth5' , 'WeekOfMonth10' , 0 , 59 ) def __str__ ( self ): pieces = 'month' , 'week_of_month' , 'day_of_week' , 'hour' , 'minute' return '{}({})' . format ( self . __class__ . __name__ , ', ' . join ( '{}={}' . format ( x , getattr ( self , x )) for x in pieces )) def __repr__ ( self ): return self . __str__ () def _make_prop ( query_tpl : str , data_type , prop_type , readable = True , writable = True , doc = None , restriction_f = None ): assert readable or writable def read ( self ) -> prop_type : query = query_tpl . format ( self = self ) res = self . _sdk . get_device_param ( parameters = ( query ,), buffer_size = self . buffer_size ) res = res [ query ] res = data_type ( res ) if data_type != prop_type : res = prop_type ( res ) if not ( restriction_f is None or restriction_f ( res )): raise ValueError ( 'Value {} does not meet to parameter restrictions, ' 'see property docstring and SDK documentation' . format ( res )) return res def write ( self , value : prop_type ): # Check incoming value type. If prop_type is specified then # check against it, otherwise check against data_type if not isinstance ( value , prop_type ): raise TypeError ( 'Bad value type, should be {}' . format ( prop_type )) # Pass original value to restriction function if not ( restriction_f is None or restriction_f ( value )): raise ValueError ( 'Value {} does not meet to parameter restrictions, ' 'see property docstring and SDK documentation' . format ( value )) if issubclass ( prop_type , Enum ): value = value . value value = data_type ( value ) query = query_tpl . format ( self = self ) self . _sdk . set_device_param ( parameters = { query : str ( value )}) doc_readable_msg = '-' . join ( x for x in [ 'read' if readable else '' , 'write' if writable else '' , 'only' if readable != writable else '' ] if x ) return property ( fget = read if readable else None , fset = write if writable else None , fdel = None , doc = '{} ({})' . format ( doc , doc_readable_msg ) ) class BaseParameters : #: Size in bytes of c-string buffer which is used to accept #: text data from PULL SDK functions buffer_size = 4096 def __init__ ( self , sdk : ZKSDK , device_model : type ( ZKModel )): self . device_model = device_model self . _sdk = sdk def _check_ip ( addr : str ): return re . match ( r '^[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}$' , addr ) \\ and all ( 0 <= int ( x ) <= 255 for x in addr . split ( '.' )) class DeviceParameters ( BaseParameters ): \"\"\"Parameters related to the whole device\"\"\" serial_number = _make_prop ( '~SerialNumber' , str , str , True , False , 'Serial number of device' ) lock_count = _make_prop ( 'LockCount' , int , int , True , False , 'Doors count' ) reader_count = _make_prop ( 'ReaderCount' , int , int , True , False , 'Readers count' ) aux_in_count = _make_prop ( 'AuxInCount' , int , int , True , False , 'Auxiliary inputs count' ) aux_out_count = _make_prop ( 'AuxOutCount' , int , int , True , False , 'Auxiliary output count' ) communication_password = _make_prop ( 'ComPwd' , str , str , True , True , 'Password to connect to a device. Maximum is 15 symbols' , lambda x : len ( x ) <= 15 ) ip_address = _make_prop ( 'IPAddress' , str , str , True , True , 'Device IPv4 address' , _check_ip ) netmask = _make_prop ( 'NetMask' , str , str , True , True , 'Subnet mask' , _check_ip ) gateway_ip_address = _make_prop ( 'GATEIPAddress' , str , str , True , True , 'Gateway IPv4 address' , _check_ip ) rs232_baud_rate = _make_prop ( 'RS232BaudRate' , int , int , True , True , 'RS232 baud rate' , lambda x : x > 0 ) watchdog_enabled = _make_prop ( 'WatchDog' , int , bool , True , True , 'MCU watchdog enabled' ) door4_to_door2 = _make_prop ( 'Door4ToDoor2' , int , bool , True , True , '4 doors turn 2 doors' ) backup_hour = _make_prop ( 'BackupTime' , int , int , True , True , 'The time (hour) of backup SD card. Number 1..24' , lambda x : 1 <= x <= 24 ) reboot = _make_prop ( 'Reboot' , int , bool , False , True , 'Reboot a device, accepts only True value' , lambda x : x is True ) reader_direction = _make_prop ( 'InBIOTowWay' , str , str , True , True , 'One-way/Two-way reader' ) fingerprint_version = _make_prop ( '~ZKFPVersion' , int , int , True , False , 'Device fingerprint identification version. Available values: 9, 10' , lambda x : x in ( 9 , 10 ) ) display_daylight_saving = _make_prop ( '~DSTF' , int , bool , True , True , 'Display parameters of daylight saving time' ) enable_daylight_saving = _make_prop ( 'DaylightSavingTimeOn' , int , bool , True , True , 'Enable time daylight saving' ) daylight_saving_mode = _make_prop ( 'DLSTMode' , int , int , True , True , 'Daylight saving mode, available values 0 (mode 1), 1 (mode 2)' , lambda x : x in ( 0 , 1 ) ) @property def anti_passback_rule ( self ) -> int : \"\"\"Passback rule for doors. Possible values depend on device model. Passback is when the second door can be opened only after the first door has opened, not otherwise. Or a door can be opened only by its readers from one side. \"\"\" res = self . _sdk . get_device_param ( parameters = ( 'AntiPassback' ,), buffer_size = self . buffer_size ) res = int ( res [ 'AntiPassback' ]) if res not in self . device_model . anti_passback_rules : raise ValueError ( 'Value {} not in possible values for {}: {}' . format ( res , self . device_model . name , self . device_model . anti_passback_rules . keys () )) return self . device_model . anti_passback_rules [ res ] @anti_passback_rule.setter def anti_passback_rule ( self , value : int ): if value not in self . device_model . anti_passback_rules : raise ValueError ( 'Value {} not in possible values for {}: {}' . format ( value , self . device_model . name , tuple ( self . device_model . anti_passback_rules . keys ()) )) self . _sdk . set_device_param ( parameters = { 'AntiPassback' : str ( value )}) @property def interlock ( self ) -> int : \"\"\"Interlock rule for doors. Possible values depend on device model. Interlock is when the second door can be opened only after the first door was opened and closed, and vice versa\"\"\" res = self . _sdk . get_device_param ( parameters = ( 'InterLock' ,), buffer_size = self . buffer_size ) if not res : return self . device_model . interlock_rules [ 0 ] res = int ( res [ 'InterLock' ]) if res not in self . device_model . interlock_rules : raise ValueError ( 'Value {} not in possible values for {}: {}' . format ( res , self . device_model . name , self . device_model . interlock_rules . keys () )) return self . device_model . interlock_rules [ res ] @interlock.setter def interlock ( self , value : int ): if value not in self . device_model . anti_passback_rules : raise ValueError ( 'Value {} not in possible values for {}: {}' . format ( value , self . device_model . name , self . device_model . anti_passback_rules . keys () )) self . _sdk . set_device_param ( parameters = { 'InterLock' : str ( value )}) @property def spring_daylight_time_mode1 ( self ) -> DaylightSavingMomentMode1 : \"\"\"Spring forward daylight saving time (mode 1) (read-write)\"\"\" res = self . _sdk . get_device_param ( parameters = ( 'DaylightSavingTime' ,), buffer_size = self . buffer_size ) res = [ int ( x ) for x in res [ 'DaylightSavingTime' ] . split ( '-' )] # FIXME: extract bytes? return DaylightSavingMomentMode1 ( month = res [ 0 ], day = res [ 1 ], hour = res [ 2 ], minute = res [ 3 ]) @spring_daylight_time_mode1.setter def spring_daylight_time_mode1 ( self , value : DaylightSavingMomentMode1 ): self . _sdk . set_device_param ( parameters = { 'DaylightSavingTime' : str ( value )}) @property def fall_daylight_time_mode1 ( self ) -> DaylightSavingMomentMode1 : \"\"\"Fall back daylight saving time (mode 1) (read-write)\"\"\" res = self . _sdk . get_device_param ( parameters = ( 'StandardTime' ,), buffer_size = self . buffer_size ) res = [ int ( x ) for x in res [ 'StandardTime' ] . split ( '-' )] return DaylightSavingMomentMode1 ( month = res [ 0 ], day = res [ 1 ], hour = res [ 2 ], minute = res [ 3 ]) @fall_daylight_time_mode1.setter def fall_daylight_time_mode1 ( self , value : DaylightSavingMomentMode1 ): self . _sdk . set_device_param ( parameters = { 'StandardTime' : str ( value )}) @property def spring_daylight_time_mode2 ( self ) -> DaylightSavingMomentMode2 : \"\"\"Spring forward daylight saving time (mode 2) (read-write)\"\"\" return DaylightSavingMomentMode2 ( self . _sdk , True , self . buffer_size ) @spring_daylight_time_mode2.setter def spring_daylight_time_mode2 ( self , value : DaylightSavingMomentMode2 ): t = DaylightSavingMomentMode2 ( self . _sdk , True , self . buffer_size ) for attr in ( 'month' , 'week_of_month' , 'day_of_week' , 'hour' , 'minute' ): setattr ( t , attr , getattr ( value , attr )) @property def fall_daylight_time_mode2 ( self ) -> DaylightSavingMomentMode2 : \"\"\"Fall back daylight saving time (mode 2) (read-write)\"\"\" return DaylightSavingMomentMode2 ( self . _sdk , False , self . buffer_size ) @fall_daylight_time_mode2.setter def fall_daylight_time_mode2 ( self , value : DaylightSavingMomentMode2 ): t = DaylightSavingMomentMode2 ( self . _sdk , False , self . buffer_size ) for attr in ( 'month' , 'week_of_month' , 'day_of_week' , 'hour' , 'minute' ): setattr ( t , attr , getattr ( value , attr )) def _set_datetime ( self , value : datetime ): # Amazing DIY ctime calculating from ZKTeco guys. # Simply put this is a count of seconds starting from # 2000-01-01T00:00:00 without considering leap years/seconds # or different length of months (always 31 day) # See PULL SDK docs if value . year < 2000 : raise ValueError ( 'Minimum year is 2000' ) value = sum (( sum (( ( value . year - 2000 ) * 12 * 31 , ( value . month - 1 ) * 31 , ( value . day - 1 ) )) * 24 * 60 * 60 , value . hour * 60 * 60 , value . minute * 60 , value . second )) self . _sdk . set_device_param ( parameters = { 'DateTime' : str ( value )}) def _get_datetime ( self ): res = self . _sdk . get_device_param ( parameters = ( 'DateTime' ,), buffer_size = self . buffer_size ) res = int ( res [ 'DateTime' ]) dt = datetime ( year = res // 32140800 + 2000 , month = ( res // 2678400 ) % 12 + 1 , day = ( res // 86400 ) % 31 + 1 , hour = ( res // 3600 ) % 24 , minute = ( res // 60 ) % 60 , second = res % 60 ) return dt datetime = property ( _get_datetime , _set_datetime , None , 'Current datetime (read-write)' ) class DoorParameters ( BaseParameters ): \"\"\"Parameters related to a concrete door\"\"\" def __init__ ( self , sdk : ZKSDK , device_model : type ( ZKModel ), door_number : int ): super () . __init__ ( sdk , device_model ) self . door_number = door_number duress_password = _make_prop ( 'Door{self.door_number}ForcePassWord' , str , str , True , True , 'Duress password for door. Maximum length is 8 digits' , lambda x : x == '' or x . isdigit () and len ( x ) <= 8 ) emergency_password = _make_prop ( 'Door{self.door_number}SupperPassWord' , str , str , True , True , 'Emergency password for door. Maximum length is 8 digits' , lambda x : x == '' or x . isdigit () and len ( x ) <= 8 ) lock_on_close = _make_prop ( 'Door{self.door_number}CloseAndLock' , int , bool , True , True , 'Lock on door closing' ) sensor_type = _make_prop ( 'Door{self.door_number}SensorType' , int , SensorType , True , True , 'Lock on door closing' ) lock_driver_time = _make_prop ( 'Door{self.door_number}Drivertime' , int , int , True , True , 'Lock driver time length. 0 - Normal closed, 1-254 - Door opening duration, ' '255 - Normal open' , lambda x : 0 <= x <= 255 ) magnet_alarm_duration = _make_prop ( 'Door{self.door_number}Detectortime' , int , int , True , True , 'Timeout alarm duration of door magnet' , lambda x : 0 <= x <= 255 ) verify_mode = _make_prop ( 'Door{self.door_number}VerifyType' , int , VerifyMode , True , True , 'VerifyMode' ) multi_card_open = _make_prop ( 'Door{self.door_number}MultiCardOpenDoor' , int , bool , True , True , 'Open a door by several cards' ) first_card_open = _make_prop ( 'Door{self.door_number}FirstCardOpenDoor' , int , bool , True , True , 'Open a door by first card' ) active_time_tz = _make_prop ( 'Door{self.door_number}ValidTZ' , int , int , True , True , 'Active time segment for a door (0 - door is inactive)' ) open_time_tz = _make_prop ( 'Door{self.door_number}KeepOpenTimeZone' , int , int , True , True , 'Normal-open time segment of door (0 - not set)' ) punch_interval = _make_prop ( 'Door{self.door_number}Intertime' , int , int , True , True , 'Punch interval in seconds (0 - no interval)' ) cancel_open_day = _make_prop ( 'Door{self.door_number}CancelKeepOpenDay' , int , int , True , True , 'The date of Cancel Normal Open' )","title":"Module pyzkaccess.param"},{"location":"reference/pyzkaccess/param/#classes","text":"","title":"Classes"},{"location":"reference/pyzkaccess/param/#baseparameters","text":"class BaseParameters ( sdk : pyzkaccess . sdk . ZKSDK , device_model : type ) View Source class BaseParameters: #: Size in bytes of c-string buffer which is used to accept #: text data from PULL SDK functions buffer_size = 4096 def __init__ ( self , sdk: ZKSDK , device_model: type ( ZKModel )): self . device_model = device_model self . _sdk = sdk","title":"BaseParameters"},{"location":"reference/pyzkaccess/param/#descendants","text":"pyzkaccess.param.DeviceParameters pyzkaccess.param.DoorParameters","title":"Descendants"},{"location":"reference/pyzkaccess/param/#class-variables","text":"buffer_size","title":"Class variables"},{"location":"reference/pyzkaccess/param/#daylightsavingmomentmode1","text":"class DaylightSavingMomentMode1 ( month , day , hour , minute ) Daylight saving parameters used in mode1 setting (all parameters in one request). See DLSTMode , DaylightSavingTime , StandardTime parameters in SDK docs View Source class DaylightSavingMomentMode1 : \"\"\"Daylight saving parameters used in mode1 setting (all parameters in one request). See `DLSTMode`, `DaylightSavingTime`, `StandardTime` parameters in SDK docs \"\"\" def __init__ ( self , month , day , hour , minute ): self . month = int ( month ) self . day = int ( day ) self . hour = int ( hour ) self . minute = int ( minute ) if not ( 1 <= self . month <= 12 ): raise ValueError ( 'Month must have value in range 1..12' ) if not ( 1 <= self . day <= 7 ): raise ValueError ( 'Day of week must have value in range 1..7' ) if not ( 0 <= self . hour <= 23 ): raise ValueError ( 'Hour must have value in range 0..23' ) if not ( 0 <= self . minute <= 59 ): raise ValueError ( 'Minute must have value in range 0..59' ) def __str__ ( self ): return '-' . join ( str ( x ) for x in ( self . month , self . day , self . hour , self . minute )) def __repr__ ( self ): pieces = 'month' , 'day' , 'hour' , 'minute' return '{}({})' . format ( self . __class__ . __name__ , ', ' . join ( '{}={}' . format ( x , getattr ( self , x )) for x in pieces ))","title":"DaylightSavingMomentMode1"},{"location":"reference/pyzkaccess/param/#daylightsavingmomentmode2","text":"class DaylightSavingMomentMode2 ( sdk : pyzkaccess . sdk . ZKSDK , is_daylight : bool , buffer_size : int ) Daylight saving parameters used in mode2 setting (each parameter in a separate request). See DLSTMode , WeekOfMonth* parameters in SDK docs View Source class DaylightSavingMomentMode2 : \"\"\"Daylight saving parameters used in mode2 setting (each parameter in a separate request). See `DLSTMode`, `WeekOfMonth*` parameters in SDK docs \"\"\" def __init__ ( self , sdk : ZKSDK , is_daylight : bool , buffer_size : int ): self . is_daylight = is_daylight self . buffer_size = buffer_size self . _sdk = sdk month = _make_daylight_prop ( 'WeekOfMonth1' , 'WeekOfMonth6' , 1 , 12 ) week_of_month = _make_daylight_prop ( 'WeekOfMonth2' , 'WeekOfMonth7' , 1 , 6 ) day_of_week = _make_daylight_prop ( 'WeekOfMonth3' , 'WeekOfMonth8' , 1 , 7 ) hour = _make_daylight_prop ( 'WeekOfMonth4' , 'WeekOfMonth9' , 0 , 23 ) minute = _make_daylight_prop ( 'WeekOfMonth5' , 'WeekOfMonth10' , 0 , 59 ) def __str__ ( self ): pieces = 'month' , 'week_of_month' , 'day_of_week' , 'hour' , 'minute' return '{}({})' . format ( self . __class__ . __name__ , ', ' . join ( '{}={}' . format ( x , getattr ( self , x )) for x in pieces )) def __repr__ ( self ): return self . __str__ ()","title":"DaylightSavingMomentMode2"},{"location":"reference/pyzkaccess/param/#class-variables_1","text":"day_of_week hour minute month week_of_month","title":"Class variables"},{"location":"reference/pyzkaccess/param/#instance-variables","text":"day_of_week hour minute month week_of_month","title":"Instance variables"},{"location":"reference/pyzkaccess/param/#deviceparameters","text":"class DeviceParameters ( sdk : pyzkaccess . sdk . ZKSDK , device_model : type ) Parameters related to the whole device View Source class DeviceParameters ( BaseParameters ) : \"\"\"Parameters related to the whole device\"\"\" serial_number = _make_prop ( '~SerialNumber' , str , str , True , False , 'Serial number of device' ) lock_count = _make_prop ( 'LockCount' , int , int , True , False , 'Doors count' ) reader_count = _make_prop ( 'ReaderCount' , int , int , True , False , 'Readers count' ) aux_in_count = _make_prop ( 'AuxInCount' , int , int , True , False , 'Auxiliary inputs count' ) aux_out_count = _make_prop ( 'AuxOutCount' , int , int , True , False , 'Auxiliary output count' ) communication_password = _make_prop ( 'ComPwd' , str , str , True , True , 'Password to connect to a device. Maximum is 15 symbols' , lambda x : len ( x ) <= 15 ) ip_address = _make_prop ( 'IPAddress' , str , str , True , True , 'Device IPv4 address' , _check_ip ) netmask = _make_prop ( 'NetMask' , str , str , True , True , 'Subnet mask' , _check_ip ) gateway_ip_address = _make_prop ( 'GATEIPAddress' , str , str , True , True , 'Gateway IPv4 address' , _check_ip ) rs232_baud_rate = _make_prop ( 'RS232BaudRate' , int , int , True , True , 'RS232 baud rate' , lambda x : x > 0 ) watchdog_enabled = _make_prop ( 'WatchDog' , int , bool , True , True , 'MCU watchdog enabled' ) door4_to_door2 = _make_prop ( 'Door4ToDoor2' , int , bool , True , True , '4 doors turn 2 doors' ) backup_hour = _make_prop ( 'BackupTime' , int , int , True , True , 'The time (hour) of backup SD card. Number 1..24' , lambda x : 1 <= x <= 24 ) reboot = _make_prop ( 'Reboot' , int , bool , False , True , 'Reboot a device, accepts only True value' , lambda x : x is True ) reader_direction = _make_prop ( 'InBIOTowWay' , str , str , True , True , 'One-way/Two-way reader' ) fingerprint_version = _make_prop ( '~ZKFPVersion' , int , int , True , False , 'Device fingerprint identification version. Available values: 9, 10' , lambda x : x in ( 9 , 10 ) ) display_daylight_saving = _make_prop ( '~DSTF' , int , bool , True , True , 'Display parameters of daylight saving time' ) enable_daylight_saving = _make_prop ( 'DaylightSavingTimeOn' , int , bool , True , True , 'Enable time daylight saving' ) daylight_saving_mode = _make_prop ( 'DLSTMode' , int , int , True , True , 'Daylight saving mode, available values 0 (mode 1), 1 (mode 2)' , lambda x : x in ( 0 , 1 ) ) @property def anti_passback_rule ( self ) -> int : \"\"\"Passback rule for doors. Possible values depend on device model. Passback is when the second door can be opened only after the first door has opened, not otherwise. Or a door can be opened only by its readers from one side. \"\"\" res = self . _sdk . get_device_param ( parameters = ( 'AntiPassback' ,), buffer_size = self . buffer_size ) res = int ( res [ 'AntiPassback' ] ) if res not in self . device_model . anti_passback_rules : raise ValueError ( 'Value {} not in possible values for {}: {}' . format ( res , self . device_model . name , self . device_model . anti_passback_rules . keys () )) return self . device_model . anti_passback_rules [ res ] @anti_passback_rule . setter def anti_passback_rule ( self , value : int ) : if value not in self . device_model . anti_passback_rules : raise ValueError ( 'Value {} not in possible values for {}: {}' . format ( value , self . device_model . name , tuple ( self . device_model . anti_passback_rules . keys ()) )) self . _sdk . set_device_param ( parameters = { 'AntiPassback' : str ( value ) } ) @property def interlock ( self ) -> int : \"\"\"Interlock rule for doors. Possible values depend on device model. Interlock is when the second door can be opened only after the first door was opened and closed, and vice versa\"\"\" res = self . _sdk . get_device_param ( parameters = ( 'InterLock' ,), buffer_size = self . buffer_size ) if not res : return self . device_model . interlock_rules [ 0 ] res = int ( res [ 'InterLock' ] ) if res not in self . device_model . interlock_rules : raise ValueError ( 'Value {} not in possible values for {}: {}' . format ( res , self . device_model . name , self . device_model . interlock_rules . keys () )) return self . device_model . interlock_rules [ res ] @interlock . setter def interlock ( self , value : int ) : if value not in self . device_model . anti_passback_rules : raise ValueError ( 'Value {} not in possible values for {}: {}' . format ( value , self . device_model . name , self . device_model . anti_passback_rules . keys () )) self . _sdk . set_device_param ( parameters = { 'InterLock' : str ( value ) } ) @property def spring_daylight_time_mode1 ( self ) -> DaylightSavingMomentMode1 : \"\"\"Spring forward daylight saving time (mode 1) (read-write)\"\"\" res = self . _sdk . get_device_param ( parameters = ( 'DaylightSavingTime' ,), buffer_size = self . buffer_size ) res = [ int(x) for x in res['DaylightSavingTime' ] . split ( '-' ) ] # FIXME : extract bytes ? return DaylightSavingMomentMode1 ( month = res [ 0 ] , day = res [ 1 ] , hour = res [ 2 ] , minute = res [ 3 ] ) @spring_daylight_time_mode1 . setter def spring_daylight_time_mode1 ( self , value : DaylightSavingMomentMode1 ) : self . _sdk . set_device_param ( parameters = { 'DaylightSavingTime' : str ( value ) } ) @property def fall_daylight_time_mode1 ( self ) -> DaylightSavingMomentMode1 : \"\"\"Fall back daylight saving time (mode 1) (read-write)\"\"\" res = self . _sdk . get_device_param ( parameters = ( 'StandardTime' ,), buffer_size = self . buffer_size ) res = [ int(x) for x in res['StandardTime' ] . split ( '-' ) ] return DaylightSavingMomentMode1 ( month = res [ 0 ] , day = res [ 1 ] , hour = res [ 2 ] , minute = res [ 3 ] ) @fall_daylight_time_mode1 . setter def fall_daylight_time_mode1 ( self , value : DaylightSavingMomentMode1 ) : self . _sdk . set_device_param ( parameters = { 'StandardTime' : str ( value ) } ) @property def spring_daylight_time_mode2 ( self ) -> DaylightSavingMomentMode2 : \"\"\"Spring forward daylight saving time (mode 2) (read-write)\"\"\" return DaylightSavingMomentMode2 ( self . _sdk , True , self . buffer_size ) @spring_daylight_time_mode2 . setter def spring_daylight_time_mode2 ( self , value : DaylightSavingMomentMode2 ) : t = DaylightSavingMomentMode2 ( self . _sdk , True , self . buffer_size ) for attr in ( 'month' , 'week_of_month' , 'day_of_week' , 'hour' , 'minute' ) : setattr ( t , attr , getattr ( value , attr )) @property def fall_daylight_time_mode2 ( self ) -> DaylightSavingMomentMode2 : \"\"\"Fall back daylight saving time (mode 2) (read-write)\"\"\" return DaylightSavingMomentMode2 ( self . _sdk , False , self . buffer_size ) @fall_daylight_time_mode2 . setter def fall_daylight_time_mode2 ( self , value : DaylightSavingMomentMode2 ) : t = DaylightSavingMomentMode2 ( self . _sdk , False , self . buffer_size ) for attr in ( 'month' , 'week_of_month' , 'day_of_week' , 'hour' , 'minute' ) : setattr ( t , attr , getattr ( value , attr )) def _set_datetime ( self , value : datetime ) : # Amazing DIY ctime calculating from ZKTeco guys . # Simply put this is a count of seconds starting from # 2000 - 01 - 01 T00 : 00 : 00 without considering leap years / seconds # or different length of months ( always 31 day ) # See PULL SDK docs if value . year < 2000 : raise ValueError ( 'Minimum year is 2000' ) value = sum (( sum (( ( value . year - 2000 ) * 12 * 31 , ( value . month - 1 ) * 31 , ( value . day - 1 ) )) * 24 * 60 * 60 , value . hour * 60 * 60 , value . minute * 60 , value . second )) self . _sdk . set_device_param ( parameters = { 'DateTime' : str ( value ) } ) def _get_datetime ( self ) : res = self . _sdk . get_device_param ( parameters = ( 'DateTime' ,), buffer_size = self . buffer_size ) res = int ( res [ 'DateTime' ] ) dt = datetime ( year = res // 32140800 + 2000 , month = ( res // 2678400 ) % 12 + 1 , day = ( res // 86400 ) % 31 + 1 , hour = ( res // 3600 ) % 24 , minute = ( res // 60 ) % 60 , second = res % 60 ) return dt datetime = property ( _get_datetime , _set_datetime , None , 'Current datetime (read-write)' )","title":"DeviceParameters"},{"location":"reference/pyzkaccess/param/#ancestors-in-mro","text":"pyzkaccess.param.BaseParameters","title":"Ancestors (in MRO)"},{"location":"reference/pyzkaccess/param/#class-variables_2","text":"aux_in_count aux_out_count backup_hour buffer_size communication_password datetime daylight_saving_mode display_daylight_saving door4_to_door2 enable_daylight_saving fingerprint_version gateway_ip_address ip_address lock_count netmask reader_count reader_direction reboot rs232_baud_rate serial_number watchdog_enabled","title":"Class variables"},{"location":"reference/pyzkaccess/param/#instance-variables_1","text":"anti_passback_rule Passback rule for doors. Possible values depend on device model. Passback is when the second door can be opened only after the first door has opened, not otherwise. Or a door can be opened only by its readers from one side. aux_in_count Auxiliary inputs count (read-only) aux_out_count Auxiliary output count (read-only) backup_hour The time (hour) of backup SD card. Number 1..24 (read-write) communication_password Password to connect to a device. Maximum is 15 symbols (read-write) datetime Current datetime (read-write) daylight_saving_mode Daylight saving mode, available values 0 (mode 1), 1 (mode 2) (read-write) display_daylight_saving Display parameters of daylight saving time (read-write) door4_to_door2 4 doors turn 2 doors (read-write) enable_daylight_saving Enable time daylight saving (read-write) fall_daylight_time_mode1 Fall back daylight saving time (mode 1) (read-write) fall_daylight_time_mode2 Fall back daylight saving time (mode 2) (read-write) fingerprint_version Device fingerprint identification version. Available values: 9, 10 (read-only) gateway_ip_address Gateway IPv4 address (read-write) interlock Interlock rule for doors. Possible values depend on device model. Interlock is when the second door can be opened only after the first door was opened and closed, and vice versa ip_address Device IPv4 address (read-write) lock_count Doors count (read-only) netmask Subnet mask (read-write) reader_count Readers count (read-only) reader_direction One-way/Two-way reader (read-write) reboot Reboot a device, accepts only True value (write-only) rs232_baud_rate RS232 baud rate (read-write) serial_number Serial number of device (read-only) spring_daylight_time_mode1 Spring forward daylight saving time (mode 1) (read-write) spring_daylight_time_mode2 Spring forward daylight saving time (mode 2) (read-write) watchdog_enabled MCU watchdog enabled (read-write)","title":"Instance variables"},{"location":"reference/pyzkaccess/param/#doorparameters","text":"class DoorParameters ( sdk : pyzkaccess . sdk . ZKSDK , device_model : type , door_number : int ) Parameters related to a concrete door View Source class DoorParameters ( BaseParameters ): \"\"\"Parameters related to a concrete door\"\"\" def __init__ ( self , sdk: ZKSDK , device_model: type ( ZKModel ), door_number: int ): super (). __init__ ( sdk , device_model ) self . door_number = door_number duress_password = _make_prop ( 'Door{self.door_number}ForcePassWord' , str , str , True , True , 'Duress password for door. Maximum length is 8 digits' , lambda x : x == '' or x . isdigit () and len ( x ) <= 8 ) emergency_password = _make_prop ( 'Door{self.door_number}SupperPassWord' , str , str , True , True , 'Emergency password for door. Maximum length is 8 digits' , lambda x : x == '' or x . isdigit () and len ( x ) <= 8 ) lock_on_close = _make_prop ( 'Door{self.door_number}CloseAndLock' , int , bool , True , True , 'Lock on door closing' ) sensor_type = _make_prop ( 'Door{self.door_number}SensorType' , int , SensorType , True , True , 'Lock on door closing' ) lock_driver_time = _make_prop ( 'Door{self.door_number}Drivertime' , int , int , True , True , 'Lock driver time length. 0 - Normal closed, 1-254 - Door opening duration, ' '255 - Normal open' , lambda x : 0 <= x <= 255 ) magnet_alarm_duration = _make_prop ( 'Door{self.door_number}Detectortime' , int , int , True , True , 'Timeout alarm duration of door magnet' , lambda x : 0 <= x <= 255 ) verify_mode = _make_prop ( 'Door{self.door_number}VerifyType' , int , VerifyMode , True , True , 'VerifyMode' ) multi_card_open = _make_prop ( 'Door{self.door_number}MultiCardOpenDoor' , int , bool , True , True , 'Open a door by several cards' ) first_card_open = _make_prop ( 'Door{self.door_number}FirstCardOpenDoor' , int , bool , True , True , 'Open a door by first card' ) active_time_tz = _make_prop ( 'Door{self.door_number}ValidTZ' , int , int , True , True , 'Active time segment for a door (0 - door is inactive)' ) open_time_tz = _make_prop ( 'Door{self.door_number}KeepOpenTimeZone' , int , int , True , True , 'Normal-open time segment of door (0 - not set)' ) punch_interval = _make_prop ( 'Door{self.door_number}Intertime' , int , int , True , True , 'Punch interval in seconds (0 - no interval)' ) cancel_open_day = _make_prop ( 'Door{self.door_number}CancelKeepOpenDay' , int , int , True , True , 'The date of Cancel Normal Open' )","title":"DoorParameters"},{"location":"reference/pyzkaccess/param/#ancestors-in-mro_1","text":"pyzkaccess.param.BaseParameters","title":"Ancestors (in MRO)"},{"location":"reference/pyzkaccess/param/#class-variables_3","text":"active_time_tz buffer_size cancel_open_day duress_password emergency_password first_card_open lock_driver_time lock_on_close magnet_alarm_duration multi_card_open open_time_tz punch_interval sensor_type verify_mode","title":"Class variables"},{"location":"reference/pyzkaccess/param/#instance-variables_2","text":"active_time_tz Active time segment for a door (0 - door is inactive) (read-write) cancel_open_day The date of Cancel Normal Open (read-write) duress_password Duress password for door. Maximum length is 8 digits (read-write) emergency_password Emergency password for door. Maximum length is 8 digits (read-write) first_card_open Open a door by first card (read-write) lock_driver_time Lock driver time length. 0 - Normal closed, 1-254 - Door opening duration, 255 - Normal open (read-write) lock_on_close Lock on door closing (read-write) magnet_alarm_duration Timeout alarm duration of door magnet (read-write) multi_card_open Open a door by several cards (read-write) open_time_tz Normal-open time segment of door (0 - not set) (read-write) punch_interval Punch interval in seconds (0 - no interval) (read-write) sensor_type Lock on door closing (read-write) verify_mode VerifyMode (read-write)","title":"Instance variables"},{"location":"reference/pyzkaccess/pyzkaccess/","text":"Module pyzkaccess.pyzkaccess View Source __all__ = [ 'ZKAccess' ] import pyzkaccess.ctypes as ctypes from typing import Optional , Sequence from .aux_input import AuxInput , AuxInputList from .device import ZKModel , ZK400 , ZKDevice from .door import Door , DoorList from .enum import ControlOperation from .event import EventLog from .param import DeviceParameters , DoorParameters from .reader import Reader , ReaderList from .relay import Relay , RelayList import pyzkaccess.sdk class ZKAccess : \"\"\"Interface to a connected device\"\"\" #: Size in bytes of c-string buffer which is used to accept #: text data from PULL SDK functions buffer_size = 4096 def __init__ ( self , connstr : Optional [ str ] = None , device : Optional [ ZKDevice ] = None , device_model : type ( ZKModel ) = ZK400 , dllpath : str = 'plcommpro.dll' , log_capacity : Optional [ int ] = None ): \"\"\" :param connstr: Connection string. If given then we try to connect automatically to a device. Ex: 'protocol=TCP,ipaddress=192.168.1.201,port=4370,timeout=4000,passwd=' :param device: ZKDevice object to connect with. If given then we try to connect automatically to a device :param device_model: Device model. Default is C3-400 :param dllpath: Full path to plcommpro.dll :param log_capacity: Mixumum capacity of events log. By default size is not limited :raises ZKSDKError: On connection error \"\"\" self . connstr = connstr self . device_model = device_model self . sdk = pyzkaccess . sdk . ZKSDK ( dllpath ) self . _device = device self . _event_log = EventLog ( self . sdk , self . buffer_size , maxlen = log_capacity ) if device : if not connstr : self . connstr = \\ 'protocol=TCP,ipaddress={},port=4370,timeout=4000,passwd=' . format ( device . ip ) if not device_model : self . device_model = device . model if self . connstr : self . connect ( self . connstr ) @property def doors ( self ): \"\"\"Door object list, depends on device model. Door object incapsulates access to appropriate relays, reader, aux input, and also its events and parameters You can work with one object as with a slice. E.g. switch_on all relays of a door (`zk.doors[0].relays.switch_on(5)`) or of a slice (`zk.doors[:2].relays.switch_on(5)`) \"\"\" mdl = self . device_model readers = ( Reader ( self . sdk , self . _event_log , x ) for x in mdl . readers_def ) aux_inputs = ( AuxInput ( self . sdk , self . _event_log , n ) for n in mdl . aux_inputs_def ) relays = ( Relay ( self . sdk , g , n ) for g , n in zip ( mdl . groups_def , mdl . relays_def )) door_relays = ( RelayList ( self . sdk , relays = [ x for x in relays if x . number == door ]) for door in mdl . doors_def ) params = ( DoorParameters ( self . sdk , device_model = mdl , door_number = door ) for door in mdl . doors_def ) seq = zip ( mdl . doors_def , door_relays , readers , aux_inputs , params ) doors = [ Door ( self . sdk , self . _event_log , door , relays , reader , aux_input , params ) for door , relays , reader , aux_input , params in seq ] return DoorList ( self . sdk , event_log = self . _event_log , doors = doors ) @property def relays ( self ) -> 'RelayList' : \"\"\"Relay object list, depends on device model You can work with one object as with a slice. E.g. switch on a single relay (`zk.relays[0].switch_on(5)`) or a slice (`zk.relays[:2].switch_on(5)`) \"\"\" mdl = self . device_model relays = [ Relay ( self . sdk , g , n ) for g , n in zip ( mdl . groups_def , mdl . relays_def )] return RelayList ( sdk = self . sdk , relays = relays ) @property def readers ( self ) -> 'ReaderList' : \"\"\"Reader object list, depends on device model You can work with one object as with a slice. E.g. get events of single reader (`zk.readers[0].events`) or a slice (`zk.readers[:2].events`) \"\"\" readers = [ Reader ( self . sdk , self . _event_log , x ) for x in self . device_model . readers_def ] return ReaderList ( sdk = self . sdk , event_log = self . _event_log , readers = readers ) @property def aux_inputs ( self ): \"\"\"Aux input object list, depends on device model You can work with one object as with a slice. E.g. get events of single input (`zk.aux_inputs[0].events`) or a slice (`zk.aux_inputs[:2].events`) \"\"\" mdl = self . device_model aux_inputs = [ AuxInput ( self . sdk , self . _event_log , n ) for n in mdl . aux_inputs_def ] return AuxInputList ( self . sdk , event_log = self . _event_log , aux_inputs = aux_inputs ) @property def events ( self ) -> 'EventLog' : \"\"\"Device event log. This property returns all records pulled from a device. Keep in mind that log is not filled out automatically and should be refreshed periodically by hand using `refresh()` method. This is because working with ZKAccess has request-response nature and cannot up a tunnel which may be used to feed events. But you can use `poll()` method which awaits new events from a device and return them if any. Doors, inputs, readers have their own `events` property. Those properties just filters the same event log instance and return entries related to requested object. \"\"\" return self . _event_log @property def parameters ( self ): \"\"\"Parameters related to the whole device such as datetime, connection settings and so forth. Door-specific parameters are accesible by `doors` property. \"\"\" return DeviceParameters ( self . sdk , self . device_model ) @property def device ( self ) -> ZKDevice : \"\"\"Current device object we connected with\"\"\" if self . _device : return self . _device if not self . sdk . is_connected : raise RuntimeError ( 'Cannot create device while not connected' ) return ZKDevice ( mac = None , ip = self . parameters . ip_address , serial_number = self . parameters . serial_number , model = self . device_model , version = None ) @property def dll_object ( self ) -> ctypes . WinDLL : \"\"\"DLL object (`ctypes.WinDLL`). Read only.\"\"\" return self . sdk . dll @property def handle ( self ) -> Optional [ int ]: \"\"\"Device handle. `None` if there is no active connection. Read only. \"\"\" return self . sdk . handle @classmethod def search_devices ( cls , broadcast_address : str = '255.255.255.255' , dllpath : str = 'plcommpro.dll' ) -> Sequence [ ZKDevice ]: \"\"\" Classmethod which scans an Ethernet network with given broadcast address and returns all found ZK devices. Please keep in mind that process sends broadcast packets to perform a search which are not passed through routers. So you'll get results only for local network segment. The default broadcast address may not work in some cases, so it's better to specify your local network broadcast address. For example, if your ip is `192.168.22.123` and netmask is `255.255.255.0` or `/24` so address will be `192.168.22.255`. Returned objects can be used as `device=` parameter in constructor. :param broadcast_address: your local segment broadcast address as string. Default is '255.255.255.255' :param dllpath: path to a PULL SDK DLL. Default: 'plcommpro.dll' :return: iterable of found ZKDevice \"\"\" sdk = pyzkaccess . sdk . ZKSDK ( dllpath ) devices = sdk . search_device ( broadcast_address , cls . buffer_size ) return tuple ( ZKDevice ( line ) for line in devices ) def connect ( self , connstr : str ) -> None : \"\"\" Connect to a device using connection string, ex: 'protocol=TCP,ipaddress=192.168.1.201,port=4370,timeout=4000,passwd=' :param connstr: device connection string :return: \"\"\" if self . sdk . is_connected : if connstr != self . connstr : raise ValueError ( 'Please disconnect before connecting with other connstr' ) return self . connstr = connstr self . sdk . connect ( connstr ) def disconnect ( self ) -> None : \"\"\"Disconnect from a device\"\"\" self . sdk . disconnect () def restart ( self ) -> None : \"\"\"Restart a device\"\"\" self . sdk . control_device ( ControlOperation . restart . value , 0 , 0 , 0 , 0 ) def __enter__ ( self ): return self def __exit__ ( self , exc_type , exc_val , exc_tb ): if self . sdk . is_connected : self . disconnect () Classes ZKAccess class ZKAccess ( connstr : Union [ str , NoneType ] = None , device : Union [ pyzkaccess . device . ZKDevice , NoneType ] = None , device_model : type = < class ' pyzkaccess . device . ZK400 '>, dllpath : str = 'plcommpro.dll' , log_capacity : Union [ int , NoneType ] = None ) Interface to a connected device View Source class ZKAccess : \"\"\"Interface to a connected device\"\"\" #: Size in bytes of c - string buffer which is used to accept #: text data from PULL SDK functions buffer_size = 4096 def __init__ ( self , connstr : Optional [ str ] = None , device : Optional [ ZKDevice ] = None , device_model : type ( ZKModel ) = ZK400 , dllpath : str = 'plcommpro.dll' , log_capacity : Optional [ int ] = None ) : \"\"\" :param connstr: Connection string. If given then we try to connect automatically to a device. Ex: 'protocol=TCP,ipaddress=192.168.1.201,port=4370,timeout=4000,passwd=' :param device: ZKDevice object to connect with. If given then we try to connect automatically to a device :param device_model: Device model. Default is C3-400 :param dllpath: Full path to plcommpro.dll :param log_capacity: Mixumum capacity of events log. By default size is not limited :raises ZKSDKError: On connection error \"\"\" self . connstr = connstr self . device_model = device_model self . sdk = pyzkaccess . sdk . ZKSDK ( dllpath ) self . _device = device self . _event_log = EventLog ( self . sdk , self . buffer_size , maxlen = log_capacity ) if device : if not connstr : self . connstr = \\ 'protocol=TCP,ipaddress={},port=4370,timeout=4000,passwd=' . format ( device . ip ) if not device_model : self . device_model = device . model if self . connstr : self . connect ( self . connstr ) @property def doors ( self ) : \"\"\"Door object list, depends on device model. Door object incapsulates access to appropriate relays, reader, aux input, and also its events and parameters You can work with one object as with a slice. E.g. switch_on all relays of a door (`zk.doors[0].relays.switch_on(5)`) or of a slice (`zk.doors[:2].relays.switch_on(5)`) \"\"\" mdl = self . device_model readers = ( Reader ( self . sdk , self . _event_log , x ) for x in mdl . readers_def ) aux_inputs = ( AuxInput ( self . sdk , self . _event_log , n ) for n in mdl . aux_inputs_def ) relays = ( Relay ( self . sdk , g , n ) for g , n in zip ( mdl . groups_def , mdl . relays_def )) door_relays = ( RelayList ( self . sdk , relays =[ x for x in relays if x.number == door ] ) for door in mdl . doors_def ) params = ( DoorParameters ( self . sdk , device_model = mdl , door_number = door ) for door in mdl . doors_def ) seq = zip ( mdl . doors_def , door_relays , readers , aux_inputs , params ) doors = [ Door(self.sdk, self._event_log, door, relays, reader, aux_input, params) for door, relays, reader, aux_input, params in seq ] return DoorList ( self . sdk , event_log = self . _event_log , doors = doors ) @property def relays ( self ) -> 'RelayList' : \"\"\"Relay object list, depends on device model You can work with one object as with a slice. E.g. switch on a single relay (`zk.relays[0].switch_on(5)`) or a slice (`zk.relays[:2].switch_on(5)`) \"\"\" mdl = self . device_model relays = [ Relay(self.sdk, g, n) for g, n in zip(mdl.groups_def, mdl.relays_def) ] return RelayList ( sdk = self . sdk , relays = relays ) @property def readers ( self ) -> 'ReaderList' : \"\"\"Reader object list, depends on device model You can work with one object as with a slice. E.g. get events of single reader (`zk.readers[0].events`) or a slice (`zk.readers[:2].events`) \"\"\" readers = [ Reader(self.sdk, self._event_log, x) for x in self.device_model.readers_def ] return ReaderList ( sdk = self . sdk , event_log = self . _event_log , readers = readers ) @property def aux_inputs ( self ) : \"\"\"Aux input object list, depends on device model You can work with one object as with a slice. E.g. get events of single input (`zk.aux_inputs[0].events`) or a slice (`zk.aux_inputs[:2].events`) \"\"\" mdl = self . device_model aux_inputs = [ AuxInput(self.sdk, self._event_log, n) for n in mdl.aux_inputs_def ] return AuxInputList ( self . sdk , event_log = self . _event_log , aux_inputs = aux_inputs ) @property def events ( self ) -> 'EventLog' : \"\"\"Device event log. This property returns all records pulled from a device. Keep in mind that log is not filled out automatically and should be refreshed periodically by hand using `refresh()` method. This is because working with ZKAccess has request-response nature and cannot up a tunnel which may be used to feed events. But you can use `poll()` method which awaits new events from a device and return them if any. Doors, inputs, readers have their own `events` property. Those properties just filters the same event log instance and return entries related to requested object. \"\"\" return self . _event_log @property def parameters ( self ) : \"\"\"Parameters related to the whole device such as datetime, connection settings and so forth. Door-specific parameters are accesible by `doors` property. \"\"\" return DeviceParameters ( self . sdk , self . device_model ) @property def device ( self ) -> ZKDevice : \"\"\"Current device object we connected with\"\"\" if self . _device : return self . _device if not self . sdk . is_connected : raise RuntimeError ( 'Cannot create device while not connected' ) return ZKDevice ( mac = None , ip = self . parameters . ip_address , serial_number = self . parameters . serial_number , model = self . device_model , version = None ) @property def dll_object ( self ) -> ctypes . WinDLL : \"\"\"DLL object (`ctypes.WinDLL`). Read only.\"\"\" return self . sdk . dll @property def handle ( self ) -> Optional [ int ] : \"\"\"Device handle. `None` if there is no active connection. Read only. \"\"\" return self . sdk . handle @classmethod def search_devices ( cls , broadcast_address : str = '255.255.255.255' , dllpath : str = 'plcommpro.dll' ) -> Sequence [ ZKDevice ] : \"\"\" Classmethod which scans an Ethernet network with given broadcast address and returns all found ZK devices. Please keep in mind that process sends broadcast packets to perform a search which are not passed through routers. So you'll get results only for local network segment. The default broadcast address may not work in some cases, so it's better to specify your local network broadcast address. For example, if your ip is `192.168.22.123` and netmask is `255.255.255.0` or `/24` so address will be `192.168.22.255`. Returned objects can be used as `device=` parameter in constructor. :param broadcast_address: your local segment broadcast address as string. Default is '255.255.255.255' :param dllpath: path to a PULL SDK DLL. Default: 'plcommpro.dll' :return: iterable of found ZKDevice \"\"\" sdk = pyzkaccess . sdk . ZKSDK ( dllpath ) devices = sdk . search_device ( broadcast_address , cls . buffer_size ) return tuple ( ZKDevice ( line ) for line in devices ) def connect ( self , connstr : str ) -> None : \"\"\" Connect to a device using connection string, ex: 'protocol=TCP,ipaddress=192.168.1.201,port=4370,timeout=4000,passwd=' :param connstr: device connection string :return: \"\"\" if self . sdk . is_connected : if connstr != self . connstr : raise ValueError ( 'Please disconnect before connecting with other connstr' ) return self . connstr = connstr self . sdk . connect ( connstr ) def disconnect ( self ) -> None : \"\"\"Disconnect from a device\"\"\" self . sdk . disconnect () def restart ( self ) -> None : \"\"\"Restart a device\"\"\" self . sdk . control_device ( ControlOperation . restart . value , 0 , 0 , 0 , 0 ) def __enter__ ( self ) : return self def __exit__ ( self , exc_type , exc_val , exc_tb ) : if self . sdk . is_connected : self . disconnect () Class variables buffer_size Static methods search_devices def search_devices ( broadcast_address : str = '255.255.255.255' , dllpath : str = 'plcommpro.dll' ) -> Sequence [ pyzkaccess . device . ZKDevice ] Classmethod which scans an Ethernet network with given broadcast address and returns all found ZK devices. Please keep in mind that process sends broadcast packets to perform a search which are not passed through routers. So you'll get results only for local network segment. The default broadcast address may not work in some cases, so it's better to specify your local network broadcast address. For example, if your ip is 192.168.22.123 and netmask is 255.255.255.0 or /24 so address will be 192.168.22.255 . Returned objects can be used as device= parameter in constructor. :param broadcast_address: your local segment broadcast address as string. Default is '255.255.255.255' :param dllpath: path to a PULL SDK DLL. Default: 'plcommpro.dll' :return: iterable of found ZKDevice View Source @classmethod def search_devices ( cls , broadcast_address : str = '255.255.255.255' , dllpath : str = 'plcommpro.dll' ) -> Sequence [ ZKDevice ] : \"\"\" Classmethod which scans an Ethernet network with given broadcast address and returns all found ZK devices. Please keep in mind that process sends broadcast packets to perform a search which are not passed through routers. So you'll get results only for local network segment. The default broadcast address may not work in some cases, so it's better to specify your local network broadcast address. For example, if your ip is `192.168.22.123` and netmask is `255.255.255.0` or `/24` so address will be `192.168.22.255`. Returned objects can be used as `device=` parameter in constructor. :param broadcast_address: your local segment broadcast address as string. Default is '255.255.255.255' :param dllpath: path to a PULL SDK DLL. Default: 'plcommpro.dll' :return: iterable of found ZKDevice \"\"\" sdk = pyzkaccess . sdk . ZKSDK ( dllpath ) devices = sdk . search_device ( broadcast_address , cls . buffer_size ) return tuple ( ZKDevice ( line ) for line in devices ) Instance variables aux_inputs Aux input object list, depends on device model You can work with one object as with a slice. E.g. get events of single input ( zk.aux_inputs[0].events ) or a slice ( zk.aux_inputs[:2].events ) device Current device object we connected with dll_object DLL object ( ctypes.WinDLL ). Read only. doors Door object list, depends on device model. Door object incapsulates access to appropriate relays, reader, aux input, and also its events and parameters You can work with one object as with a slice. E.g. switch_on all relays of a door ( zk.doors[0].relays.switch_on(5) ) or of a slice ( zk.doors[:2].relays.switch_on(5) ) events Device event log. This property returns all records pulled from a device. Keep in mind that log is not filled out automatically and should be refreshed periodically by hand using refresh() method. This is because working with ZKAccess has request-response nature and cannot up a tunnel which may be used to feed events. But you can use poll() method which awaits new events from a device and return them if any. Doors, inputs, readers have their own events property. Those properties just filters the same event log instance and return entries related to requested object. handle Device handle. None if there is no active connection. Read only. parameters Parameters related to the whole device such as datetime, connection settings and so forth. Door-specific parameters are accesible by doors property. readers Reader object list, depends on device model You can work with one object as with a slice. E.g. get events of single reader ( zk.readers[0].events ) or a slice ( zk.readers[:2].events ) relays Relay object list, depends on device model You can work with one object as with a slice. E.g. switch on a single relay ( zk.relays[0].switch_on(5) ) or a slice ( zk.relays[:2].switch_on(5) ) Methods connect def connect ( self , connstr : str ) -> None Connect to a device using connection string, ex: 'protocol=TCP,ipaddress=192.168.1.201,port=4370,timeout=4000,passwd=' :param connstr: device connection string :return: View Source def connect ( self , connstr : str ) -> None : \"\"\" Connect to a device using connection string, ex: 'protocol=TCP,ipaddress=192.168.1.201,port=4370,timeout=4000,passwd=' :param connstr: device connection string :return: \"\"\" if self . sdk . is_connected : if connstr != self . connstr : raise ValueError ( 'Please disconnect before connecting with other connstr' ) return self . connstr = connstr self . sdk . connect ( connstr ) disconnect def disconnect ( self ) -> None Disconnect from a device View Source def disconnect ( self ) -> None : \"\"\"Disconnect from a device\"\"\" self . sdk . disconnect () restart def restart ( self ) -> None Restart a device View Source def restart ( self ) -> None : \"\"\"Restart a device\"\"\" self . sdk . control_device ( ControlOperation . restart . value , 0 , 0 , 0 , 0 )","title":"Pyzkaccess"},{"location":"reference/pyzkaccess/pyzkaccess/#module-pyzkaccesspyzkaccess","text":"View Source __all__ = [ 'ZKAccess' ] import pyzkaccess.ctypes as ctypes from typing import Optional , Sequence from .aux_input import AuxInput , AuxInputList from .device import ZKModel , ZK400 , ZKDevice from .door import Door , DoorList from .enum import ControlOperation from .event import EventLog from .param import DeviceParameters , DoorParameters from .reader import Reader , ReaderList from .relay import Relay , RelayList import pyzkaccess.sdk class ZKAccess : \"\"\"Interface to a connected device\"\"\" #: Size in bytes of c-string buffer which is used to accept #: text data from PULL SDK functions buffer_size = 4096 def __init__ ( self , connstr : Optional [ str ] = None , device : Optional [ ZKDevice ] = None , device_model : type ( ZKModel ) = ZK400 , dllpath : str = 'plcommpro.dll' , log_capacity : Optional [ int ] = None ): \"\"\" :param connstr: Connection string. If given then we try to connect automatically to a device. Ex: 'protocol=TCP,ipaddress=192.168.1.201,port=4370,timeout=4000,passwd=' :param device: ZKDevice object to connect with. If given then we try to connect automatically to a device :param device_model: Device model. Default is C3-400 :param dllpath: Full path to plcommpro.dll :param log_capacity: Mixumum capacity of events log. By default size is not limited :raises ZKSDKError: On connection error \"\"\" self . connstr = connstr self . device_model = device_model self . sdk = pyzkaccess . sdk . ZKSDK ( dllpath ) self . _device = device self . _event_log = EventLog ( self . sdk , self . buffer_size , maxlen = log_capacity ) if device : if not connstr : self . connstr = \\ 'protocol=TCP,ipaddress={},port=4370,timeout=4000,passwd=' . format ( device . ip ) if not device_model : self . device_model = device . model if self . connstr : self . connect ( self . connstr ) @property def doors ( self ): \"\"\"Door object list, depends on device model. Door object incapsulates access to appropriate relays, reader, aux input, and also its events and parameters You can work with one object as with a slice. E.g. switch_on all relays of a door (`zk.doors[0].relays.switch_on(5)`) or of a slice (`zk.doors[:2].relays.switch_on(5)`) \"\"\" mdl = self . device_model readers = ( Reader ( self . sdk , self . _event_log , x ) for x in mdl . readers_def ) aux_inputs = ( AuxInput ( self . sdk , self . _event_log , n ) for n in mdl . aux_inputs_def ) relays = ( Relay ( self . sdk , g , n ) for g , n in zip ( mdl . groups_def , mdl . relays_def )) door_relays = ( RelayList ( self . sdk , relays = [ x for x in relays if x . number == door ]) for door in mdl . doors_def ) params = ( DoorParameters ( self . sdk , device_model = mdl , door_number = door ) for door in mdl . doors_def ) seq = zip ( mdl . doors_def , door_relays , readers , aux_inputs , params ) doors = [ Door ( self . sdk , self . _event_log , door , relays , reader , aux_input , params ) for door , relays , reader , aux_input , params in seq ] return DoorList ( self . sdk , event_log = self . _event_log , doors = doors ) @property def relays ( self ) -> 'RelayList' : \"\"\"Relay object list, depends on device model You can work with one object as with a slice. E.g. switch on a single relay (`zk.relays[0].switch_on(5)`) or a slice (`zk.relays[:2].switch_on(5)`) \"\"\" mdl = self . device_model relays = [ Relay ( self . sdk , g , n ) for g , n in zip ( mdl . groups_def , mdl . relays_def )] return RelayList ( sdk = self . sdk , relays = relays ) @property def readers ( self ) -> 'ReaderList' : \"\"\"Reader object list, depends on device model You can work with one object as with a slice. E.g. get events of single reader (`zk.readers[0].events`) or a slice (`zk.readers[:2].events`) \"\"\" readers = [ Reader ( self . sdk , self . _event_log , x ) for x in self . device_model . readers_def ] return ReaderList ( sdk = self . sdk , event_log = self . _event_log , readers = readers ) @property def aux_inputs ( self ): \"\"\"Aux input object list, depends on device model You can work with one object as with a slice. E.g. get events of single input (`zk.aux_inputs[0].events`) or a slice (`zk.aux_inputs[:2].events`) \"\"\" mdl = self . device_model aux_inputs = [ AuxInput ( self . sdk , self . _event_log , n ) for n in mdl . aux_inputs_def ] return AuxInputList ( self . sdk , event_log = self . _event_log , aux_inputs = aux_inputs ) @property def events ( self ) -> 'EventLog' : \"\"\"Device event log. This property returns all records pulled from a device. Keep in mind that log is not filled out automatically and should be refreshed periodically by hand using `refresh()` method. This is because working with ZKAccess has request-response nature and cannot up a tunnel which may be used to feed events. But you can use `poll()` method which awaits new events from a device and return them if any. Doors, inputs, readers have their own `events` property. Those properties just filters the same event log instance and return entries related to requested object. \"\"\" return self . _event_log @property def parameters ( self ): \"\"\"Parameters related to the whole device such as datetime, connection settings and so forth. Door-specific parameters are accesible by `doors` property. \"\"\" return DeviceParameters ( self . sdk , self . device_model ) @property def device ( self ) -> ZKDevice : \"\"\"Current device object we connected with\"\"\" if self . _device : return self . _device if not self . sdk . is_connected : raise RuntimeError ( 'Cannot create device while not connected' ) return ZKDevice ( mac = None , ip = self . parameters . ip_address , serial_number = self . parameters . serial_number , model = self . device_model , version = None ) @property def dll_object ( self ) -> ctypes . WinDLL : \"\"\"DLL object (`ctypes.WinDLL`). Read only.\"\"\" return self . sdk . dll @property def handle ( self ) -> Optional [ int ]: \"\"\"Device handle. `None` if there is no active connection. Read only. \"\"\" return self . sdk . handle @classmethod def search_devices ( cls , broadcast_address : str = '255.255.255.255' , dllpath : str = 'plcommpro.dll' ) -> Sequence [ ZKDevice ]: \"\"\" Classmethod which scans an Ethernet network with given broadcast address and returns all found ZK devices. Please keep in mind that process sends broadcast packets to perform a search which are not passed through routers. So you'll get results only for local network segment. The default broadcast address may not work in some cases, so it's better to specify your local network broadcast address. For example, if your ip is `192.168.22.123` and netmask is `255.255.255.0` or `/24` so address will be `192.168.22.255`. Returned objects can be used as `device=` parameter in constructor. :param broadcast_address: your local segment broadcast address as string. Default is '255.255.255.255' :param dllpath: path to a PULL SDK DLL. Default: 'plcommpro.dll' :return: iterable of found ZKDevice \"\"\" sdk = pyzkaccess . sdk . ZKSDK ( dllpath ) devices = sdk . search_device ( broadcast_address , cls . buffer_size ) return tuple ( ZKDevice ( line ) for line in devices ) def connect ( self , connstr : str ) -> None : \"\"\" Connect to a device using connection string, ex: 'protocol=TCP,ipaddress=192.168.1.201,port=4370,timeout=4000,passwd=' :param connstr: device connection string :return: \"\"\" if self . sdk . is_connected : if connstr != self . connstr : raise ValueError ( 'Please disconnect before connecting with other connstr' ) return self . connstr = connstr self . sdk . connect ( connstr ) def disconnect ( self ) -> None : \"\"\"Disconnect from a device\"\"\" self . sdk . disconnect () def restart ( self ) -> None : \"\"\"Restart a device\"\"\" self . sdk . control_device ( ControlOperation . restart . value , 0 , 0 , 0 , 0 ) def __enter__ ( self ): return self def __exit__ ( self , exc_type , exc_val , exc_tb ): if self . sdk . is_connected : self . disconnect ()","title":"Module pyzkaccess.pyzkaccess"},{"location":"reference/pyzkaccess/pyzkaccess/#classes","text":"","title":"Classes"},{"location":"reference/pyzkaccess/pyzkaccess/#zkaccess","text":"class ZKAccess ( connstr : Union [ str , NoneType ] = None , device : Union [ pyzkaccess . device . ZKDevice , NoneType ] = None , device_model : type = < class ' pyzkaccess . device . ZK400 '>, dllpath : str = 'plcommpro.dll' , log_capacity : Union [ int , NoneType ] = None ) Interface to a connected device View Source class ZKAccess : \"\"\"Interface to a connected device\"\"\" #: Size in bytes of c - string buffer which is used to accept #: text data from PULL SDK functions buffer_size = 4096 def __init__ ( self , connstr : Optional [ str ] = None , device : Optional [ ZKDevice ] = None , device_model : type ( ZKModel ) = ZK400 , dllpath : str = 'plcommpro.dll' , log_capacity : Optional [ int ] = None ) : \"\"\" :param connstr: Connection string. If given then we try to connect automatically to a device. Ex: 'protocol=TCP,ipaddress=192.168.1.201,port=4370,timeout=4000,passwd=' :param device: ZKDevice object to connect with. If given then we try to connect automatically to a device :param device_model: Device model. Default is C3-400 :param dllpath: Full path to plcommpro.dll :param log_capacity: Mixumum capacity of events log. By default size is not limited :raises ZKSDKError: On connection error \"\"\" self . connstr = connstr self . device_model = device_model self . sdk = pyzkaccess . sdk . ZKSDK ( dllpath ) self . _device = device self . _event_log = EventLog ( self . sdk , self . buffer_size , maxlen = log_capacity ) if device : if not connstr : self . connstr = \\ 'protocol=TCP,ipaddress={},port=4370,timeout=4000,passwd=' . format ( device . ip ) if not device_model : self . device_model = device . model if self . connstr : self . connect ( self . connstr ) @property def doors ( self ) : \"\"\"Door object list, depends on device model. Door object incapsulates access to appropriate relays, reader, aux input, and also its events and parameters You can work with one object as with a slice. E.g. switch_on all relays of a door (`zk.doors[0].relays.switch_on(5)`) or of a slice (`zk.doors[:2].relays.switch_on(5)`) \"\"\" mdl = self . device_model readers = ( Reader ( self . sdk , self . _event_log , x ) for x in mdl . readers_def ) aux_inputs = ( AuxInput ( self . sdk , self . _event_log , n ) for n in mdl . aux_inputs_def ) relays = ( Relay ( self . sdk , g , n ) for g , n in zip ( mdl . groups_def , mdl . relays_def )) door_relays = ( RelayList ( self . sdk , relays =[ x for x in relays if x.number == door ] ) for door in mdl . doors_def ) params = ( DoorParameters ( self . sdk , device_model = mdl , door_number = door ) for door in mdl . doors_def ) seq = zip ( mdl . doors_def , door_relays , readers , aux_inputs , params ) doors = [ Door(self.sdk, self._event_log, door, relays, reader, aux_input, params) for door, relays, reader, aux_input, params in seq ] return DoorList ( self . sdk , event_log = self . _event_log , doors = doors ) @property def relays ( self ) -> 'RelayList' : \"\"\"Relay object list, depends on device model You can work with one object as with a slice. E.g. switch on a single relay (`zk.relays[0].switch_on(5)`) or a slice (`zk.relays[:2].switch_on(5)`) \"\"\" mdl = self . device_model relays = [ Relay(self.sdk, g, n) for g, n in zip(mdl.groups_def, mdl.relays_def) ] return RelayList ( sdk = self . sdk , relays = relays ) @property def readers ( self ) -> 'ReaderList' : \"\"\"Reader object list, depends on device model You can work with one object as with a slice. E.g. get events of single reader (`zk.readers[0].events`) or a slice (`zk.readers[:2].events`) \"\"\" readers = [ Reader(self.sdk, self._event_log, x) for x in self.device_model.readers_def ] return ReaderList ( sdk = self . sdk , event_log = self . _event_log , readers = readers ) @property def aux_inputs ( self ) : \"\"\"Aux input object list, depends on device model You can work with one object as with a slice. E.g. get events of single input (`zk.aux_inputs[0].events`) or a slice (`zk.aux_inputs[:2].events`) \"\"\" mdl = self . device_model aux_inputs = [ AuxInput(self.sdk, self._event_log, n) for n in mdl.aux_inputs_def ] return AuxInputList ( self . sdk , event_log = self . _event_log , aux_inputs = aux_inputs ) @property def events ( self ) -> 'EventLog' : \"\"\"Device event log. This property returns all records pulled from a device. Keep in mind that log is not filled out automatically and should be refreshed periodically by hand using `refresh()` method. This is because working with ZKAccess has request-response nature and cannot up a tunnel which may be used to feed events. But you can use `poll()` method which awaits new events from a device and return them if any. Doors, inputs, readers have their own `events` property. Those properties just filters the same event log instance and return entries related to requested object. \"\"\" return self . _event_log @property def parameters ( self ) : \"\"\"Parameters related to the whole device such as datetime, connection settings and so forth. Door-specific parameters are accesible by `doors` property. \"\"\" return DeviceParameters ( self . sdk , self . device_model ) @property def device ( self ) -> ZKDevice : \"\"\"Current device object we connected with\"\"\" if self . _device : return self . _device if not self . sdk . is_connected : raise RuntimeError ( 'Cannot create device while not connected' ) return ZKDevice ( mac = None , ip = self . parameters . ip_address , serial_number = self . parameters . serial_number , model = self . device_model , version = None ) @property def dll_object ( self ) -> ctypes . WinDLL : \"\"\"DLL object (`ctypes.WinDLL`). Read only.\"\"\" return self . sdk . dll @property def handle ( self ) -> Optional [ int ] : \"\"\"Device handle. `None` if there is no active connection. Read only. \"\"\" return self . sdk . handle @classmethod def search_devices ( cls , broadcast_address : str = '255.255.255.255' , dllpath : str = 'plcommpro.dll' ) -> Sequence [ ZKDevice ] : \"\"\" Classmethod which scans an Ethernet network with given broadcast address and returns all found ZK devices. Please keep in mind that process sends broadcast packets to perform a search which are not passed through routers. So you'll get results only for local network segment. The default broadcast address may not work in some cases, so it's better to specify your local network broadcast address. For example, if your ip is `192.168.22.123` and netmask is `255.255.255.0` or `/24` so address will be `192.168.22.255`. Returned objects can be used as `device=` parameter in constructor. :param broadcast_address: your local segment broadcast address as string. Default is '255.255.255.255' :param dllpath: path to a PULL SDK DLL. Default: 'plcommpro.dll' :return: iterable of found ZKDevice \"\"\" sdk = pyzkaccess . sdk . ZKSDK ( dllpath ) devices = sdk . search_device ( broadcast_address , cls . buffer_size ) return tuple ( ZKDevice ( line ) for line in devices ) def connect ( self , connstr : str ) -> None : \"\"\" Connect to a device using connection string, ex: 'protocol=TCP,ipaddress=192.168.1.201,port=4370,timeout=4000,passwd=' :param connstr: device connection string :return: \"\"\" if self . sdk . is_connected : if connstr != self . connstr : raise ValueError ( 'Please disconnect before connecting with other connstr' ) return self . connstr = connstr self . sdk . connect ( connstr ) def disconnect ( self ) -> None : \"\"\"Disconnect from a device\"\"\" self . sdk . disconnect () def restart ( self ) -> None : \"\"\"Restart a device\"\"\" self . sdk . control_device ( ControlOperation . restart . value , 0 , 0 , 0 , 0 ) def __enter__ ( self ) : return self def __exit__ ( self , exc_type , exc_val , exc_tb ) : if self . sdk . is_connected : self . disconnect ()","title":"ZKAccess"},{"location":"reference/pyzkaccess/pyzkaccess/#class-variables","text":"buffer_size","title":"Class variables"},{"location":"reference/pyzkaccess/pyzkaccess/#static-methods","text":"","title":"Static methods"},{"location":"reference/pyzkaccess/pyzkaccess/#search_devices","text":"def search_devices ( broadcast_address : str = '255.255.255.255' , dllpath : str = 'plcommpro.dll' ) -> Sequence [ pyzkaccess . device . ZKDevice ] Classmethod which scans an Ethernet network with given broadcast address and returns all found ZK devices. Please keep in mind that process sends broadcast packets to perform a search which are not passed through routers. So you'll get results only for local network segment. The default broadcast address may not work in some cases, so it's better to specify your local network broadcast address. For example, if your ip is 192.168.22.123 and netmask is 255.255.255.0 or /24 so address will be 192.168.22.255 . Returned objects can be used as device= parameter in constructor. :param broadcast_address: your local segment broadcast address as string. Default is '255.255.255.255' :param dllpath: path to a PULL SDK DLL. Default: 'plcommpro.dll' :return: iterable of found ZKDevice View Source @classmethod def search_devices ( cls , broadcast_address : str = '255.255.255.255' , dllpath : str = 'plcommpro.dll' ) -> Sequence [ ZKDevice ] : \"\"\" Classmethod which scans an Ethernet network with given broadcast address and returns all found ZK devices. Please keep in mind that process sends broadcast packets to perform a search which are not passed through routers. So you'll get results only for local network segment. The default broadcast address may not work in some cases, so it's better to specify your local network broadcast address. For example, if your ip is `192.168.22.123` and netmask is `255.255.255.0` or `/24` so address will be `192.168.22.255`. Returned objects can be used as `device=` parameter in constructor. :param broadcast_address: your local segment broadcast address as string. Default is '255.255.255.255' :param dllpath: path to a PULL SDK DLL. Default: 'plcommpro.dll' :return: iterable of found ZKDevice \"\"\" sdk = pyzkaccess . sdk . ZKSDK ( dllpath ) devices = sdk . search_device ( broadcast_address , cls . buffer_size ) return tuple ( ZKDevice ( line ) for line in devices )","title":"search_devices"},{"location":"reference/pyzkaccess/pyzkaccess/#instance-variables","text":"aux_inputs Aux input object list, depends on device model You can work with one object as with a slice. E.g. get events of single input ( zk.aux_inputs[0].events ) or a slice ( zk.aux_inputs[:2].events ) device Current device object we connected with dll_object DLL object ( ctypes.WinDLL ). Read only. doors Door object list, depends on device model. Door object incapsulates access to appropriate relays, reader, aux input, and also its events and parameters You can work with one object as with a slice. E.g. switch_on all relays of a door ( zk.doors[0].relays.switch_on(5) ) or of a slice ( zk.doors[:2].relays.switch_on(5) ) events Device event log. This property returns all records pulled from a device. Keep in mind that log is not filled out automatically and should be refreshed periodically by hand using refresh() method. This is because working with ZKAccess has request-response nature and cannot up a tunnel which may be used to feed events. But you can use poll() method which awaits new events from a device and return them if any. Doors, inputs, readers have their own events property. Those properties just filters the same event log instance and return entries related to requested object. handle Device handle. None if there is no active connection. Read only. parameters Parameters related to the whole device such as datetime, connection settings and so forth. Door-specific parameters are accesible by doors property. readers Reader object list, depends on device model You can work with one object as with a slice. E.g. get events of single reader ( zk.readers[0].events ) or a slice ( zk.readers[:2].events ) relays Relay object list, depends on device model You can work with one object as with a slice. E.g. switch on a single relay ( zk.relays[0].switch_on(5) ) or a slice ( zk.relays[:2].switch_on(5) )","title":"Instance variables"},{"location":"reference/pyzkaccess/pyzkaccess/#methods","text":"","title":"Methods"},{"location":"reference/pyzkaccess/pyzkaccess/#connect","text":"def connect ( self , connstr : str ) -> None Connect to a device using connection string, ex: 'protocol=TCP,ipaddress=192.168.1.201,port=4370,timeout=4000,passwd=' :param connstr: device connection string :return: View Source def connect ( self , connstr : str ) -> None : \"\"\" Connect to a device using connection string, ex: 'protocol=TCP,ipaddress=192.168.1.201,port=4370,timeout=4000,passwd=' :param connstr: device connection string :return: \"\"\" if self . sdk . is_connected : if connstr != self . connstr : raise ValueError ( 'Please disconnect before connecting with other connstr' ) return self . connstr = connstr self . sdk . connect ( connstr )","title":"connect"},{"location":"reference/pyzkaccess/pyzkaccess/#disconnect","text":"def disconnect ( self ) -> None Disconnect from a device View Source def disconnect ( self ) -> None : \"\"\"Disconnect from a device\"\"\" self . sdk . disconnect ()","title":"disconnect"},{"location":"reference/pyzkaccess/pyzkaccess/#restart","text":"def restart ( self ) -> None Restart a device View Source def restart ( self ) -> None : \"\"\"Restart a device\"\"\" self . sdk . control_device ( ControlOperation . restart . value , 0 , 0 , 0 , 0 )","title":"restart"},{"location":"reference/pyzkaccess/reader/","text":"Module pyzkaccess.reader View Source __all__ = [ 'Reader' , 'ReaderList' ] from abc import ABCMeta , abstractmethod from typing import Iterable , Union from .common import UserTuple from .event import EventLog from .sdk import ZKSDK class ReaderInterface ( metaclass = ABCMeta ): #: Event types which are fully or partially related to a reader #: See EVENT_TYPES enum and SDK docs event_types = frozenset (( 0 , 1 , 2 , 3 , 4 , 10 , 11 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 26 , 27 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 , 101 , 103 , 203 )) @property def events ( self ) -> EventLog : \"\"\"Event log of current reader\"\"\" return self . _specific_event_log () @abstractmethod def _specific_event_log ( self ) -> EventLog : pass class Reader ( ReaderInterface ): \"\"\"Concrete reader\"\"\" def __init__ ( self , sdk : ZKSDK , event_log : EventLog , number : int ): self . number = number self . _sdk = sdk self . _event_log = event_log def _specific_event_log ( self ) -> EventLog : return self . _event_log . only ( door = [ self . number ], event_type = self . event_types ) def __eq__ ( self , other ): if isinstance ( other , Reader ): return self . number == other . number and self . _sdk is other . _sdk return False def __ne__ ( self , other ): return not self . __eq__ ( other ) def __str__ ( self ): return \"Reader[{}]\" . format ( self . number ) def __repr__ ( self ): return self . __str__ () class ReaderList ( ReaderInterface , UserTuple ): \"\"\"Collection of reader objects which is used to perform group operations over multiple readers \"\"\" def __init__ ( self , sdk : ZKSDK , event_log : EventLog , readers : Iterable [ Reader ] = ()): super () . __init__ ( readers ) self . _sdk = sdk self . _event_log = event_log def __getitem__ ( self , item : Union [ int , slice ]) -> Union [ Reader , 'ReaderList' ]: readers = self . data [ item ] if isinstance ( item , slice ): return self . __class__ ( self . _sdk , self . _event_log , readers = readers ) else : return readers def _specific_event_log ( self ) -> EventLog : doors = set ( x . number for x in self ) return self . _event_log . only ( door = doors , event_type = self . event_types ) Classes Reader class Reader ( sdk : pyzkaccess . sdk . ZKSDK , event_log : pyzkaccess . event . EventLog , number : int ) Concrete reader View Source class Reader ( ReaderInterface ): \"\"\"Concrete reader\"\"\" def __init__ ( self , sdk: ZKSDK , event_log: EventLog , number: int ): self . number = number self . _sdk = sdk self . _event_log = event_log def _specific_event_log ( self ) -> EventLog: return self . _event_log . only ( door =[ self . number ], event_type = self . event_types ) def __eq__ ( self , other ): if isinstance ( other , Reader ): return self . number == other . number and self . _sdk is other . _sdk return False def __ne__ ( self , other ): return not self . __eq__ ( other ) def __str__ ( self ): return \"Reader[{}]\" . format ( self . number ) def __repr__ ( self ): return self . __str__ () Ancestors (in MRO) pyzkaccess.reader.ReaderInterface Class variables event_types Instance variables events Event log of current reader ReaderList class ReaderList ( sdk : pyzkaccess . sdk . ZKSDK , event_log : pyzkaccess . event . EventLog , readers : Iterable [ pyzkaccess . reader . Reader ] = () ) Collection of reader objects which is used to perform group operations over multiple readers View Source class ReaderList ( ReaderInterface , UserTuple ) : \"\"\"Collection of reader objects which is used to perform group operations over multiple readers \"\"\" def __init__ ( self , sdk : ZKSDK , event_log : EventLog , readers : Iterable [ Reader ] = ()) : super (). __init__ ( readers ) self . _sdk = sdk self . _event_log = event_log def __getitem__ ( self , item : Union [ int, slice ] ) -> Union [ Reader, 'ReaderList' ] : readers = self . data [ item ] if isinstance ( item , slice ) : return self . __class__ ( self . _sdk , self . _event_log , readers = readers ) else : return readers def _specific_event_log ( self ) -> EventLog : doors = set ( x . number for x in self ) return self . _event_log . only ( door = doors , event_type = self . event_types ) Ancestors (in MRO) pyzkaccess.reader.ReaderInterface pyzkaccess.common.UserTuple Class variables event_types Instance variables events Event log of current reader Methods copy def copy ( self ) View Source def copy(self): return self.__class__(self) count def count ( self , item ) View Source def count(self, item): return self.data.count(item) index def index ( self , item , * args ) View Source def index(self, item, *args): return self.data.index(item, *args)","title":"Reader"},{"location":"reference/pyzkaccess/reader/#module-pyzkaccessreader","text":"View Source __all__ = [ 'Reader' , 'ReaderList' ] from abc import ABCMeta , abstractmethod from typing import Iterable , Union from .common import UserTuple from .event import EventLog from .sdk import ZKSDK class ReaderInterface ( metaclass = ABCMeta ): #: Event types which are fully or partially related to a reader #: See EVENT_TYPES enum and SDK docs event_types = frozenset (( 0 , 1 , 2 , 3 , 4 , 10 , 11 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 26 , 27 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 , 101 , 103 , 203 )) @property def events ( self ) -> EventLog : \"\"\"Event log of current reader\"\"\" return self . _specific_event_log () @abstractmethod def _specific_event_log ( self ) -> EventLog : pass class Reader ( ReaderInterface ): \"\"\"Concrete reader\"\"\" def __init__ ( self , sdk : ZKSDK , event_log : EventLog , number : int ): self . number = number self . _sdk = sdk self . _event_log = event_log def _specific_event_log ( self ) -> EventLog : return self . _event_log . only ( door = [ self . number ], event_type = self . event_types ) def __eq__ ( self , other ): if isinstance ( other , Reader ): return self . number == other . number and self . _sdk is other . _sdk return False def __ne__ ( self , other ): return not self . __eq__ ( other ) def __str__ ( self ): return \"Reader[{}]\" . format ( self . number ) def __repr__ ( self ): return self . __str__ () class ReaderList ( ReaderInterface , UserTuple ): \"\"\"Collection of reader objects which is used to perform group operations over multiple readers \"\"\" def __init__ ( self , sdk : ZKSDK , event_log : EventLog , readers : Iterable [ Reader ] = ()): super () . __init__ ( readers ) self . _sdk = sdk self . _event_log = event_log def __getitem__ ( self , item : Union [ int , slice ]) -> Union [ Reader , 'ReaderList' ]: readers = self . data [ item ] if isinstance ( item , slice ): return self . __class__ ( self . _sdk , self . _event_log , readers = readers ) else : return readers def _specific_event_log ( self ) -> EventLog : doors = set ( x . number for x in self ) return self . _event_log . only ( door = doors , event_type = self . event_types )","title":"Module pyzkaccess.reader"},{"location":"reference/pyzkaccess/reader/#classes","text":"","title":"Classes"},{"location":"reference/pyzkaccess/reader/#reader","text":"class Reader ( sdk : pyzkaccess . sdk . ZKSDK , event_log : pyzkaccess . event . EventLog , number : int ) Concrete reader View Source class Reader ( ReaderInterface ): \"\"\"Concrete reader\"\"\" def __init__ ( self , sdk: ZKSDK , event_log: EventLog , number: int ): self . number = number self . _sdk = sdk self . _event_log = event_log def _specific_event_log ( self ) -> EventLog: return self . _event_log . only ( door =[ self . number ], event_type = self . event_types ) def __eq__ ( self , other ): if isinstance ( other , Reader ): return self . number == other . number and self . _sdk is other . _sdk return False def __ne__ ( self , other ): return not self . __eq__ ( other ) def __str__ ( self ): return \"Reader[{}]\" . format ( self . number ) def __repr__ ( self ): return self . __str__ ()","title":"Reader"},{"location":"reference/pyzkaccess/reader/#ancestors-in-mro","text":"pyzkaccess.reader.ReaderInterface","title":"Ancestors (in MRO)"},{"location":"reference/pyzkaccess/reader/#class-variables","text":"event_types","title":"Class variables"},{"location":"reference/pyzkaccess/reader/#instance-variables","text":"events Event log of current reader","title":"Instance variables"},{"location":"reference/pyzkaccess/reader/#readerlist","text":"class ReaderList ( sdk : pyzkaccess . sdk . ZKSDK , event_log : pyzkaccess . event . EventLog , readers : Iterable [ pyzkaccess . reader . Reader ] = () ) Collection of reader objects which is used to perform group operations over multiple readers View Source class ReaderList ( ReaderInterface , UserTuple ) : \"\"\"Collection of reader objects which is used to perform group operations over multiple readers \"\"\" def __init__ ( self , sdk : ZKSDK , event_log : EventLog , readers : Iterable [ Reader ] = ()) : super (). __init__ ( readers ) self . _sdk = sdk self . _event_log = event_log def __getitem__ ( self , item : Union [ int, slice ] ) -> Union [ Reader, 'ReaderList' ] : readers = self . data [ item ] if isinstance ( item , slice ) : return self . __class__ ( self . _sdk , self . _event_log , readers = readers ) else : return readers def _specific_event_log ( self ) -> EventLog : doors = set ( x . number for x in self ) return self . _event_log . only ( door = doors , event_type = self . event_types )","title":"ReaderList"},{"location":"reference/pyzkaccess/reader/#ancestors-in-mro_1","text":"pyzkaccess.reader.ReaderInterface pyzkaccess.common.UserTuple","title":"Ancestors (in MRO)"},{"location":"reference/pyzkaccess/reader/#class-variables_1","text":"event_types","title":"Class variables"},{"location":"reference/pyzkaccess/reader/#instance-variables_1","text":"events Event log of current reader","title":"Instance variables"},{"location":"reference/pyzkaccess/reader/#methods","text":"","title":"Methods"},{"location":"reference/pyzkaccess/reader/#copy","text":"def copy ( self ) View Source def copy(self): return self.__class__(self)","title":"copy"},{"location":"reference/pyzkaccess/reader/#count","text":"def count ( self , item ) View Source def count(self, item): return self.data.count(item)","title":"count"},{"location":"reference/pyzkaccess/reader/#index","text":"def index ( self , item , * args ) View Source def index(self, item, *args): return self.data.index(item, *args)","title":"index"},{"location":"reference/pyzkaccess/relay/","text":"Module pyzkaccess.relay View Source __all__ = [ 'Relay' , 'RelayList' ] from abc import ABCMeta , abstractmethod from typing import Iterable , Union from .common import UserTuple from .enum import RelayGroup , ControlOperation from .sdk import ZKSDK class RelayInterface ( metaclass = ABCMeta ): @abstractmethod def switch_on ( self , timeout : int ) -> None : \"\"\" Switch on a relay for the given time. If a relay is already switched on then its timeout will be refreshed :param timeout: timeout in seconds, Number between 0 and 255 :return: \"\"\" pass class Relay ( RelayInterface ): \"\"\"Concrete relay\"\"\" def __init__ ( self , sdk : ZKSDK , group : RelayGroup , number : int ): self . group = group self . number = number self . _sdk = sdk def switch_on ( self , timeout : int ) -> None : \"\"\" Switch on a relay for the given time. If a relay is already switched on then its timeout will be refreshed :param timeout: Timeout in seconds while relay will be enabled. Number between 0 and 255 :return: \"\"\" if timeout < 0 or timeout > 255 : raise ValueError ( \"Timeout must be in range 0..255, got {}\" . format ( timeout )) self . _sdk . control_device ( ControlOperation . output . value , self . number , self . group . value , timeout , 0 ) def __eq__ ( self , other ): if isinstance ( other , Relay ): return self . number == other . number \\ and self . group == other . group \\ and self . _sdk is other . _sdk return False def __ne__ ( self , other ): return not self . __eq__ ( other ) def __str__ ( self ): return \"Relay.{}({})\" . format ( self . group . name , self . number ) def __repr__ ( self ): return \"Relay(RelayGroup.{}, {})\" . format ( self . group . name , self . number ) class RelayList ( RelayInterface , UserTuple ): \"\"\"Collection of relay objects which is used to perform group operations over multiple relays \"\"\" def __init__ ( self , sdk : ZKSDK , relays : Iterable [ Relay ] = ()): super () . __init__ ( relays ) self . _sdk = sdk def switch_on ( self , timeout : int ) -> None : \"\"\" Switch on all relays in set for a given time :param timeout: Timeout in seconds while relay will be enabled. Number between 0 and 255 :return: \"\"\" if timeout < 0 or timeout > 255 : raise ValueError ( \"Timeout must be in range 0..255, got {}\" . format ( timeout )) for relay in self : self . _sdk . control_device ( ControlOperation . output . value , relay . number , relay . group . value , timeout , 0 ) @property def aux ( self ) -> 'RelayList' : \"\"\"Return relays only from aux group\"\"\" relays = [ x for x in self if x . group == RelayGroup . aux ] return self . __class__ ( sdk = self . _sdk , relays = relays ) @property def lock ( self ) -> 'RelayList' : \"\"\"Return relays only from lock group\"\"\" relays = [ x for x in self if x . group == RelayGroup . lock ] return self . __class__ ( sdk = self . _sdk , relays = relays ) def __getitem__ ( self , item ): relays = self . data [ item ] if isinstance ( item , slice ): return self . __class__ ( self . _sdk , relays = relays ) else : return relays def by_mask ( self , mask : Iterable [ Union [ int , bool ]]) -> 'RelayList' : \"\"\" Return only relays starting from 0 which are matched by given mask. E.g. for `mask=[1, 0, 0, 1, 0, 0, 1, 0]` the function returns the 1st, the 4th and the 7th of 8 relays. If mask is longer than count of relays, the rest values will be ignored: for 5 relays `mask=[1, 0, 0, 1, 0, 0, 1, 0]` will return the 1st and the 4th relays. If mask is shorter than count of relays then the rest relays will be ignored: for 8 relays `mask=[1, 0, 0]` will return the 1st relay only. :param mask: mask is a list of ints or bools :return: new instance of RelayList contained needed relays \"\"\" relays = [ x for x , m in zip ( self , mask ) if m ] return self . __class__ ( sdk = self . _sdk , relays = relays ) Classes Relay class Relay ( sdk : pyzkaccess . sdk . ZKSDK , group : pyzkaccess . enum . RelayGroup , number : int ) Concrete relay View Source class Relay ( RelayInterface ): \"\"\"Concrete relay\"\"\" def __init__ ( self , sdk: ZKSDK , group: RelayGroup , number: int ): self . group = group self . number = number self . _sdk = sdk def switch_on ( self , timeout: int ) -> None: \"\"\" Switch on a relay for the given time. If a relay is already switched on then its timeout will be refreshed :param timeout: Timeout in seconds while relay will be enabled. Number between 0 and 255 :return: \"\"\" if timeout < 0 or timeout > 255 : raise ValueError ( \"Timeout must be in range 0..255, got {}\" . format ( timeout )) self . _sdk . control_device ( ControlOperation . output . value , self . number , self . group . value , timeout , 0 ) def __eq__ ( self , other ): if isinstance ( other , Relay ): return self . number == other . number \\ and self . group == other . group \\ and self . _sdk is other . _sdk return False def __ne__ ( self , other ): return not self . __eq__ ( other ) def __str__ ( self ): return \"Relay.{}({})\" . format ( self . group . name , self . number ) def __repr__ ( self ): return \"Relay(RelayGroup.{}, {})\" . format ( self . group . name , self . number ) Ancestors (in MRO) pyzkaccess.relay.RelayInterface Methods switch_on def switch_on ( self , timeout : int ) -> None Switch on a relay for the given time. If a relay is already switched on then its timeout will be refreshed :param timeout: Timeout in seconds while relay will be enabled. Number between 0 and 255 :return: View Source def switch_on ( self , timeout : int ) -> None : \"\"\" Switch on a relay for the given time. If a relay is already switched on then its timeout will be refreshed :param timeout: Timeout in seconds while relay will be enabled. Number between 0 and 255 :return: \"\"\" if timeout < 0 or timeout > 255 : raise ValueError ( \"Timeout must be in range 0..255, got {}\" . format ( timeout )) self . _sdk . control_device ( ControlOperation . output . value , self . number , self . group . value , timeout , 0 ) RelayList class RelayList ( sdk : pyzkaccess . sdk . ZKSDK , relays : Iterable [ pyzkaccess . relay . Relay ] = () ) Collection of relay objects which is used to perform group operations over multiple relays View Source class RelayList ( RelayInterface , UserTuple ) : \"\"\"Collection of relay objects which is used to perform group operations over multiple relays \"\"\" def __init__ ( self , sdk : ZKSDK , relays : Iterable [ Relay ] = ()) : super (). __init__ ( relays ) self . _sdk = sdk def switch_on ( self , timeout : int ) -> None : \"\"\" Switch on all relays in set for a given time :param timeout: Timeout in seconds while relay will be enabled. Number between 0 and 255 :return: \"\"\" if timeout < 0 or timeout > 255 : raise ValueError ( \"Timeout must be in range 0..255, got {}\" . format ( timeout )) for relay in self : self . _sdk . control_device ( ControlOperation . output . value , relay . number , relay . group . value , timeout , 0 ) @property def aux ( self ) -> 'RelayList' : \"\"\"Return relays only from aux group\"\"\" relays = [ x for x in self if x.group == RelayGroup.aux ] return self . __class__ ( sdk = self . _sdk , relays = relays ) @property def lock ( self ) -> 'RelayList' : \"\"\"Return relays only from lock group\"\"\" relays = [ x for x in self if x.group == RelayGroup.lock ] return self . __class__ ( sdk = self . _sdk , relays = relays ) def __getitem__ ( self , item ) : relays = self . data [ item ] if isinstance ( item , slice ) : return self . __class__ ( self . _sdk , relays = relays ) else : return relays def by_mask ( self , mask : Iterable [ Union[int, bool ] ] ) -> 'RelayList' : \"\"\" Return only relays starting from 0 which are matched by given mask. E.g. for `mask=[1, 0, 0, 1, 0, 0, 1, 0]` the function returns the 1st, the 4th and the 7th of 8 relays. If mask is longer than count of relays, the rest values will be ignored: for 5 relays `mask=[1, 0, 0, 1, 0, 0, 1, 0]` will return the 1st and the 4th relays. If mask is shorter than count of relays then the rest relays will be ignored: for 8 relays `mask=[1, 0, 0]` will return the 1st relay only. :param mask: mask is a list of ints or bools :return: new instance of RelayList contained needed relays \"\"\" relays = [ x for x, m in zip(self, mask) if m ] return self . __class__ ( sdk = self . _sdk , relays = relays ) Ancestors (in MRO) pyzkaccess.relay.RelayInterface pyzkaccess.common.UserTuple Instance variables aux Return relays only from aux group lock Return relays only from lock group Methods by_mask def by_mask ( self , mask : Iterable [ Union [ int , bool ]] ) -> 'RelayList' Return only relays starting from 0 which are matched by given mask. E.g. for mask=[1, 0, 0, 1, 0, 0, 1, 0] the function returns the 1st, the 4th and the 7th of 8 relays. If mask is longer than count of relays, the rest values will be ignored: for 5 relays mask=[1, 0, 0, 1, 0, 0, 1, 0] will return the 1st and the 4th relays. If mask is shorter than count of relays then the rest relays will be ignored: for 8 relays mask=[1, 0, 0] will return the 1st relay only. :param mask: mask is a list of ints or bools :return: new instance of RelayList contained needed relays View Source def by_mask ( self , mask : Iterable [ Union [ int , bool ]]) -> 'RelayList' : \"\"\" Return only relays starting from 0 which are matched by given mask. E.g. for `mask=[1, 0, 0, 1, 0, 0, 1, 0]` the function returns the 1st, the 4th and the 7th of 8 relays. If mask is longer than count of relays, the rest values will be ignored: for 5 relays `mask=[1, 0, 0, 1, 0, 0, 1, 0]` will return the 1st and the 4th relays. If mask is shorter than count of relays then the rest relays will be ignored: for 8 relays `mask=[1, 0, 0]` will return the 1st relay only. :param mask: mask is a list of ints or bools :return: new instance of RelayList contained needed relays \"\"\" relays = [ x for x , m in zip ( self , mask ) if m ] return self . __class__ ( sdk = self . _sdk , relays = relays ) copy def copy ( self ) View Source def copy(self): return self.__class__(self) count def count ( self , item ) View Source def count(self, item): return self.data.count(item) index def index ( self , item , * args ) View Source def index(self, item, *args): return self.data.index(item, *args) switch_on def switch_on ( self , timeout : int ) -> None Switch on all relays in set for a given time :param timeout: Timeout in seconds while relay will be enabled. Number between 0 and 255 :return: View Source def switch_on ( self , timeout : int ) -> None : \"\"\" Switch on all relays in set for a given time :param timeout: Timeout in seconds while relay will be enabled. Number between 0 and 255 :return: \"\"\" if timeout < 0 or timeout > 255 : raise ValueError ( \"Timeout must be in range 0..255, got {}\" . format ( timeout )) for relay in self : self . _sdk . control_device ( ControlOperation . output . value , relay . number , relay . group . value , timeout , 0 )","title":"Relay"},{"location":"reference/pyzkaccess/relay/#module-pyzkaccessrelay","text":"View Source __all__ = [ 'Relay' , 'RelayList' ] from abc import ABCMeta , abstractmethod from typing import Iterable , Union from .common import UserTuple from .enum import RelayGroup , ControlOperation from .sdk import ZKSDK class RelayInterface ( metaclass = ABCMeta ): @abstractmethod def switch_on ( self , timeout : int ) -> None : \"\"\" Switch on a relay for the given time. If a relay is already switched on then its timeout will be refreshed :param timeout: timeout in seconds, Number between 0 and 255 :return: \"\"\" pass class Relay ( RelayInterface ): \"\"\"Concrete relay\"\"\" def __init__ ( self , sdk : ZKSDK , group : RelayGroup , number : int ): self . group = group self . number = number self . _sdk = sdk def switch_on ( self , timeout : int ) -> None : \"\"\" Switch on a relay for the given time. If a relay is already switched on then its timeout will be refreshed :param timeout: Timeout in seconds while relay will be enabled. Number between 0 and 255 :return: \"\"\" if timeout < 0 or timeout > 255 : raise ValueError ( \"Timeout must be in range 0..255, got {}\" . format ( timeout )) self . _sdk . control_device ( ControlOperation . output . value , self . number , self . group . value , timeout , 0 ) def __eq__ ( self , other ): if isinstance ( other , Relay ): return self . number == other . number \\ and self . group == other . group \\ and self . _sdk is other . _sdk return False def __ne__ ( self , other ): return not self . __eq__ ( other ) def __str__ ( self ): return \"Relay.{}({})\" . format ( self . group . name , self . number ) def __repr__ ( self ): return \"Relay(RelayGroup.{}, {})\" . format ( self . group . name , self . number ) class RelayList ( RelayInterface , UserTuple ): \"\"\"Collection of relay objects which is used to perform group operations over multiple relays \"\"\" def __init__ ( self , sdk : ZKSDK , relays : Iterable [ Relay ] = ()): super () . __init__ ( relays ) self . _sdk = sdk def switch_on ( self , timeout : int ) -> None : \"\"\" Switch on all relays in set for a given time :param timeout: Timeout in seconds while relay will be enabled. Number between 0 and 255 :return: \"\"\" if timeout < 0 or timeout > 255 : raise ValueError ( \"Timeout must be in range 0..255, got {}\" . format ( timeout )) for relay in self : self . _sdk . control_device ( ControlOperation . output . value , relay . number , relay . group . value , timeout , 0 ) @property def aux ( self ) -> 'RelayList' : \"\"\"Return relays only from aux group\"\"\" relays = [ x for x in self if x . group == RelayGroup . aux ] return self . __class__ ( sdk = self . _sdk , relays = relays ) @property def lock ( self ) -> 'RelayList' : \"\"\"Return relays only from lock group\"\"\" relays = [ x for x in self if x . group == RelayGroup . lock ] return self . __class__ ( sdk = self . _sdk , relays = relays ) def __getitem__ ( self , item ): relays = self . data [ item ] if isinstance ( item , slice ): return self . __class__ ( self . _sdk , relays = relays ) else : return relays def by_mask ( self , mask : Iterable [ Union [ int , bool ]]) -> 'RelayList' : \"\"\" Return only relays starting from 0 which are matched by given mask. E.g. for `mask=[1, 0, 0, 1, 0, 0, 1, 0]` the function returns the 1st, the 4th and the 7th of 8 relays. If mask is longer than count of relays, the rest values will be ignored: for 5 relays `mask=[1, 0, 0, 1, 0, 0, 1, 0]` will return the 1st and the 4th relays. If mask is shorter than count of relays then the rest relays will be ignored: for 8 relays `mask=[1, 0, 0]` will return the 1st relay only. :param mask: mask is a list of ints or bools :return: new instance of RelayList contained needed relays \"\"\" relays = [ x for x , m in zip ( self , mask ) if m ] return self . __class__ ( sdk = self . _sdk , relays = relays )","title":"Module pyzkaccess.relay"},{"location":"reference/pyzkaccess/relay/#classes","text":"","title":"Classes"},{"location":"reference/pyzkaccess/relay/#relay","text":"class Relay ( sdk : pyzkaccess . sdk . ZKSDK , group : pyzkaccess . enum . RelayGroup , number : int ) Concrete relay View Source class Relay ( RelayInterface ): \"\"\"Concrete relay\"\"\" def __init__ ( self , sdk: ZKSDK , group: RelayGroup , number: int ): self . group = group self . number = number self . _sdk = sdk def switch_on ( self , timeout: int ) -> None: \"\"\" Switch on a relay for the given time. If a relay is already switched on then its timeout will be refreshed :param timeout: Timeout in seconds while relay will be enabled. Number between 0 and 255 :return: \"\"\" if timeout < 0 or timeout > 255 : raise ValueError ( \"Timeout must be in range 0..255, got {}\" . format ( timeout )) self . _sdk . control_device ( ControlOperation . output . value , self . number , self . group . value , timeout , 0 ) def __eq__ ( self , other ): if isinstance ( other , Relay ): return self . number == other . number \\ and self . group == other . group \\ and self . _sdk is other . _sdk return False def __ne__ ( self , other ): return not self . __eq__ ( other ) def __str__ ( self ): return \"Relay.{}({})\" . format ( self . group . name , self . number ) def __repr__ ( self ): return \"Relay(RelayGroup.{}, {})\" . format ( self . group . name , self . number )","title":"Relay"},{"location":"reference/pyzkaccess/relay/#ancestors-in-mro","text":"pyzkaccess.relay.RelayInterface","title":"Ancestors (in MRO)"},{"location":"reference/pyzkaccess/relay/#methods","text":"","title":"Methods"},{"location":"reference/pyzkaccess/relay/#switch_on","text":"def switch_on ( self , timeout : int ) -> None Switch on a relay for the given time. If a relay is already switched on then its timeout will be refreshed :param timeout: Timeout in seconds while relay will be enabled. Number between 0 and 255 :return: View Source def switch_on ( self , timeout : int ) -> None : \"\"\" Switch on a relay for the given time. If a relay is already switched on then its timeout will be refreshed :param timeout: Timeout in seconds while relay will be enabled. Number between 0 and 255 :return: \"\"\" if timeout < 0 or timeout > 255 : raise ValueError ( \"Timeout must be in range 0..255, got {}\" . format ( timeout )) self . _sdk . control_device ( ControlOperation . output . value , self . number , self . group . value , timeout , 0 )","title":"switch_on"},{"location":"reference/pyzkaccess/relay/#relaylist","text":"class RelayList ( sdk : pyzkaccess . sdk . ZKSDK , relays : Iterable [ pyzkaccess . relay . Relay ] = () ) Collection of relay objects which is used to perform group operations over multiple relays View Source class RelayList ( RelayInterface , UserTuple ) : \"\"\"Collection of relay objects which is used to perform group operations over multiple relays \"\"\" def __init__ ( self , sdk : ZKSDK , relays : Iterable [ Relay ] = ()) : super (). __init__ ( relays ) self . _sdk = sdk def switch_on ( self , timeout : int ) -> None : \"\"\" Switch on all relays in set for a given time :param timeout: Timeout in seconds while relay will be enabled. Number between 0 and 255 :return: \"\"\" if timeout < 0 or timeout > 255 : raise ValueError ( \"Timeout must be in range 0..255, got {}\" . format ( timeout )) for relay in self : self . _sdk . control_device ( ControlOperation . output . value , relay . number , relay . group . value , timeout , 0 ) @property def aux ( self ) -> 'RelayList' : \"\"\"Return relays only from aux group\"\"\" relays = [ x for x in self if x.group == RelayGroup.aux ] return self . __class__ ( sdk = self . _sdk , relays = relays ) @property def lock ( self ) -> 'RelayList' : \"\"\"Return relays only from lock group\"\"\" relays = [ x for x in self if x.group == RelayGroup.lock ] return self . __class__ ( sdk = self . _sdk , relays = relays ) def __getitem__ ( self , item ) : relays = self . data [ item ] if isinstance ( item , slice ) : return self . __class__ ( self . _sdk , relays = relays ) else : return relays def by_mask ( self , mask : Iterable [ Union[int, bool ] ] ) -> 'RelayList' : \"\"\" Return only relays starting from 0 which are matched by given mask. E.g. for `mask=[1, 0, 0, 1, 0, 0, 1, 0]` the function returns the 1st, the 4th and the 7th of 8 relays. If mask is longer than count of relays, the rest values will be ignored: for 5 relays `mask=[1, 0, 0, 1, 0, 0, 1, 0]` will return the 1st and the 4th relays. If mask is shorter than count of relays then the rest relays will be ignored: for 8 relays `mask=[1, 0, 0]` will return the 1st relay only. :param mask: mask is a list of ints or bools :return: new instance of RelayList contained needed relays \"\"\" relays = [ x for x, m in zip(self, mask) if m ] return self . __class__ ( sdk = self . _sdk , relays = relays )","title":"RelayList"},{"location":"reference/pyzkaccess/relay/#ancestors-in-mro_1","text":"pyzkaccess.relay.RelayInterface pyzkaccess.common.UserTuple","title":"Ancestors (in MRO)"},{"location":"reference/pyzkaccess/relay/#instance-variables","text":"aux Return relays only from aux group lock Return relays only from lock group","title":"Instance variables"},{"location":"reference/pyzkaccess/relay/#methods_1","text":"","title":"Methods"},{"location":"reference/pyzkaccess/relay/#by_mask","text":"def by_mask ( self , mask : Iterable [ Union [ int , bool ]] ) -> 'RelayList' Return only relays starting from 0 which are matched by given mask. E.g. for mask=[1, 0, 0, 1, 0, 0, 1, 0] the function returns the 1st, the 4th and the 7th of 8 relays. If mask is longer than count of relays, the rest values will be ignored: for 5 relays mask=[1, 0, 0, 1, 0, 0, 1, 0] will return the 1st and the 4th relays. If mask is shorter than count of relays then the rest relays will be ignored: for 8 relays mask=[1, 0, 0] will return the 1st relay only. :param mask: mask is a list of ints or bools :return: new instance of RelayList contained needed relays View Source def by_mask ( self , mask : Iterable [ Union [ int , bool ]]) -> 'RelayList' : \"\"\" Return only relays starting from 0 which are matched by given mask. E.g. for `mask=[1, 0, 0, 1, 0, 0, 1, 0]` the function returns the 1st, the 4th and the 7th of 8 relays. If mask is longer than count of relays, the rest values will be ignored: for 5 relays `mask=[1, 0, 0, 1, 0, 0, 1, 0]` will return the 1st and the 4th relays. If mask is shorter than count of relays then the rest relays will be ignored: for 8 relays `mask=[1, 0, 0]` will return the 1st relay only. :param mask: mask is a list of ints or bools :return: new instance of RelayList contained needed relays \"\"\" relays = [ x for x , m in zip ( self , mask ) if m ] return self . __class__ ( sdk = self . _sdk , relays = relays )","title":"by_mask"},{"location":"reference/pyzkaccess/relay/#copy","text":"def copy ( self ) View Source def copy(self): return self.__class__(self)","title":"copy"},{"location":"reference/pyzkaccess/relay/#count","text":"def count ( self , item ) View Source def count(self, item): return self.data.count(item)","title":"count"},{"location":"reference/pyzkaccess/relay/#index","text":"def index ( self , item , * args ) View Source def index(self, item, *args): return self.data.index(item, *args)","title":"index"},{"location":"reference/pyzkaccess/relay/#switch_on_1","text":"def switch_on ( self , timeout : int ) -> None Switch on all relays in set for a given time :param timeout: Timeout in seconds while relay will be enabled. Number between 0 and 255 :return: View Source def switch_on ( self , timeout : int ) -> None : \"\"\" Switch on all relays in set for a given time :param timeout: Timeout in seconds while relay will be enabled. Number between 0 and 255 :return: \"\"\" if timeout < 0 or timeout > 255 : raise ValueError ( \"Timeout must be in range 0..255, got {}\" . format ( timeout )) for relay in self : self . _sdk . control_device ( ControlOperation . output . value , relay . number , relay . group . value , timeout , 0 )","title":"switch_on"},{"location":"reference/pyzkaccess/sdk/","text":"Module pyzkaccess.sdk View Source __all__ = [ 'ZKSDK' ] import pyzkaccess.ctypes as ctypes from typing import Sequence , Mapping , Any from .exceptions import ZKSDKError class ZKSDK : \"\"\"This is machinery class which directly calls SDK functions. This is a wrapper around DLL functions of SDK, it incapsulates working with ctypes, handles errors and holds connection info. \"\"\" def __init__ ( self , dllpath : str ): \"\"\" :param dllpath: path to a DLL file. Typically \"plcommpro.dll\" \"\"\" self . dll = ctypes . WinDLL ( dllpath ) self . handle = None @property def is_connected ( self ) -> bool : \"\"\"Return True if connection is active\"\"\" return bool ( self . handle is not None ) def connect ( self , connstr : str ) -> None : \"\"\" Connect to a device. SDK: Connect() :param connstr: connection string, see docs :raises ZKSDKError: :return: \"\"\" connstr = connstr . encode () self . handle = self . dll . Connect ( connstr ) if self . handle == 0 : self . handle = None err = self . dll . PullLastError () raise ZKSDKError ( \"Unable to connect a device using connstr {}\" . format ( connstr ), err ) def disconnect ( self ) -> None : \"\"\" Disconnect from a device SDK: Disconnect() :return: \"\"\" if not self . handle : return self . dll . Disconnect ( self . handle ) self . handle = None def control_device ( self , operation , p1 , p2 , p3 , p4 , options_str = '' ) -> int : \"\"\" Perform an action on a device such as relay switching or reboot. For parameter meaning please see SDK docs. SDK: ControlDevice() :param operation: Number, operation id :param p1: Number, depends on operation id :param p2: Number, depends on operation id :param p3: Number, depends on operation id :param p4: Number, depends on operation id :param options_str: String, depends on operation id :raises ZKSDKError: :return: DLL function result code, 0 or positive number \"\"\" err = self . dll . ControlDevice ( self . handle , operation , p1 , p2 , p3 , p4 , options_str ) if err < 0 : raise ZKSDKError ( 'ControlDevice failed for operation {}' . format ( operation ), err ) return err def get_rt_log ( self , buffer_size : int ) -> Sequence [ str ]: \"\"\" Retrieve unread realtime events from a device SDK: GetRTLog() :param buffer_size: size in bytes of buffer which is filled with contents :raises ZKSDKError: :return: event string lines \"\"\" buf = ctypes . create_string_buffer ( buffer_size ) err = self . dll . GetRTLog ( self . handle , buf , buffer_size ) if err < 0 : raise ZKSDKError ( 'GetRTLog failed' , err ) raw = buf . value . decode ( 'utf-8' ) if raw == ' \\r\\n ' : return [] * lines , _ = raw . split ( ' \\r\\n ' ) return lines def search_device ( self , broadcast_address : str , buffer_size : int ) -> Sequence [ str ]: \"\"\" Perform network scan in order to collect available ZK devices SDK: SearchDevice() :param broadcast_address: network broadcast address :param buffer_size: size in bytes of buffer which is filled with contents :raises ZKSDKError: :return: device string lines \"\"\" buf = ctypes . create_string_buffer ( buffer_size ) broadcast_address = broadcast_address . encode () protocol = b 'UDP' # Only UDP works, see SDK docs err = self . dll . SearchDevice ( protocol , broadcast_address , buf ) if err < 0 : raise ZKSDKError ( 'SearchDevice failed' , err ) raw = buf . value . decode ( 'utf-8' ) if raw == ' \\r\\n ' : return [] * lines , _ = raw . split ( \" \\r\\n \" ) return lines def get_device_param ( self , parameters : Sequence [ str ], buffer_size : int ) -> Mapping [ str , str ]: \"\"\" Fetch given device parameters SDK: GetDeviceParam() :param parameters: sequence with parameter names to be requested :param buffer_size: size in bytes of buffer which is filled with contents :raises ZKSDKError: :return: dict with requested parameters value. Each value is string \"\"\" buf = ctypes . create_string_buffer ( buffer_size ) results = {} # Device can return maximum 30 parameters for one call. See SDK # docs. So fetch them in loop by bunches of 30 items parameters_copy = list ( parameters ) while parameters_copy : query_params = parameters_copy [: 30 ] query = ',' . join ( query_params ) . encode () del parameters_copy [: 30 ] err = self . dll . GetDeviceParam ( self . handle , buf , buffer_size , query ) if err < 0 : raise ZKSDKError ( 'GetDeviceParam failed' , err ) for pair in buf . value . decode () . split ( ',' ): key , val = pair . split ( '=' ) results [ key ] = val if results . keys () != set ( parameters ): raise ValueError ( 'Parameters returned by a device are differ than parameters was requested' ) return results def set_device_param ( self , parameters : Mapping [ str , Any ]) -> None : \"\"\" Set given device parameters SDK: SetDeviceParam() :param parameters: dict with parameter names and values to be set. Every value will be casted to string :raises ZKSDKError: :return: \"\"\" if not parameters : return # Device can accept maximum 20 parameters for one call. See SDK # docs. So send them in loop by bunches of 20 items keys = list ( sorted ( parameters . keys ())) while keys : query_keys = keys [: 20 ] query = ',' . join ( '{}={}' . format ( k , parameters [ k ]) for k in query_keys ) . encode () del keys [: 20 ] err = self . dll . SetDeviceParam ( self . handle , query ) if err < 0 : raise ZKSDKError ( 'SetDeviceParam failed' , err ) def __del__ ( self ): self . disconnect () Classes ZKSDK class ZKSDK ( dllpath : str ) This is machinery class which directly calls SDK functions. This is a wrapper around DLL functions of SDK, it incapsulates working with ctypes, handles errors and holds connection info. View Source class ZKSDK : \"\"\"This is machinery class which directly calls SDK functions. This is a wrapper around DLL functions of SDK, it incapsulates working with ctypes, handles errors and holds connection info. \"\"\" def __init__ ( self , dllpath : str ) : \"\"\" :param dllpath: path to a DLL file. Typically \" plcommpro . dll \" \"\"\" self . dll = ctypes . WinDLL ( dllpath ) self . handle = None @property def is_connected ( self ) -> bool : \"\"\"Return True if connection is active\"\"\" return bool ( self . handle is not None ) def connect ( self , connstr : str ) -> None : \"\"\" Connect to a device. SDK: Connect() :param connstr: connection string, see docs :raises ZKSDKError: :return: \"\"\" connstr = connstr . encode () self . handle = self . dll . Connect ( connstr ) if self . handle == 0 : self . handle = None err = self . dll . PullLastError () raise ZKSDKError ( \"Unable to connect a device using connstr {}\" . format ( connstr ), err ) def disconnect ( self ) -> None : \"\"\" Disconnect from a device SDK: Disconnect() :return: \"\"\" if not self . handle : return self . dll . Disconnect ( self . handle ) self . handle = None def control_device ( self , operation , p1 , p2 , p3 , p4 , options_str = '' ) -> int : \"\"\" Perform an action on a device such as relay switching or reboot. For parameter meaning please see SDK docs. SDK: ControlDevice() :param operation: Number, operation id :param p1: Number, depends on operation id :param p2: Number, depends on operation id :param p3: Number, depends on operation id :param p4: Number, depends on operation id :param options_str: String, depends on operation id :raises ZKSDKError: :return: DLL function result code, 0 or positive number \"\"\" err = self . dll . ControlDevice ( self . handle , operation , p1 , p2 , p3 , p4 , options_str ) if err < 0 : raise ZKSDKError ( 'ControlDevice failed for operation {}' . format ( operation ), err ) return err def get_rt_log ( self , buffer_size : int ) -> Sequence [ str ] : \"\"\" Retrieve unread realtime events from a device SDK: GetRTLog() :param buffer_size: size in bytes of buffer which is filled with contents :raises ZKSDKError: :return: event string lines \"\"\" buf = ctypes . create_string_buffer ( buffer_size ) err = self . dll . GetRTLog ( self . handle , buf , buffer_size ) if err < 0 : raise ZKSDKError ( 'GetRTLog failed' , err ) raw = buf . value . decode ( 'utf-8' ) if raw == '\\r\\n' : return [] * lines , _ = raw . split ( '\\r\\n' ) return lines def search_device ( self , broadcast_address : str , buffer_size : int ) -> Sequence [ str ] : \"\"\" Perform network scan in order to collect available ZK devices SDK: SearchDevice() :param broadcast_address: network broadcast address :param buffer_size: size in bytes of buffer which is filled with contents :raises ZKSDKError: :return: device string lines \"\"\" buf = ctypes . create_string_buffer ( buffer_size ) broadcast_address = broadcast_address . encode () protocol = b 'UDP' # Only UDP works , see SDK docs err = self . dll . SearchDevice ( protocol , broadcast_address , buf ) if err < 0 : raise ZKSDKError ( 'SearchDevice failed' , err ) raw = buf . value . decode ( 'utf-8' ) if raw == '\\r\\n' : return [] * lines , _ = raw . split ( \"\\r\\n\" ) return lines def get_device_param ( self , parameters : Sequence [ str ] , buffer_size : int ) -> Mapping [ str, str ] : \"\"\" Fetch given device parameters SDK: GetDeviceParam() :param parameters: sequence with parameter names to be requested :param buffer_size: size in bytes of buffer which is filled with contents :raises ZKSDKError: :return: dict with requested parameters value. Each value is string \"\"\" buf = ctypes . create_string_buffer ( buffer_size ) results = {} # Device can return maximum 30 parameters for one call . See SDK # docs . So fetch them in loop by bunches of 30 items parameters_copy = list ( parameters ) while parameters_copy : query_params = parameters_copy [ :30 ] query = ',' . join ( query_params ). encode () del parameters_copy [ :30 ] err = self . dll . GetDeviceParam ( self . handle , buf , buffer_size , query ) if err < 0 : raise ZKSDKError ( 'GetDeviceParam failed' , err ) for pair in buf . value . decode (). split ( ',' ) : key , val = pair . split ( '=' ) results [ key ] = val if results . keys () != set ( parameters ) : raise ValueError ( 'Parameters returned by a device are differ than parameters was requested' ) return results def set_device_param ( self , parameters : Mapping [ str, Any ] ) -> None : \"\"\" Set given device parameters SDK: SetDeviceParam() :param parameters: dict with parameter names and values to be set. Every value will be casted to string :raises ZKSDKError: :return: \"\"\" if not parameters : return # Device can accept maximum 20 parameters for one call . See SDK # docs . So send them in loop by bunches of 20 items keys = list ( sorted ( parameters . keys ())) while keys : query_keys = keys [ :20 ] query = ',' . join ( '{}={}' . format ( k , parameters [ k ] ) for k in query_keys ). encode () del keys [ :20 ] err = self . dll . SetDeviceParam ( self . handle , query ) if err < 0 : raise ZKSDKError ( 'SetDeviceParam failed' , err ) def __del__ ( self ) : self . disconnect () Instance variables is_connected Return True if connection is active Methods connect def connect ( self , connstr : str ) -> None Connect to a device. SDK: Connect() :param connstr: connection string, see docs :raises ZKSDKError: :return: View Source def connect ( self , connstr : str ) -> None : \"\"\" Connect to a device. SDK: Connect() :param connstr: connection string, see docs :raises ZKSDKError: :return: \"\"\" connstr = connstr . encode () self . handle = self . dll . Connect ( connstr ) if self . handle == 0 : self . handle = None err = self . dll . PullLastError () raise ZKSDKError ( \"Unable to connect a device using connstr {}\" . format ( connstr ), err ) control_device def control_device ( self , operation , p1 , p2 , p3 , p4 , options_str = '' ) -> int Perform an action on a device such as relay switching or reboot. For parameter meaning please see SDK docs. SDK: ControlDevice() :param operation: Number, operation id :param p1: Number, depends on operation id :param p2: Number, depends on operation id :param p3: Number, depends on operation id :param p4: Number, depends on operation id :param options_str: String, depends on operation id :raises ZKSDKError: :return: DLL function result code, 0 or positive number View Source def control_device ( self , operation , p1 , p2 , p3 , p4 , options_str = '' ) -> int : \"\"\" Perform an action on a device such as relay switching or reboot. For parameter meaning please see SDK docs. SDK: ControlDevice() :param operation: Number, operation id :param p1: Number, depends on operation id :param p2: Number, depends on operation id :param p3: Number, depends on operation id :param p4: Number, depends on operation id :param options_str: String, depends on operation id :raises ZKSDKError: :return: DLL function result code, 0 or positive number \"\"\" err = self . dll . ControlDevice ( self . handle , operation , p1 , p2 , p3 , p4 , options_str ) if err < 0 : raise ZKSDKError ( 'ControlDevice failed for operation {}' . format ( operation ), err ) return err disconnect def disconnect ( self ) -> None Disconnect from a device SDK: Disconnect() :return: View Source def disconnect ( self ) -> None : \"\"\" Disconnect from a device SDK: Disconnect() :return: \"\"\" if not self . handle : return self . dll . Disconnect ( self . handle ) self . handle = None get_device_param def get_device_param ( self , parameters : Sequence [ str ], buffer_size : int ) -> Mapping [ str , str ] Fetch given device parameters SDK: GetDeviceParam() :param parameters: sequence with parameter names to be requested :param buffer_size: size in bytes of buffer which is filled with contents :raises ZKSDKError: :return: dict with requested parameters value. Each value is string View Source def get_device_param ( self , parameters : Sequence [ str ] , buffer_size : int ) -> Mapping [ str, str ] : \"\"\" Fetch given device parameters SDK: GetDeviceParam() :param parameters: sequence with parameter names to be requested :param buffer_size: size in bytes of buffer which is filled with contents :raises ZKSDKError: :return: dict with requested parameters value. Each value is string \"\"\" buf = ctypes . create_string_buffer ( buffer_size ) results = {} # Device can return maximum 30 parameters for one call . See SDK # docs . So fetch them in loop by bunches of 30 items parameters_copy = list ( parameters ) while parameters_copy : query_params = parameters_copy [ :30 ] query = ',' . join ( query_params ). encode () del parameters_copy [ :30 ] err = self . dll . GetDeviceParam ( self . handle , buf , buffer_size , query ) if err < 0 : raise ZKSDKError ( 'GetDeviceParam failed' , err ) for pair in buf . value . decode (). split ( ',' ) : key , val = pair . split ( '=' ) results [ key ] = val if results . keys () != set ( parameters ) : raise ValueError ( 'Parameters returned by a device are differ than parameters was requested' ) return results get_rt_log def get_rt_log ( self , buffer_size : int ) -> Sequence [ str ] Retrieve unread realtime events from a device SDK: GetRTLog() :param buffer_size: size in bytes of buffer which is filled with contents :raises ZKSDKError: :return: event string lines View Source def get_rt_log ( self , buffer_size : int ) -> Sequence [ str ] : \"\"\" Retrieve unread realtime events from a device SDK: GetRTLog() :param buffer_size: size in bytes of buffer which is filled with contents :raises ZKSDKError: :return: event string lines \"\"\" buf = ctypes . create_string_buffer ( buffer_size ) err = self . dll . GetRTLog ( self . handle , buf , buffer_size ) if err < 0 : raise ZKSDKError ( 'GetRTLog failed' , err ) raw = buf . value . decode ( 'utf-8' ) if raw == '\\r\\n' : return [] * lines , _ = raw . split ( '\\r\\n' ) return lines search_device def search_device ( self , broadcast_address : str , buffer_size : int ) -> Sequence [ str ] Perform network scan in order to collect available ZK devices SDK: SearchDevice() :param broadcast_address: network broadcast address :param buffer_size: size in bytes of buffer which is filled with contents :raises ZKSDKError: :return: device string lines View Source def search_device ( self , broadcast_address : str , buffer_size : int ) -> Sequence [ str ] : \"\"\" Perform network scan in order to collect available ZK devices SDK: SearchDevice() :param broadcast_address: network broadcast address :param buffer_size: size in bytes of buffer which is filled with contents :raises ZKSDKError: :return: device string lines \"\"\" buf = ctypes . create_string_buffer ( buffer_size ) broadcast_address = broadcast_address . encode () protocol = b 'UDP' # Only UDP works , see SDK docs err = self . dll . SearchDevice ( protocol , broadcast_address , buf ) if err < 0 : raise ZKSDKError ( 'SearchDevice failed' , err ) raw = buf . value . decode ( 'utf-8' ) if raw == '\\r\\n' : return [] * lines , _ = raw . split ( \"\\r\\n\" ) return lines set_device_param def set_device_param ( self , parameters : Mapping [ str , Any ] ) -> None Set given device parameters SDK: SetDeviceParam() :param parameters: dict with parameter names and values to be set. Every value will be casted to string :raises ZKSDKError: :return: View Source def set_device_param ( self , parameters : Mapping [ str, Any ] ) -> None : \"\"\" Set given device parameters SDK: SetDeviceParam() :param parameters: dict with parameter names and values to be set. Every value will be casted to string :raises ZKSDKError: :return: \"\"\" if not parameters : return # Device can accept maximum 20 parameters for one call . See SDK # docs . So send them in loop by bunches of 20 items keys = list ( sorted ( parameters . keys ())) while keys : query_keys = keys [ :20 ] query = ',' . join ( '{}={}' . format ( k , parameters [ k ] ) for k in query_keys ). encode () del keys [ :20 ] err = self . dll . SetDeviceParam ( self . handle , query ) if err < 0 : raise ZKSDKError ( 'SetDeviceParam failed' , err )","title":"Sdk"},{"location":"reference/pyzkaccess/sdk/#module-pyzkaccesssdk","text":"View Source __all__ = [ 'ZKSDK' ] import pyzkaccess.ctypes as ctypes from typing import Sequence , Mapping , Any from .exceptions import ZKSDKError class ZKSDK : \"\"\"This is machinery class which directly calls SDK functions. This is a wrapper around DLL functions of SDK, it incapsulates working with ctypes, handles errors and holds connection info. \"\"\" def __init__ ( self , dllpath : str ): \"\"\" :param dllpath: path to a DLL file. Typically \"plcommpro.dll\" \"\"\" self . dll = ctypes . WinDLL ( dllpath ) self . handle = None @property def is_connected ( self ) -> bool : \"\"\"Return True if connection is active\"\"\" return bool ( self . handle is not None ) def connect ( self , connstr : str ) -> None : \"\"\" Connect to a device. SDK: Connect() :param connstr: connection string, see docs :raises ZKSDKError: :return: \"\"\" connstr = connstr . encode () self . handle = self . dll . Connect ( connstr ) if self . handle == 0 : self . handle = None err = self . dll . PullLastError () raise ZKSDKError ( \"Unable to connect a device using connstr {}\" . format ( connstr ), err ) def disconnect ( self ) -> None : \"\"\" Disconnect from a device SDK: Disconnect() :return: \"\"\" if not self . handle : return self . dll . Disconnect ( self . handle ) self . handle = None def control_device ( self , operation , p1 , p2 , p3 , p4 , options_str = '' ) -> int : \"\"\" Perform an action on a device such as relay switching or reboot. For parameter meaning please see SDK docs. SDK: ControlDevice() :param operation: Number, operation id :param p1: Number, depends on operation id :param p2: Number, depends on operation id :param p3: Number, depends on operation id :param p4: Number, depends on operation id :param options_str: String, depends on operation id :raises ZKSDKError: :return: DLL function result code, 0 or positive number \"\"\" err = self . dll . ControlDevice ( self . handle , operation , p1 , p2 , p3 , p4 , options_str ) if err < 0 : raise ZKSDKError ( 'ControlDevice failed for operation {}' . format ( operation ), err ) return err def get_rt_log ( self , buffer_size : int ) -> Sequence [ str ]: \"\"\" Retrieve unread realtime events from a device SDK: GetRTLog() :param buffer_size: size in bytes of buffer which is filled with contents :raises ZKSDKError: :return: event string lines \"\"\" buf = ctypes . create_string_buffer ( buffer_size ) err = self . dll . GetRTLog ( self . handle , buf , buffer_size ) if err < 0 : raise ZKSDKError ( 'GetRTLog failed' , err ) raw = buf . value . decode ( 'utf-8' ) if raw == ' \\r\\n ' : return [] * lines , _ = raw . split ( ' \\r\\n ' ) return lines def search_device ( self , broadcast_address : str , buffer_size : int ) -> Sequence [ str ]: \"\"\" Perform network scan in order to collect available ZK devices SDK: SearchDevice() :param broadcast_address: network broadcast address :param buffer_size: size in bytes of buffer which is filled with contents :raises ZKSDKError: :return: device string lines \"\"\" buf = ctypes . create_string_buffer ( buffer_size ) broadcast_address = broadcast_address . encode () protocol = b 'UDP' # Only UDP works, see SDK docs err = self . dll . SearchDevice ( protocol , broadcast_address , buf ) if err < 0 : raise ZKSDKError ( 'SearchDevice failed' , err ) raw = buf . value . decode ( 'utf-8' ) if raw == ' \\r\\n ' : return [] * lines , _ = raw . split ( \" \\r\\n \" ) return lines def get_device_param ( self , parameters : Sequence [ str ], buffer_size : int ) -> Mapping [ str , str ]: \"\"\" Fetch given device parameters SDK: GetDeviceParam() :param parameters: sequence with parameter names to be requested :param buffer_size: size in bytes of buffer which is filled with contents :raises ZKSDKError: :return: dict with requested parameters value. Each value is string \"\"\" buf = ctypes . create_string_buffer ( buffer_size ) results = {} # Device can return maximum 30 parameters for one call. See SDK # docs. So fetch them in loop by bunches of 30 items parameters_copy = list ( parameters ) while parameters_copy : query_params = parameters_copy [: 30 ] query = ',' . join ( query_params ) . encode () del parameters_copy [: 30 ] err = self . dll . GetDeviceParam ( self . handle , buf , buffer_size , query ) if err < 0 : raise ZKSDKError ( 'GetDeviceParam failed' , err ) for pair in buf . value . decode () . split ( ',' ): key , val = pair . split ( '=' ) results [ key ] = val if results . keys () != set ( parameters ): raise ValueError ( 'Parameters returned by a device are differ than parameters was requested' ) return results def set_device_param ( self , parameters : Mapping [ str , Any ]) -> None : \"\"\" Set given device parameters SDK: SetDeviceParam() :param parameters: dict with parameter names and values to be set. Every value will be casted to string :raises ZKSDKError: :return: \"\"\" if not parameters : return # Device can accept maximum 20 parameters for one call. See SDK # docs. So send them in loop by bunches of 20 items keys = list ( sorted ( parameters . keys ())) while keys : query_keys = keys [: 20 ] query = ',' . join ( '{}={}' . format ( k , parameters [ k ]) for k in query_keys ) . encode () del keys [: 20 ] err = self . dll . SetDeviceParam ( self . handle , query ) if err < 0 : raise ZKSDKError ( 'SetDeviceParam failed' , err ) def __del__ ( self ): self . disconnect ()","title":"Module pyzkaccess.sdk"},{"location":"reference/pyzkaccess/sdk/#classes","text":"","title":"Classes"},{"location":"reference/pyzkaccess/sdk/#zksdk","text":"class ZKSDK ( dllpath : str ) This is machinery class which directly calls SDK functions. This is a wrapper around DLL functions of SDK, it incapsulates working with ctypes, handles errors and holds connection info. View Source class ZKSDK : \"\"\"This is machinery class which directly calls SDK functions. This is a wrapper around DLL functions of SDK, it incapsulates working with ctypes, handles errors and holds connection info. \"\"\" def __init__ ( self , dllpath : str ) : \"\"\" :param dllpath: path to a DLL file. Typically \" plcommpro . dll \" \"\"\" self . dll = ctypes . WinDLL ( dllpath ) self . handle = None @property def is_connected ( self ) -> bool : \"\"\"Return True if connection is active\"\"\" return bool ( self . handle is not None ) def connect ( self , connstr : str ) -> None : \"\"\" Connect to a device. SDK: Connect() :param connstr: connection string, see docs :raises ZKSDKError: :return: \"\"\" connstr = connstr . encode () self . handle = self . dll . Connect ( connstr ) if self . handle == 0 : self . handle = None err = self . dll . PullLastError () raise ZKSDKError ( \"Unable to connect a device using connstr {}\" . format ( connstr ), err ) def disconnect ( self ) -> None : \"\"\" Disconnect from a device SDK: Disconnect() :return: \"\"\" if not self . handle : return self . dll . Disconnect ( self . handle ) self . handle = None def control_device ( self , operation , p1 , p2 , p3 , p4 , options_str = '' ) -> int : \"\"\" Perform an action on a device such as relay switching or reboot. For parameter meaning please see SDK docs. SDK: ControlDevice() :param operation: Number, operation id :param p1: Number, depends on operation id :param p2: Number, depends on operation id :param p3: Number, depends on operation id :param p4: Number, depends on operation id :param options_str: String, depends on operation id :raises ZKSDKError: :return: DLL function result code, 0 or positive number \"\"\" err = self . dll . ControlDevice ( self . handle , operation , p1 , p2 , p3 , p4 , options_str ) if err < 0 : raise ZKSDKError ( 'ControlDevice failed for operation {}' . format ( operation ), err ) return err def get_rt_log ( self , buffer_size : int ) -> Sequence [ str ] : \"\"\" Retrieve unread realtime events from a device SDK: GetRTLog() :param buffer_size: size in bytes of buffer which is filled with contents :raises ZKSDKError: :return: event string lines \"\"\" buf = ctypes . create_string_buffer ( buffer_size ) err = self . dll . GetRTLog ( self . handle , buf , buffer_size ) if err < 0 : raise ZKSDKError ( 'GetRTLog failed' , err ) raw = buf . value . decode ( 'utf-8' ) if raw == '\\r\\n' : return [] * lines , _ = raw . split ( '\\r\\n' ) return lines def search_device ( self , broadcast_address : str , buffer_size : int ) -> Sequence [ str ] : \"\"\" Perform network scan in order to collect available ZK devices SDK: SearchDevice() :param broadcast_address: network broadcast address :param buffer_size: size in bytes of buffer which is filled with contents :raises ZKSDKError: :return: device string lines \"\"\" buf = ctypes . create_string_buffer ( buffer_size ) broadcast_address = broadcast_address . encode () protocol = b 'UDP' # Only UDP works , see SDK docs err = self . dll . SearchDevice ( protocol , broadcast_address , buf ) if err < 0 : raise ZKSDKError ( 'SearchDevice failed' , err ) raw = buf . value . decode ( 'utf-8' ) if raw == '\\r\\n' : return [] * lines , _ = raw . split ( \"\\r\\n\" ) return lines def get_device_param ( self , parameters : Sequence [ str ] , buffer_size : int ) -> Mapping [ str, str ] : \"\"\" Fetch given device parameters SDK: GetDeviceParam() :param parameters: sequence with parameter names to be requested :param buffer_size: size in bytes of buffer which is filled with contents :raises ZKSDKError: :return: dict with requested parameters value. Each value is string \"\"\" buf = ctypes . create_string_buffer ( buffer_size ) results = {} # Device can return maximum 30 parameters for one call . See SDK # docs . So fetch them in loop by bunches of 30 items parameters_copy = list ( parameters ) while parameters_copy : query_params = parameters_copy [ :30 ] query = ',' . join ( query_params ). encode () del parameters_copy [ :30 ] err = self . dll . GetDeviceParam ( self . handle , buf , buffer_size , query ) if err < 0 : raise ZKSDKError ( 'GetDeviceParam failed' , err ) for pair in buf . value . decode (). split ( ',' ) : key , val = pair . split ( '=' ) results [ key ] = val if results . keys () != set ( parameters ) : raise ValueError ( 'Parameters returned by a device are differ than parameters was requested' ) return results def set_device_param ( self , parameters : Mapping [ str, Any ] ) -> None : \"\"\" Set given device parameters SDK: SetDeviceParam() :param parameters: dict with parameter names and values to be set. Every value will be casted to string :raises ZKSDKError: :return: \"\"\" if not parameters : return # Device can accept maximum 20 parameters for one call . See SDK # docs . So send them in loop by bunches of 20 items keys = list ( sorted ( parameters . keys ())) while keys : query_keys = keys [ :20 ] query = ',' . join ( '{}={}' . format ( k , parameters [ k ] ) for k in query_keys ). encode () del keys [ :20 ] err = self . dll . SetDeviceParam ( self . handle , query ) if err < 0 : raise ZKSDKError ( 'SetDeviceParam failed' , err ) def __del__ ( self ) : self . disconnect ()","title":"ZKSDK"},{"location":"reference/pyzkaccess/sdk/#instance-variables","text":"is_connected Return True if connection is active","title":"Instance variables"},{"location":"reference/pyzkaccess/sdk/#methods","text":"","title":"Methods"},{"location":"reference/pyzkaccess/sdk/#connect","text":"def connect ( self , connstr : str ) -> None Connect to a device. SDK: Connect() :param connstr: connection string, see docs :raises ZKSDKError: :return: View Source def connect ( self , connstr : str ) -> None : \"\"\" Connect to a device. SDK: Connect() :param connstr: connection string, see docs :raises ZKSDKError: :return: \"\"\" connstr = connstr . encode () self . handle = self . dll . Connect ( connstr ) if self . handle == 0 : self . handle = None err = self . dll . PullLastError () raise ZKSDKError ( \"Unable to connect a device using connstr {}\" . format ( connstr ), err )","title":"connect"},{"location":"reference/pyzkaccess/sdk/#control_device","text":"def control_device ( self , operation , p1 , p2 , p3 , p4 , options_str = '' ) -> int Perform an action on a device such as relay switching or reboot. For parameter meaning please see SDK docs. SDK: ControlDevice() :param operation: Number, operation id :param p1: Number, depends on operation id :param p2: Number, depends on operation id :param p3: Number, depends on operation id :param p4: Number, depends on operation id :param options_str: String, depends on operation id :raises ZKSDKError: :return: DLL function result code, 0 or positive number View Source def control_device ( self , operation , p1 , p2 , p3 , p4 , options_str = '' ) -> int : \"\"\" Perform an action on a device such as relay switching or reboot. For parameter meaning please see SDK docs. SDK: ControlDevice() :param operation: Number, operation id :param p1: Number, depends on operation id :param p2: Number, depends on operation id :param p3: Number, depends on operation id :param p4: Number, depends on operation id :param options_str: String, depends on operation id :raises ZKSDKError: :return: DLL function result code, 0 or positive number \"\"\" err = self . dll . ControlDevice ( self . handle , operation , p1 , p2 , p3 , p4 , options_str ) if err < 0 : raise ZKSDKError ( 'ControlDevice failed for operation {}' . format ( operation ), err ) return err","title":"control_device"},{"location":"reference/pyzkaccess/sdk/#disconnect","text":"def disconnect ( self ) -> None Disconnect from a device SDK: Disconnect() :return: View Source def disconnect ( self ) -> None : \"\"\" Disconnect from a device SDK: Disconnect() :return: \"\"\" if not self . handle : return self . dll . Disconnect ( self . handle ) self . handle = None","title":"disconnect"},{"location":"reference/pyzkaccess/sdk/#get_device_param","text":"def get_device_param ( self , parameters : Sequence [ str ], buffer_size : int ) -> Mapping [ str , str ] Fetch given device parameters SDK: GetDeviceParam() :param parameters: sequence with parameter names to be requested :param buffer_size: size in bytes of buffer which is filled with contents :raises ZKSDKError: :return: dict with requested parameters value. Each value is string View Source def get_device_param ( self , parameters : Sequence [ str ] , buffer_size : int ) -> Mapping [ str, str ] : \"\"\" Fetch given device parameters SDK: GetDeviceParam() :param parameters: sequence with parameter names to be requested :param buffer_size: size in bytes of buffer which is filled with contents :raises ZKSDKError: :return: dict with requested parameters value. Each value is string \"\"\" buf = ctypes . create_string_buffer ( buffer_size ) results = {} # Device can return maximum 30 parameters for one call . See SDK # docs . So fetch them in loop by bunches of 30 items parameters_copy = list ( parameters ) while parameters_copy : query_params = parameters_copy [ :30 ] query = ',' . join ( query_params ). encode () del parameters_copy [ :30 ] err = self . dll . GetDeviceParam ( self . handle , buf , buffer_size , query ) if err < 0 : raise ZKSDKError ( 'GetDeviceParam failed' , err ) for pair in buf . value . decode (). split ( ',' ) : key , val = pair . split ( '=' ) results [ key ] = val if results . keys () != set ( parameters ) : raise ValueError ( 'Parameters returned by a device are differ than parameters was requested' ) return results","title":"get_device_param"},{"location":"reference/pyzkaccess/sdk/#get_rt_log","text":"def get_rt_log ( self , buffer_size : int ) -> Sequence [ str ] Retrieve unread realtime events from a device SDK: GetRTLog() :param buffer_size: size in bytes of buffer which is filled with contents :raises ZKSDKError: :return: event string lines View Source def get_rt_log ( self , buffer_size : int ) -> Sequence [ str ] : \"\"\" Retrieve unread realtime events from a device SDK: GetRTLog() :param buffer_size: size in bytes of buffer which is filled with contents :raises ZKSDKError: :return: event string lines \"\"\" buf = ctypes . create_string_buffer ( buffer_size ) err = self . dll . GetRTLog ( self . handle , buf , buffer_size ) if err < 0 : raise ZKSDKError ( 'GetRTLog failed' , err ) raw = buf . value . decode ( 'utf-8' ) if raw == '\\r\\n' : return [] * lines , _ = raw . split ( '\\r\\n' ) return lines","title":"get_rt_log"},{"location":"reference/pyzkaccess/sdk/#search_device","text":"def search_device ( self , broadcast_address : str , buffer_size : int ) -> Sequence [ str ] Perform network scan in order to collect available ZK devices SDK: SearchDevice() :param broadcast_address: network broadcast address :param buffer_size: size in bytes of buffer which is filled with contents :raises ZKSDKError: :return: device string lines View Source def search_device ( self , broadcast_address : str , buffer_size : int ) -> Sequence [ str ] : \"\"\" Perform network scan in order to collect available ZK devices SDK: SearchDevice() :param broadcast_address: network broadcast address :param buffer_size: size in bytes of buffer which is filled with contents :raises ZKSDKError: :return: device string lines \"\"\" buf = ctypes . create_string_buffer ( buffer_size ) broadcast_address = broadcast_address . encode () protocol = b 'UDP' # Only UDP works , see SDK docs err = self . dll . SearchDevice ( protocol , broadcast_address , buf ) if err < 0 : raise ZKSDKError ( 'SearchDevice failed' , err ) raw = buf . value . decode ( 'utf-8' ) if raw == '\\r\\n' : return [] * lines , _ = raw . split ( \"\\r\\n\" ) return lines","title":"search_device"},{"location":"reference/pyzkaccess/sdk/#set_device_param","text":"def set_device_param ( self , parameters : Mapping [ str , Any ] ) -> None Set given device parameters SDK: SetDeviceParam() :param parameters: dict with parameter names and values to be set. Every value will be casted to string :raises ZKSDKError: :return: View Source def set_device_param ( self , parameters : Mapping [ str, Any ] ) -> None : \"\"\" Set given device parameters SDK: SetDeviceParam() :param parameters: dict with parameter names and values to be set. Every value will be casted to string :raises ZKSDKError: :return: \"\"\" if not parameters : return # Device can accept maximum 20 parameters for one call . See SDK # docs . So send them in loop by bunches of 20 items keys = list ( sorted ( parameters . keys ())) while keys : query_keys = keys [ :20 ] query = ',' . join ( '{}={}' . format ( k , parameters [ k ] ) for k in query_keys ). encode () del keys [ :20 ] err = self . dll . SetDeviceParam ( self . handle , query ) if err < 0 : raise ZKSDKError ( 'SetDeviceParam failed' , err )","title":"set_device_param"}]}